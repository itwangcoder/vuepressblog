---
title: Java基础学习笔记韩顺平上篇
description: Java基础学习笔记韩顺平上篇
author: itwangcoder
date: '2023-12-19'
categories:
 - Java
tags:
 - 韩顺平
 - Java
 - 编程语言
---

# Java基础---韩顺平

## 一、建立编程思想

### 学前详解

#### 就业方向

- Java EE软件工程师
- 大数据软件工程师
- Android软件工程师

#### 应用领域

- 企业级应用
- Android平台应用
- 移动领域应用

### Java概述

什么是程序：计算机执行某些操作或解决某个问题而编写的一系列**有序指令的集合**

#### Java技术体系平台

- Java SE标准版——支持面向桌面级应用的Java平台

- Java EE企业版——是为开发企业环境下的应用程序提供的一套解决方案
- Java ME小型版——支持Java程序运行在移动终端上的平台

#### 特点

1. Java语言是面向对象的
2. Java语言是健壮的，Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证
3. Java语言是跨平台性的
4. Java语言是解释型的

##### 区别

解释性语言：JavaScript、PHP、Java

编译性语言：C/C++

区别：解释性语言，编译后的代码，不能直接被机器 执行，需要解释器来执行，编译性语言，编译后的代码，可以直接被机器执行

#### Java运行机制及运行过程

Java核心机制——Java虚拟机【JVM】

##### 基本介绍

1. JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，包括在**JDK**中
2. 对于不同的平台，有不同的虚拟机
3. Java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”

##### JDK与JRE

1. JDK = JRE + 开发工具集
2. JRE = JVM + Java SE标准类库
3. JDK = JVM + Java SE标准类库 + 开发工具集
4. 如果只想运行开发好的.class文件，只需要JRE

##### Java执行流程

![](Java基础学习笔记韩顺平/Java执行流程.png)

#### Java开发注意事项和细节说明

1. Java源文件以.java为扩展名。源文件的基本组成部分是类(class)，如本类中的Hello类
2. Java应用程序的执行入口是main()方法。它有固定的书写格式：`public static void main(String[] args){……}`
3. Java语言严格区分大小写
4. Java方法由一条条语句构成，每个语句以“;”结束
5. 大括号都是成对出现的，缺一不可。【习惯，想写{}再写代码】
6. 一个源文件中最多只能有一个public类。其他类的个数不限。
7. 如果源文件包含一个public类，则文件名必须按该类名命名
8. 一个源文件中最多只能有一个public类。其它类的个数不限，也可以将main方法写在非public类中，然后指定运行非public类，这样入口方法就是非public类的main方法

##### Java转义字符

- \t：一个制表符，实现对齐的功能
- \n：换行符
- \\\：一个\
- \\"：一个"
- \\'：一个'
- \\r：一个回车——输出后光标会放置当前行首位，后面输出的内容会覆盖之前的内容`System.out.println("好好学习\r天天");`  输出结果为**天天学习**

#### Java基础知识学习

##### Java注释

- 单行注释：// 注释内容

- 多行注释：/* 注释内容 */

- 文档注释：注释内容可以被JDK提供的工具javadoc所解析

  `/** `

  `* @author 汪重阳`

  `* @version 1.0`

  `*/`

`javadoc -d d:\\Code\\SUBJAVA\\Test -author -version ChangeChar.java`

##### Java代码规范

1. 类、方法的注释，要以javadoc的方式来写
2. 非Java Doc的注释，往往是给代码的维护者看的，着重告述读者为什么这样写，如何修改，注意什么问题等
3. 使用tab操作，实现缩进，默认整体向右边移动，时候用shift+tab整体向左移
4. 运算符和 = 两边习惯性各加一个空格。如：2 + 4 * 5 + 345 -89
5. 源文件使用utf-8编码
6. 行宽度不要超过80字符
7. 代码编写次行风格和行尾风格

##### DOS命令

- md 文件路径\\\文件名称——创建文件
- rd 文件路径\\\文件名称——删除文件
- dir 查看当前目录的内容
- cd 
  - cd /D c: 切换到其他盘下
  - cd d:\abc2\test200 切换到当前盘的其他目录下
  - cd .. 切换到上一级
  - cd \ 切换到根目录

- tree 查看指定的目录下 的所有子级目录
- cls 清屏
- exit 退出DOS
- copy 拷贝文件
- del 删除文件
- echo 输入内容到文件
- type 显示文本文件的内容
- move 剪切

### 变量

变量是程序的基本组成单位

基本要素：类型、名称、值

- 概念：变量相当于内存中一个数据存储空间的表示

- 使用步骤：也可以`int a = 60;`
  - 声明变量 `int a;`
  - 赋值 `a = 60;`
  - 使用 `System.out.println(a);`

- 注意事项
  - 变量表示内存中的一个存储区域【不同的变量，类型不同，占用的空间大小不同】
  - 该区域有自己的名称【变量名】和类型【数据类型】
  - 变量必须先声明，后使用，即有顺序
  - 该区域的数据可以在同一类型范围内不断变化
  - 变量在同一个作用域内不能重名
  - 变量 = 变量名 + 值 + 数据类型

- 加号的使用
  - 当左右两边都是数值型时，则做加法运算
  - 当左右两边有一方为字符串时，则做拼接运算
  - 运算顺序，是从左到右

#### 数据类型

1. Java数据类型分为两大类：基本数据类型和引用数据类型
2. 基本数据类型有8种：数值型[byte,short,int,long,float,double],char,boolean
3. 引用类型[类，接口，数组]

- 整数类型细节
  - Java各整数类型有固定的范围和字段长度，不受具体OS【操作系统】的影响，以保证java程序的可移植性
  - Java的整型常量默认为int型，声明long型常量须后加'|'或'L'
  - Java程序中变量常声明为int型，除非不足以表示大数，才使用long
  - bit：计算机中的最小存储单元。byte：计算机中基本存储单元，1byte = 8bit
  - 当把一个具体的数赋给byte时，先判断该数是否在byte范围内，如果是就可以
  
- 浮点类型
  - 关于浮点数在机器中存放形式的简单说明，浮点数 = 符号位 + 指数位 + 尾数位
  - 尾数部分可能丢失，造成精度损失(小数都是近似值)

- 浮点类型细节
  - 与整数类型类型，Java浮点类型也有固定的范围和字段长度，不受具体OS的影响。
  - Java的浮点型常量默认为double型，声明float型常量，须后加'f'或'F'
  - 浮点型常量有两种表示形式
    - 十进制数形式：如 5.12   512.0f   .512
    - 科学计数法形式：如 5.12e2[5.12*10的2次方]   5.12E-2[5.12/10的2次方]
  - 通常情况下，应该使用double型，因为它比float型更精确
  - 浮点数使用陷阱：2.7和8.1/3比较**对运算结果是小数的进行相等判断时，要小心，应该是以两个数的差值的绝对值，在某个精度范围内判断**

- 字符类型细节
  - 字符常量是用单引号括起来 的单个字符
  - Java中还允许使用转义字符'\\'来将其后的字符转变为特殊字符型常量
  - 在Java中，char的本质是一个整数，在输出时，是unicode码对应的字符
  - 可以直接给char赋一个整数，然后输出时，会按照对应的unicode字符输出
  - char类型是可以进行运算的，相当于一个整数，因为它都对应有Unicode码

- 字符编码表
  - ASCII
  - Unicode：固定大小的编码，使用两个字节表示字符，汉字和字母统一都是占用两个字节
  - utf-8：大小可变的编码，字母使用1个字节，汉字使用3个字节
  - gbk：字母使用1个字节，汉字使用2个字节
  - gb2312：gb2312<gbk
  - big5:繁体中文，台湾，香港

- 布尔类型
  - 只占1个字节
  - 不可以使用0或非0的整数替代false和true，这点和C语言不同

#### 数据类型转换

- 自动类型转换
  - 当Java程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数据类型，这个就是自动类型转换
  - 从小到大（char，int，long，float，double）（byte，short，int，long，float，double）

- 自动类型转换细节
  - 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算
  - 当我们把精度(容量)大的数据类型赋值给精度(容量)小的数据类型时，就会报错，反之就会进行自动类型转换
  - (byte，short)和char之间不会相互自动转换
  - byte，short，char他们三者可以计算，在计算时首先转换为int类型
  - boolean不参与转换
  - 自动提升原则：表达式结果的类型自动提升为操作数中最大的类型

- 强制类型转换
  - 自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符()，但可能造成精度降低或溢出，格外要注意

- 强制类型转换细节
  - 当进行数据从大到小，就需要使用到强制转换
  - 强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级
  - char类型可以保存int的常量值，但不能保存int的变量值，需要强转
  - byte和short类型在进行运算时，当做int类型处理

- String数据类型与基本数据类型转换
  - 基本类型转String类型：将基本类型的值+""即可
  - String类型转基本数据类型：通过基本类型的包装类调用parseXX方法即可`int num = Integer.parseInt(str);`
  - 把字符串转成字符char：指把字符串的第一个字符得到`str.charAt(0)`
  - 在将String类型转成基本数据类型 时，要确保String类型能够转成有效的数据，比如我们可以把"123"，转成一个整数，但是不能把"hello"转成一个整数
  - 如果格式不正确，就会抛出异常，程序就会终止，这个问题在异常处理章节中，会处理

### 运算符

运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等

1. 算术运算符：是对数值类型的变量进行运算的，有+、-、/、%、++、--
   1. %的本质是a % b = a - (a / b) * b
   1. 有小数运算时，得到的结果是近似值
2. 赋值运算符：就是将某个运算后的值，赋给指定的变量，有=、+=、-=、*=、/=、%=
   1. 运算顺序从右往左
   2. 赋值运算符的左边只能是变量，右边可以是变量、表达式、常量值
   3. 复合赋值运算符等价于下面的效果
   4. 复合赋值运算符会进行类型转换
3. 关系运算符【比较运算符】：结果都是boolean型，经常用在if结构的条件中或循环结构的条件中，如==、!=、<、>、<=、>=、instanceof
   1. 关系运算符的结果都是boolean型，也就是要么是true，要么是false
   2. 关系运算符 组成的表达式，我们称为关系表达式
   3. 比较运算符"=="不能误写成"="
4. 逻辑运算符：用于连接多个条件（多个关系表达式），最终结果也是一个boolean值，有短路与&&、短路或||、取反!、逻辑与&、逻辑或|、逻辑异或^
   1. &&和&的区别：&&短路与中如果第一个条件为false，则第二个条件不会判断，最终结果为false；&逻辑与中不管第一个条件是否为false，第二个条件都要判断
   2. ||和|的区别：||短路或中如果第一个条件为true，则第二个条件不会判断，最终结果为true；|逻辑或中不管第一个条件是否为true，第二个条件都要判断
   3. 逻辑异或a^b：当a和b不同时，则结果为true，否则为false
5. 位运算符
6. 三元运算符：条件表达式?表达式1:表达式2
   1. 如果条件表达式为true，运算后的结果是表达式1
   2. 如果条件表达式结果为false，运算后的结果是表达式2
   3. 表达式1和表达式2要为可以赋给接收变量的类型（或可以自动转换）
   4. 三元运算符可以转成if--else语句
   5. 三元运算符是一个整体

优先级

- 运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序
- 只有单目运算符、赋值运算符是从右向左运算的
- 优先级排序大致
  - ()，{}等
  - 单目运算符
  - 算术运算符
  - 位移运算符
  - 比较运算符
  - 逻辑运算符
  - 三元运算符
  - 赋值运算符

#### 标识符

概念

- Java对各种变量、方法和类等命名时使用的字符序列称为标识符
- 凡是自己可以起名字的地方都叫标识符

命名规则（必须遵守）

- 由26个英文字母大小写，0-9，_或$组成
- 数字不可以开头
- 不可以使用关键字和保留字，但能包含关键字和保留字
- Java中严格区分大小写，长度无限制
- 标识符不能包含空格

命名规范（更加专业）

- 包名：多单词组成时所有字母都小写
- 类名、接口名：多单词组成时，所有单词的首字母大写
- 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写
- 常量名：所有字母都大写，多单词时每个单词用下划线连接

#### 键盘输入语句

介绍

在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。需要一个扫描器（对象），就是Scanner

步骤

- 导入该类的所在包 java.util.*
- 创建该类对象（声明变量）
- 调用里面的功能

`Scanner myScanner = new Scanner(System.in)`

#### 二进制

- 二进制是逢2进位的进位制，0、1是基本算符
- 现代的电子计算机技术全部采用的是二进制，因为它只使用0、1两个数字符号，非常简单方便，易于用电子方式实现，计算机内部处理的信息，都是采用二进制数来表示的，二进制数用0和1两个数字及其组合来表示任何数。进位的规则是“逢2进1”，数字1在不同的位上代表不同的值，按从右至左的次序，这个值以二倍递增。

##### 原码、反码、补码

1. 二进制的最高位是符号位：0表示正数，1表示负数
2. 正数的原码，反码，补码都一样（三码合一）
3. 负数的反码=它的原码符号位不变，其它位取反
4. 负数的补码=它的反码+1，负数的反码=负数的补码-1
5. 0的反码，补码都是0
6. java没有无符号数，换言之，java中的数都是有符号的
7. 在计算机运算的时候，都是以补码的方式来运算的
8. 当我们看运算结果的时候，要看他的原码

##### 位运算

- 按位与&：两位全为1，结果为1，否则为0
- 按位或|：两位有一个为1，结果为1，否则为0
- 按位异或^：两位一个为0，一个为1，结果为1，否则为0
- 按位取反~：0->1，1->0
- 算术右移>>：低位溢出，符号位不变，并用符号位补溢出的高位
- 算术左移<<：符号位不变，低位补0
- 逻辑右移>>>也叫无符号右移，运算规则是：低位溢出，高位补0
- 特别说明：没有<<<符号

### 控制结构

#### 流程控制

- 顺序控制：程序从上到下逐行地执行，中间没有任何判断和跳转

- 分支控制

  - 单分支

    基本语法：

    `if(条件表达式){`

    ​	`执行代码块;(可以有多条语句。)`

    `}`

    说明：当条件表达式为true时，就会执行{}的代码。如果为false，就不执行。特别说明，如果{}中只有一条语句，则可以不用{}，建议写上{}

  - 双分支

    基本语法：

    `if(条件表达式){`

    ​	`执行代码块1;`

    `}else{`

    ​	`执行代码块2;`

    `}`

    说明：当条件表达式成立，即执行代码块1，否则执行代码块2。如果执行代码块只有一条语句，则{}可以省略，否则，不能省略。

  - 多分支

    基本语法：

    `if(条件表达式1){`

    ​	`执行代码块1;`

    `}else if(条件表达式2){`

    ​	`执行代码块2;`

    `}`

    `......`

    `else{`

    ​	`执行代码块n;`

    `}`

    说明：

    1. 当条件表达式1成立时，即执行代码块1
    2. 如果表达式1不成立，才去判断表达式2是否成立
    3. 如果表达式2成立，就执行代码块2
    4. 以此类推，如果所有的表达式都不成立
    5. 则执行else的代码块，注意，只能有一个执行入口
    6. 多分支可以没有else，如果所有的条件表达式都不成立，则一个执行入口都没有
    7. 如果有else，如果所有的条件表达式都不成立，则默认执行else代码块

  - 嵌套分支

    基本介绍：在一个分支结构中又完整的嵌套了另一个完整的分支结构，里面的分支的结构称为内分支外面的分支结构称为外层分支。规范：不要超过3层（可读性不好）

    基本语法

    `if(){`

    ​	`if(){`

    ​		`//if-else`

    ​	`}else{`

    ​		`//if-else`

    ​	`}`

    `}`

  - switch分支结构

    基本语法

    `switch(表达式){`

    ​	`case 常量1:语句块1;break;`

    ​	`case 常量2:语句块2;break;`

    ​	`...`

    ​	`case 常量n:语句块n;break;`

    ​	`default:default语句块;break;`

    `}`

    说明：

    1. switch关键字，表示switch分支
    2. 表达式对应一个值
    3. case 常量1:当表达式的值等于常量1，就执行语句块1
    4. break：表示退出switch
    5. 如果和case 常量 1匹配，就执行语句块1，如果没有匹配，就继续匹配case 常量2
    6. 如果一个都没有匹配上，执行default

    switch注意事项与细节讨论

    1. 表达式数据类型，应和case后的常量类型一致，或者是可以自动转成可以相互比较的类型，比如输入的是字符，而常量是int
    2. switch(表达式)中表达式的返回值必须是：(byte,short,int,char,enum,String)
    3. case子句中的值必须是常量，而不能是变量
    4. default子句是可选的，当没有匹配的case时，执行default
    5. break语句用来执行完一个case分支后使程序跳出switch语句块；如果没有写break，程序会顺序执行到switch结尾

- 循环控制

  - for循环控制

    基本介绍：就是让你的代码可以循环的执行

    基本语法

    `for(循环变量初始化;循环条件;循环变量迭代){循环操作(可以多条语句);}`

    说明

    1. for关键字，表示循环控制
    2. for有四要素：循环变量初始化；循环条件；循环操作；循环变量迭代
    3. 循环操作，这里可以有多条语句，也就是我们要循环执行的代码
    4. 如果循环操作只有一条语句，可以省略{}，建议不要省略

    注意事项和细节说明

    1. 循环条件是返回一个布尔值的表达式
    2. for(;循环判断条件;)中的初始化和变量迭代可以写到其它地方，但是两边的分号不能省略
    3. 循环初始值可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开

    编程思想
  
    1. 化繁为简：即将复杂的需求，拆解成简单的需求，逐步完成
    2. 先死后活：先考虑固定的值，然后转成可以灵活变化的值
  
  - while循环控制
  
    基本语法
  
    `循环变量初始化;`
  
    `while(循环条件){`
  
    ​	`循环体(语句);`
  
    ​	`循环变量迭代;`
  
    `}`
  
    说明
  
    1. while循环也有四要素
    2. 只是四要素放的位置，不一样
  
  - do...while循环控制
  
    基本语法
  
    `循环变量初始化;`
  
    `do{`
  
    ​	`循环体(语句);`
  
    ​	`循环变量迭代;`
  
    `}while(循环条件);`
  
    说明
  
    1. do while是关键字
    2. 也有循环四要素，只是位置不一样
    3. 先执行，再判断，也就是说，一定会执行一次
    4. 最后有一个分号;
    5. while和do...while区别举例：要账
  
    注意事项和细节说明
  
    1. 循环条件是返回一个布尔值的表达式
    2. do...while循环是先执行，再判断，因此它至少执行一次
  
  - 多重循环控制
  
    介绍
  
    1. 将一个循环放在另一个循环体内，就形成了嵌套循环。其中，for，while，do...while均可以作为外层循环和内层循环。【建议一般使用两层，最多不要超过3层，否则，代码的可读性很差】
    2. 实质上，嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环 的循环条件为false时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的循环【听不懂，走案例】
    3. 设外层循环次数为m次，内层为n次，则内层循环体实际上需要执行m*n次
  
  - 跳转控制语句break
  
    基本介绍：break语句用于终止某个语句块的执行，一般使用在switch或者循环中
  
    基本语法：
  
    `{`
  
    ​	`......`
  
    ​	`break;`
  
    ​	`......`
  
    `}`
  
    注意事项和细节说明
  
    1. break语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是哪一层语句块
  
    2. 标签的基本使用
  
       `label1:{......`
  
       `label2:	{......`
  
       `label3:		{......`
  
       ​			`break label2;`
  
       ​			`......`
  
       ​		`}`
  
       ​	`}`
  
       `}`
  
       1. break语句可以指定退出哪层 
       2. label1是标签，由程序员指定
       3. break后指定到哪个label就退出到哪里
       4. 在实际的开发中，尽量不要使用标签
       5. 如果没有指定break，默认退出最近的循环体
  
  - 跳转控制语句continue
  
    基本介绍
  
    1. continue语句用于结束本次循环，继续执行下一次循环
    2. continue语句出现多层嵌套的循环语句体中，可以通过标签指明要跳过的是哪一层循环，这个和前面的标签的 使用的规则一样
  
    基本语法
  
    `{`
  
    ​	`......`
  
    ​	`continue;`
  
    ​	`......`
  
    `}`
  
  - 跳转控制语句return
  
    介绍：return使用在方法，表示跳出所在的方法
  
    注意：如果return写在main方法，退出程序


### 数组、排序和查找

#### 数组

数组介绍：数组可以存放多个同一类型的数据。数组也是一种数据类型，是引用类型。即：数组就是一组数据

##### 数组的使用

- 使用方式1-动态初始化

  - 数组的定义：

    数据类型 数组名[] = new 数据类型[大小]  或者  数据类型[] 数组名 = new 数据类型[大小]

    `int a[] = new int[5];	//创建了一个数组，名字a，存放5个int`

    说明：这是定义数组的一种方法。

  - 数组的引用：数组名[下标/索引]，数组的下标从0开始。比如：你要使用a数组的第3个数  a[2]

- 使用方式2-动态初始化

  - 先声明数组

    语法：数据类型 数组名[];  也可以  数据类型[] 数组名; 

    `int a[];  或者  int[] a;`

  - 创建数组

    语法：数组名 = new 数据类型[大小];

    `a = new int[10];`

- 使用方式3-静态初始化

  - 初始化数组

    语法：数据类型 数组名[] = {元素值，元素值，...}

    `int a[] = {2, 5, 6, 7, 8, 89, 90, 34, 56}`

- 数组的使用注意事项和细节
  1. 数组是多个相同类型数据的组合，实现对这些数据的统一管理
  2. 数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用
  3. 数组创建后，如果没有赋值，有默认值。int 0，short 0，byte 0，long 0，float 0，double 0.0，char \u0000，boolean false，String null
  4. 使用数组的步骤：(1)声明数组并开辟空间 (2)给数组各个元素赋值 (3)使用数组
  5. 数组的下标是从0开始的
  6. 数组下标必须在指定范围内使用，否则报：下标越界异常，比如`int[] arr = new int[5];  //则有效下标为0-4`
  7. 数组属引用类型，数组型数据是对象(object)

##### 数组赋值机制

1. 基本数据类型赋值，这个值就是具体的数据，而且相互不影响

   `int n1 = 2;`  

   `int n2 = n1;`

2. 数组在默认情况下是引用传递，赋的值是地址

##### 数组添加

要求：实现动态的给数组添加元素效果，实现对数组扩容

1. 原始数组使用静态分配`int[] arr = {1, 2, 3}`
2. 增加的元素，直接放在数组的最后`arr = {1, 2, 3, 4}`
3. 用户可以通过如下方法来决定是否继续添加，添加成功，是否继续？y/n

#### 排序  

##### 排序的介绍

排序是将一群数据，依指定的顺序进行排列的过程

分类

1. 内部排序：指将需要处理的所有数据都加载到内部存储器中进行排序。包括（交换式排序法、选择式排序法和插入式排序法）；
2. 外部排序法：数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括（合并排序法和直接合并排序法）。

##### 冒泡排序

基本思想：通过对待排序序列从后向前（从下标较大的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就像水底下的气泡一样逐渐向上冒

特点：

1. 我们一共有5个元素
2. 一共进行了4轮排序，可以看成是外层循环
3. 每1轮排序可以确定一个数的位置，比如第1轮排序确定最大数，第2轮排序确定第2大的数位置，依次类推
4. 当进行比较时，如果前面的数大于后面的数，就交换
5. 每轮比较在减少4->3->2->1

#### 查找

介绍：在java中，我们常用的查找有两种：

1. 顺序查找 
2. 二分查找

#### 二维数组

- 使用方式1：动态初始化
  1. 语法：类型\[\]\[\] 数组名 = new 类型\[大小\]\[大小\]
  2. 比如：`int a[][] = new int[2][3]`

- 使用方式2：动态初始化
  1. 先声明：类型 数组名\[\]\[\];
  2. 再定义（开辟空间）数组名 = new 类型\[大小\]\[大小\];
  3. 赋值（有默认值，比如int类型的就是0）
- 使用方式3：动态初始化-列数不确定
  1. 看需求：动态创建二维数组，并输出

- 使用方式4：静态初始化
  1. 定义：类型 数组名\[]\[] = \\{\{值1,值2...},\{值1,值2...},\{值1,值2...}\\}
  > 备注：需要去除反斜杠来看，否则会报错，页面无法显示
  2. 使用即可[固定方式访问]

- 使用细节和注意事项
  1. 声明方式：`int[][] y`或者`int[] y[]`或者`int y[][]`
  2. 二维数组实际上是由多个一维数组组成的，它的各个一维数组的长度可以相同，也可以不同

### 面向对象编程（基础）

#### 类与对象

- 使用现有技术解决
  1. 单独的定义变量解决
  2. 使用数组解决
- 现有技术解决的缺点分析
  - 不利于数据的管理
  - 效率低==》引出我们的新知识点-类与对象、哲学、道家
  - java设计者引入类与对象（OOP），根本原因就是现有的技术，不能完美的解决新的需求

- 类与对象的关系
  - 类就是数据类型
  - 对象就是一个具体的实例

- 类与对象的区别与联系
  - 类是抽象的，概念的，代表一类事物，即它是数据类型
  - 对象是具体的，实际的，代表一个具体事物，即实例
  - 类是对象的模板，对象是类的一个个体，对应一个实例

- 属性/成员变量

  - 基本介绍
    1. 从概念或叫法上看：成员变量 = 属性 = field（字段）（即成员变量是用来表示属性的，授课中，统一叫属性）
    2. 属性是类的一个组成部分，一般是基本数据类型，也可是引用类型（对象，数组）

  - 注意事项和细节说明

    1. 属性的定义语法同变量，示例：访问修饰符 属性类型 属性名；

       修饰符：控制属性的访问范围：public，proctected，default，private

    2. 属性的定义类型可以为任意类型，包含基本类型或引用类型

    3. 属性如果不赋值，有默认值，规则和数组一致

- 创建对象

  1. 先声明再创建

     `Cat cat;`

     `cat = new Cat();`

  2. 直接创建

     `Cat cat = new Cat();`

- 访问属性

  基本语法：对象名.属性名;

- 类和对象的内存分配机制

  - Java内存的结构分析
    1. 栈：一般存放基本数据类型（局部变量）
    2. 堆：存放对象（Cat cat，数组等）
    3. 方法区：常量池（常量，比如字符串），类加载信息
    4. 示意图[Cat(name,age,price)]

  - Java创建对象的流程简单分析
    1. 先加载Person类信息（属性和方法信息，只会加载一次）
    2. 在堆中分配空间，进行默认初始化（看规则）
    3. 把地址赋给p，p就指向对象
    4. 进行指定初始化，比如 `p.name = "jack"`

#### 成员方法

- 基本介绍：在某些情况下，我们需要定义成员方法（简称方法）。比如人类：除了有一些 属性外（年龄，姓名...），我们人类还有一些行为比如：可以说话、跑步...，通过学习，还可以做算术题。这时就要用成员方法才能完成

- 方法调用小结
  1. 当程序执行到方法时，就会开辟一个独立的空间（栈空间）
  2. 当方法执行完毕，或者执行到return语句时，就会返回
  3. 返回到调用方法的地方
  4. 返回后，继续执行方法后面的代码
  5. 当main方法（栈）执行完毕，整个程序退出

- 成员方法的好处
  - 提高代码的复用性
  - 可以将实现的细节封装起来，然后供其他用户来调用即可

- 成员方法的定义

  `public 返回数据类型 方法名(参数列表...){//方法体`

    `语句;`

    `return 返回值;`

  `}`

  1. 参数列表：表示成员方法输入cal(int n)
  2. 数据类型（返回类型）：表示成员方法输出，void表示没有返回值
  3. 方法主体：表示为了实现某一功能代码块
  4. return语句不是必须的
  5. 老韩提示：结合前面的题示意图，来理解

- 注意事项和使用细节
  - 修饰符（作用是控制方法使用的范围）（有四种：public，protected，默认，private）
  - 返回类型
    1. 一个方法最多有一个返回值
    2. 返回类型可以为任意类型，包含基本类型或引用类型（数组，对象）
    3. 如果方法要求有返回数据类型，则方法体中最后的执行语句必须为return；而且要求返回值类型必须和return的值类型一致或兼容
    4. 如果方法是void，则方法体中可以没有return语句，或者只写return
  - 方法名：遵循驼峰命名法，最好见名知义
  - 参数列表
    1. 一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开，比如`getSum(int n1, int n2)`
    2. 参数类型可以为任意类型，包含基本类型或引用类型
    3. 调用带参的方法时，一定对应着参数列表传入相同类型或兼容类型的参数
    4. 方法定义时的参数称为形式参数，简称形参；方法调用时的参数称为实际参数，简称实参，实参和形参的类型要一致或兼容、个数、顺序必须一致
  - 方法体：里面写完成功能的具体的语句，可以为输入、输出、变量、运算、分支、循环、方法调用，但里面不能再定义方法！即：方法不能嵌套定义
  - 方法细节调用说明
    1. 同一个类中的方法调用：直接调用即可
    2. 跨类中的方法A类调用B类方法：需要通过对象名调用。比如 对象名.方法名(参数);
    3. 特别说明：跨类的方法调用和方法的访问修饰符相关

- 成员方法传参机制

  - 基本数据类型的传参机制：基本数据类型，传递的是值（值拷贝），形参的任何改变不影响实参！

  - 引用数据类型的传参机制：引用类型传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参！


- 方法递归调用

  基本介绍：简单的说：递归就是方法自己调用自己，每次调用时传入不同的变量。递归有助于编程者解决复杂问题，同时可以让代码变得简洁。

  解决的问题

  1. 各种数学问题如：8皇后问题，汉诺塔，阶乘问题，迷宫问题，球和篮子的问题（google编程大赛）
  2. 各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等
  3. 将用栈解决的问题-->递归代码比较简洁

- 递归重要规则
  1. 执行一个方法时，就创建一个新的受保护的独立空间（栈空间）
  2. 方法的局部变量是独立的，不会相互影响，比如n变量
  3. 如果方法中使用的是引用类型变量（比如数组），就会共享该引用类型的数据
  4. 递归必须向退出递归的条件逼近，否则就是无限递归，出现StackOverflowError，死龟了:）
  5. 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕

#### 重载（overload）

- 基本介绍：Java中允许同一个类中，多个同名方法的存在，但要求形参列表不一致！比如：`System.out.println();`out是PrintStream类型
- 好处
  1.  减轻了起名的麻烦
  2. 减轻了记名的麻烦
- 注意事项和使用细节
  1. 方法名：必须相同
  2. 形参列表：必须不同（形参类型或个数或顺序，至少有一样不同，参数名无要求）
  3. 返回类型：无要求

#### 可变参数

- 基本概念：Java允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法

- 基本语法

  `访问修饰符 返回类型 方法名(数据类型...形参名){}`

  使用可变参数时，可以当作数组来使用

- 注意事项和使用细节
  1. 可变参数的实参可以为0个或任意多个
  2. 可变参数的实参可以为数组
  3. 可变参数的本质就是数组
  4. 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后
  5. 一个形参列表中只能出现一个可变参数

#### 作用域

- 基本使用

  1. 在Java编程中，主要的变量就是属性（成员变量）和局部变量

  2. 我们说的局部变量一般是指在成员方法中定义的变量

  3. Java中作用域的分类

     全局变量：也就是属性，作用域为整个类体

     局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中！

  4. 全局变量可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值

- 注意事项和细节说明

  1. 属性和局部变量可以重名，访问时遵循就近原则

  2. 在同一个作用域中，比如在同一个成员方法中，两个局部变量，不能重名

  3. 属性生命周期较长，伴随着对象的创建而创建，伴随着对象的死亡而死亡。局部变量，生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而死亡。即在一次方法调用过程中。

  4. 作用域不同

     全局变量：可以被本类使用，或其他类使用（通过对象调用）

     局部变量：只能在本类中对应的方法中使用

  5. 修饰符不同

     全局变量/属性可以加修饰符

     局部变量不可以加修饰符

#### 构造器

- 基本语法

  `[修饰符] 方法名(形参列表){`

  ​	`方法体;`

  `}`

- 说明
  1. 构造器的修饰符可以默认
  2. 构造器没有返回值
  3. 方法名和类名字必须一样
  4. 参数列表和成员方法一样的规则
  5. 构造器的调用由系统完成

- 基本介绍

  构造方法又叫构造器（constructor），是类的一种特殊的方法，它的主要作用是完成对新对象的初始化

  特点：

  1. 方法名和类名相同
  2. 没有返回值
  3. 在创建对象时，系统会自动的调用该类的构造器完成对对象的初始化

- 注意事项和使用细节
  1. 一个类可以定义多个不同的构造器，即构造器重载
  2. 构造器名和类名要相同
  3. 构造器没有返回值
  4. 构造器是完成对象的初始化，并不是创建对象
  5. 在创建对象时，系统自动的调用该类的构造方法
  6. 如果程序员没有定义构造方法，系统会自动给类生成一个默认无参构造器（也叫默认构造器）
  7. 一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下

- 反编译指令 `javap 文件名.class`
- 对象创建流程信息
  1. 加载Person类信息（Person.class），只会加载一次
  2. 在堆中分配空间（地址）
  3. 完成对象初始化【3.1 默认初始化-给类型默认初始值；3.2 显式初始化-`int age = 10;`；3.3 构造器的初始化】
  4. 在对象在堆中的地址，返回给P（P是对象名，也可以理解成是对象的引用）

#### this

- 概念：Jav a虚拟机会给每个对象分配this，代表当前对象
- 注意事项和使用细节
  1. this关键字可以用来访问本类的属性、方法、构造器
  2. this用于区分当前类的属性和局部变量
  3. 访问成员方法的语法：this.方法名(参数列表);
  4. 访问构造器语法：this(参数列表);注意只能在构造器中使用（即只能在构造器中访问另外一个构造器，必须放在第一条语句）
  5. this不能在类定义的外部使用，只能在类定义的方法中使用

### 面向对象编程（中级）

#### IDEA

- IDEA的基本介绍和使用：IDEA是以项目的概念，来管理我们的java源码的
- 常用快捷键
  - 删除当前行，默认是 ctrl + Y，自己配置 ctrl + d
  - 复制当前行，自己配置 ctrl + alt + 向下光标
  - 补全代码 alt + /
  - 添加注释和取消注释 ctrl + /【第一次是添加注释，第二次是取消注释】
  - 导入该行需要的类，先配置auto import，然后使用 alt + enter 即可
  - 快速格式化代码 ctrl + alt + L
  - 快速运行程序，自己定义 alt + R
  - 生成构造方法等 alt + insert 【提高开发效率】
  - 查看一个类的层级关系 ctrl + H【学习继承后，非常有用】
  - 将光标放在一个方法上，输入 ctrl + B，可以选择定位到哪个类的方法【学继承后，非常有用】
  - 自动的分配变量名，通过在后面 .var

- 模板/自定义模板

  file -> settings -> editor -> Live templates

#### 包

- 三大作用
  - 区分相同名字的类
  - 当类很多时，可以很好的管理类【看Java API文档】
  - 控制访问范围

- 基本语法

  `package com.hspedu;`

  1. package关键字，表示打包
  2. com.hspedu：表示包名

- 包的本质：包实际上就是创建不同的文件夹来保存类文件

- 包的命名

  命名规 则：只能包含数字、字母、下划线、小圆点，但不能是关键字或保留字

  命名规范：一般是小写字母 + 小圆点，一般是`com.公司名.项目名.业务逻辑块`

- 常用的包
  - `java.lang.*`，lang包是基本包，默认引入，不需要再引入
  - `java.util.*`，util包，系统提供的工具包，工具类，使Scanner
  - `java.net.*`，网络包，网络开发
  - `java.awt.*`，是做java的界面开发，GUI

- 引入包：语法：`import 包;`
- 注意事项和使用细节
  1. package 的作用是声明当前类所在的包，需要放在class 的最上面，一个类中最多只有一句package
  2. import 指令，位置放在package的下面，在类定义前面，可以有多句且没有顺序要求

#### 访问修饰符

- 基本介绍：java提供四种访问控制修饰符号控制方法和属性（成员变量）的访问权限（范围）
  1. 公开级别：用public修饰，对外公开
  2. 受保护级别：用protected修饰，对子类和同一个包中的类公开
  3. 默认级别：没有修饰符号，向同一个包的类公开
  4. 私有级别：用private修饰，只有类本身可以访问，不对外公开

- 使用的注意事项
  1. 修饰符可以用来修饰类中的属性，成员方法以及类
  2. 只有默认的和public才能修饰类！，并且遵循上述访问权限的特点
  3. 成员方法的访问规则和属性完全一样

#### 封装

面向对象编程三大特征：封装、继承和多态

- 介绍：封装就是把抽象出的数据【属性】和对数据的操作【方法】封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作【方法】，才能对数据进行操作
- 封装的理解和好处
  1. 隐藏实现细节
  2. 可以对数据进行验证，保证安全合理

- 封装实现步骤

  1. 将属性进行私有化【不能直接修改属性】

  2. 提供一个公共的(public)set方法，用于对属性判断并赋值

     `public void setXxx(类型 参数名){`

     ​	`属性 = 参数名;	//加入数据验证的业务逻辑`

     `}`

  3. 提供一个公共的(public)get方法，用于获取属性的值

     `public XX getXxx(){//权限判断`

     ​	`return xx;`

     `}`

#### 继承

- 基本介绍：继承可以解决代码复用，让我们的编程更加靠近人类思维，当多个类存在相同的属性（变量）和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过extends来声明继承父类即可

- 基本语法

  `class 子类 extends 父类{}`

  1. 子类就会自动拥有父类定义的属性和方法
  2. 父类又叫超类，基类
  3. 子类又叫派生类

- 继承细节问题

  1. 子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问，但是私有属性和方法不能在子类直接访问，要通过公共的方法去访问

  2. 子类必须调用父类的构造器，完成父类的初始化

  3. 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过

  4. 如果希望指定去调用父类的某个构造器，则显式的调用 一下super(参数列表)

  5. super在使用时，需要放在构造器第一行(super只能在构造器中使用)

  6. super()和this()都只能放在构造器第一行，因此这两个方法不能共存在一个构造器

  7. java所有类都是Object类的子类，Object类是所有类的基类

  8. 父类构造器的调用不限于直接父类！将一直往上追溯直到Object类（顶级父类）

  9. 子类最多只能继承一个父类（指直接继承），即java中是单继承机制

  10. 不能滥用继承 ，子类和父类之间必须满足is-a的逻辑关系

      `Person is a Music?`

      `Person Music`

      `Music extends Person	// 不合理`

      `Animal`

      `Cat extends Animal	// 合理`

- 继承本质：当子类对象创建好后，建立查找的关系

#### 多态

- 基本介绍：方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。

- 具体体现
  1. 方法的多态，重写和重载就体现多态
  
  2. 对象的多态
  
     （1）一个对象的编译类型和运行类型可以不一致
  
     （2）编译类型在定义对象时，就确定了，不能改变
  
     （3）运行类型是可以变化的，通过getClass()来查看运行
  
     （4）编译类型看定义时 = 号的左边，运行类型看 = 号的右边

- 注意事项和细节讨论

  前提：两个对象（类）存在继承关系

  向上转型

  1. 本质：父类的引用指向了子类的对象
  2. 语法：父类类型 引用名 = new 子类类型();
  3. 特点：编译类型看左边，运行类型看右边。可以调用父类中的所有成员（需遵守访问权限），不能调用 子类中的特有成员；最终运行效果看子类的具体实现！

  向下转型

  1. 语法：子类类型 引用名 = （子类类型） 父类引用;
  2. 只能强转父类的引用，不能强转父类的对象
  3. 要求父类的引用必须指向的是当前目标类型的对象
  4.   当向下转型后， 可以调用子类类型中所有的成员

  属性没有重写之说！属性的值看编译类型

  instanceof 比较操作符，用于判断对象的运行类型是否为XX类型或XX类型的子类型

- Java动态绑定机制
  1. 当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定
  2. 当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用

- 多态的应用
  1. 多态数组：数组的定义类型为父类类型，里面保存的实际元素类型为子类类型
  2. 多态参数：方法定义的形参类型为父类类型，实参类型允许为子类类型

#### Super

- 基本介绍：super代表父类的引用，用于访问父类的属性、方法、构造器
- 基本语法
  1. 访问父类的属性，但不能访问父类的private属性`super.方法名(参数列表);`
  2. 访问父类的方法，不能访问父类的private方法`super.方法名(参数列表);`
  3. 访问父类的构造器：`super(参数列表);`只能放在构造器的第一句，只能出现一句！

- super给编程带来的便利
  1. 调用父类的构造器的好处（分工明确，父类属性由父类初始化，子类的属性由子类初始化）
  2. 当子类中有和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果！
  3. super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类（上级类）中都有同名的成员，使用super访问遵循就近原则

- super和this的比较
  1. 访问属性：this访问本类中的属性，如果本类没有此属性则从父类中继续查找；super访问父类中的属性
  2. 调用方法：this访问本类中的方法，如果本类没有此方法则从父类继续查找；super直接访问父类中的方法
  3. 调用构造器：this调用本类构造器，必须放在构造器的首行；super调用父类构造器，必须放在子类构造器的首行
  4. 特殊：this表示当前对象；super子类中访问父类对象

#### overwrite

- 基本介绍：方法覆盖就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这个方法覆盖了父类的那个方法
- 注意事项和使用细节：方法重写也叫方法覆盖
  1. 子类的方法的参数，方法名称，要和父类方法的参数，方法名称完全一样
  2. 子类方法的  返回类型和父类方法返回类型一样，或者是父类返回类型的子类
  3. 子类方法不能缩小父类方法的访问权限

| 名称           | 发生范围 | 方法名   | 形参列表                         | 返回类型                                                     | 修饰符                             |
| -------------- | -------- | -------- | -------------------------------- | ------------------------------------------------------------ | ---------------------------------- |
| 重载(overload) | 本类     | 必须一样 | 类型，个数或者顺序至少有一个不同 | 无需求                                                       | 无需求                             |
| 重写(override) | 父子类   | 必须一样 | 相同                             | 子类重写的方法，返回的类型和父类返回的类型一致，或者是其子类 | 子类方法不能缩小父类方法的访问范围 |

#### Object类详解

- equals方法

  ==和equals的对比

  ==是一个比较运算符 

  1. ==：既可以判断基本类型，又可以判断引用类型
  2. ==：如果判断基本类型，判断的是值是否相等
  3. ==：如果判断引用类型，判断的是地址是否相等，即判定是不是同一个对象
  4. equals：是Object类中的方法，只能判断引用类型
  5. 默认判断的是地址是否相等 ，子类中往往重写该方法，用于判断内容是否相等

- hashCode方法
  1. 提高具有哈希结构的容器的效率
  2. 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！
  3. 两个引用，如果指向的是不同对象，则哈希值是不一样的
  4. 哈希值主要根据地址号来的！不能完全将哈希值等价于地址

- toString方法
  - 基本介绍：默认返回：全类名 + @ + 哈希值的十六进制，【查看Object的toString方法】子类往往重写toString方法，用于返回对象的属性信息
  - 重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式
  - 当直接输出一个对象时，toString方法会被默认的调用

- finalize方法

  1. 当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作

  2. 什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize方法

  3. 垃圾回收机制的调用，是由系统来决定（即有自己的GC算法），也可以通过System.gc()主动触发垃圾回收机制

     提示：我们在实际开发中，几乎不会运用finalize，所以更多就是为了应付面试

#### 断点调试（debug）

- 一个实际需求
  1. 在开发中，新手程序员在查找错误时，这时老程序员就会温馨提示，可以用断点调试一步一步的看源码执行的过程，从而发现错误所在
  2. 重要提示：在断点调试过程中，是运行状态，是以对象的运行类型来执行的
- 断点调试介绍
  1. 断点调试是指在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。进行分析从而找到这个Bug
  2. 断点调试也是程序员必须掌握的技能
  3. 断点调试也能帮助我们查看java底层源代码的执行过程，提高程序员的Java水平

- 快捷键

  F7（跳入）：跳入方法内、F8（跳过）：逐行执行代码、shift+F8（跳出）：跳出方法、F9（resume，执行到下一个断点）

- 断点技巧：断点可以在debug过程中，动态的下断点




