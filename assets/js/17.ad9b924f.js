(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{441:function(v,_,l){"use strict";l.r(_);var i=l(2),a=Object(i.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"java基础-韩顺平"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java基础-韩顺平"}},[v._v("#")]),v._v(" Java基础---韩顺平")]),v._v(" "),_("h2",{attrs:{id:"一、建立编程思想"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、建立编程思想"}},[v._v("#")]),v._v(" 一、建立编程思想")]),v._v(" "),_("h3",{attrs:{id:"学前详解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#学前详解"}},[v._v("#")]),v._v(" 学前详解")]),v._v(" "),_("h4",{attrs:{id:"就业方向"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#就业方向"}},[v._v("#")]),v._v(" 就业方向")]),v._v(" "),_("ul",[_("li",[v._v("Java EE软件工程师")]),v._v(" "),_("li",[v._v("大数据软件工程师")]),v._v(" "),_("li",[v._v("Android软件工程师")])]),v._v(" "),_("h4",{attrs:{id:"应用领域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#应用领域"}},[v._v("#")]),v._v(" 应用领域")]),v._v(" "),_("ul",[_("li",[v._v("企业级应用")]),v._v(" "),_("li",[v._v("Android平台应用")]),v._v(" "),_("li",[v._v("移动领域应用")])]),v._v(" "),_("h3",{attrs:{id:"java概述"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java概述"}},[v._v("#")]),v._v(" Java概述")]),v._v(" "),_("p",[v._v("什么是程序：计算机执行某些操作或解决某个问题而编写的一系列"),_("strong",[v._v("有序指令的集合")])]),v._v(" "),_("h4",{attrs:{id:"java技术体系平台"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java技术体系平台"}},[v._v("#")]),v._v(" Java技术体系平台")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("Java SE标准版——支持面向桌面级应用的Java平台")])]),v._v(" "),_("li",[_("p",[v._v("Java EE企业版——是为开发企业环境下的应用程序提供的一套解决方案")])]),v._v(" "),_("li",[_("p",[v._v("Java ME小型版——支持Java程序运行在移动终端上的平台")])])]),v._v(" "),_("h4",{attrs:{id:"特点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[v._v("#")]),v._v(" 特点")]),v._v(" "),_("ol",[_("li",[v._v("Java语言是面向对象的")]),v._v(" "),_("li",[v._v("Java语言是健壮的，Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证")]),v._v(" "),_("li",[v._v("Java语言是跨平台性的")]),v._v(" "),_("li",[v._v("Java语言是解释型的")])]),v._v(" "),_("h5",{attrs:{id:"区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[v._v("#")]),v._v(" 区别")]),v._v(" "),_("p",[v._v("解释性语言：JavaScript、PHP、Java")]),v._v(" "),_("p",[v._v("编译性语言：C/C++")]),v._v(" "),_("p",[v._v("区别：解释性语言，编译后的代码，不能直接被机器 执行，需要解释器来执行，编译性语言，编译后的代码，可以直接被机器执行")]),v._v(" "),_("h4",{attrs:{id:"java运行机制及运行过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java运行机制及运行过程"}},[v._v("#")]),v._v(" Java运行机制及运行过程")]),v._v(" "),_("p",[v._v("Java核心机制——Java虚拟机【JVM】")]),v._v(" "),_("h5",{attrs:{id:"基本介绍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基本介绍"}},[v._v("#")]),v._v(" 基本介绍")]),v._v(" "),_("ol",[_("li",[v._v("JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，包括在"),_("strong",[v._v("JDK")]),v._v("中")]),v._v(" "),_("li",[v._v("对于不同的平台，有不同的虚拟机")]),v._v(" "),_("li",[v._v("Java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”")])]),v._v(" "),_("h5",{attrs:{id:"jdk与jre"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jdk与jre"}},[v._v("#")]),v._v(" JDK与JRE")]),v._v(" "),_("ol",[_("li",[v._v("JDK = JRE + 开发工具集")]),v._v(" "),_("li",[v._v("JRE = JVM + Java SE标准类库")]),v._v(" "),_("li",[v._v("JDK = JVM + Java SE标准类库 + 开发工具集")]),v._v(" "),_("li",[v._v("如果只想运行开发好的.class文件，只需要JRE")])]),v._v(" "),_("h5",{attrs:{id:"java执行流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java执行流程"}},[v._v("#")]),v._v(" Java执行流程")]),v._v(" "),_("p",[_("img",{attrs:{src:"Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/Java%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png",alt:""}})]),v._v(" "),_("h4",{attrs:{id:"java开发注意事项和细节说明"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java开发注意事项和细节说明"}},[v._v("#")]),v._v(" Java开发注意事项和细节说明")]),v._v(" "),_("ol",[_("li",[v._v("Java源文件以.java为扩展名。源文件的基本组成部分是类(class)，如本类中的Hello类")]),v._v(" "),_("li",[v._v("Java应用程序的执行入口是main()方法。它有固定的书写格式："),_("code",[v._v("public static void main(String[] args){……}")])]),v._v(" "),_("li",[v._v("Java语言严格区分大小写")]),v._v(" "),_("li",[v._v("Java方法由一条条语句构成，每个语句以“;”结束")]),v._v(" "),_("li",[v._v("大括号都是成对出现的，缺一不可。【习惯，想写{}再写代码】")]),v._v(" "),_("li",[v._v("一个源文件中最多只能有一个public类。其他类的个数不限。")]),v._v(" "),_("li",[v._v("如果源文件包含一个public类，则文件名必须按该类名命名")]),v._v(" "),_("li",[v._v("一个源文件中最多只能有一个public类。其它类的个数不限，也可以将main方法写在非public类中，然后指定运行非public类，这样入口方法就是非public类的main方法")])]),v._v(" "),_("h5",{attrs:{id:"java转义字符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java转义字符"}},[v._v("#")]),v._v(" Java转义字符")]),v._v(" "),_("ul",[_("li",[v._v("\\t：一个制表符，实现对齐的功能")]),v._v(" "),_("li",[v._v("\\n：换行符")]),v._v(" "),_("li",[v._v("\\\\：一个\\")]),v._v(" "),_("li",[v._v('\\"：一个"')]),v._v(" "),_("li",[v._v("\\'：一个'")]),v._v(" "),_("li",[v._v("\\r：一个回车——输出后光标会放置当前行首位，后面输出的内容会覆盖之前的内容"),_("code",[v._v('System.out.println("好好学习\\r天天");')]),v._v("  输出结果为"),_("strong",[v._v("天天学习")])])]),v._v(" "),_("h4",{attrs:{id:"java基础知识学习"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java基础知识学习"}},[v._v("#")]),v._v(" Java基础知识学习")]),v._v(" "),_("h5",{attrs:{id:"java注释"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java注释"}},[v._v("#")]),v._v(" Java注释")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("单行注释：// 注释内容")])]),v._v(" "),_("li",[_("p",[v._v("多行注释：/* 注释内容 */")])]),v._v(" "),_("li",[_("p",[v._v("文档注释：注释内容可以被JDK提供的工具javadoc所解析")]),v._v(" "),_("p",[_("code",[v._v("/**")])]),v._v(" "),_("p",[_("code",[v._v("* @author 汪重阳")])]),v._v(" "),_("p",[_("code",[v._v("* @version 1.0")])]),v._v(" "),_("p",[_("code",[v._v("*/")])])])]),v._v(" "),_("p",[_("code",[v._v("javadoc -d d:\\\\Code\\\\SUBJAVA\\\\Test -author -version ChangeChar.java")])]),v._v(" "),_("h5",{attrs:{id:"java代码规范"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java代码规范"}},[v._v("#")]),v._v(" Java代码规范")]),v._v(" "),_("ol",[_("li",[v._v("类、方法的注释，要以javadoc的方式来写")]),v._v(" "),_("li",[v._v("非Java Doc的注释，往往是给代码的维护者看的，着重告述读者为什么这样写，如何修改，注意什么问题等")]),v._v(" "),_("li",[v._v("使用tab操作，实现缩进，默认整体向右边移动，时候用shift+tab整体向左移")]),v._v(" "),_("li",[v._v("运算符和 = 两边习惯性各加一个空格。如：2 + 4 * 5 + 345 -89")]),v._v(" "),_("li",[v._v("源文件使用utf-8编码")]),v._v(" "),_("li",[v._v("行宽度不要超过80字符")]),v._v(" "),_("li",[v._v("代码编写次行风格和行尾风格")])]),v._v(" "),_("h5",{attrs:{id:"dos命令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dos命令"}},[v._v("#")]),v._v(" DOS命令")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("md 文件路径\\\\文件名称——创建文件")])]),v._v(" "),_("li",[_("p",[v._v("rd 文件路径\\\\文件名称——删除文件")])]),v._v(" "),_("li",[_("p",[v._v("dir 查看当前目录的内容")])]),v._v(" "),_("li",[_("p",[v._v("cd")]),v._v(" "),_("ul",[_("li",[v._v("cd /D c: 切换到其他盘下")]),v._v(" "),_("li",[v._v("cd d:\\abc2\\test200 切换到当前盘的其他目录下")]),v._v(" "),_("li",[v._v("cd .. 切换到上一级")]),v._v(" "),_("li",[v._v("cd \\ 切换到根目录")])])]),v._v(" "),_("li",[_("p",[v._v("tree 查看指定的目录下 的所有子级目录")])]),v._v(" "),_("li",[_("p",[v._v("cls 清屏")])]),v._v(" "),_("li",[_("p",[v._v("exit 退出DOS")])]),v._v(" "),_("li",[_("p",[v._v("copy 拷贝文件")])]),v._v(" "),_("li",[_("p",[v._v("del 删除文件")])]),v._v(" "),_("li",[_("p",[v._v("echo 输入内容到文件")])]),v._v(" "),_("li",[_("p",[v._v("type 显示文本文件的内容")])]),v._v(" "),_("li",[_("p",[v._v("move 剪切")])])]),v._v(" "),_("h3",{attrs:{id:"变量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#变量"}},[v._v("#")]),v._v(" 变量")]),v._v(" "),_("p",[v._v("变量是程序的基本组成单位")]),v._v(" "),_("p",[v._v("基本要素：类型、名称、值")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("概念：变量相当于内存中一个数据存储空间的表示")])]),v._v(" "),_("li",[_("p",[v._v("使用步骤：也可以"),_("code",[v._v("int a = 60;")])]),v._v(" "),_("ul",[_("li",[v._v("声明变量 "),_("code",[v._v("int a;")])]),v._v(" "),_("li",[v._v("赋值 "),_("code",[v._v("a = 60;")])]),v._v(" "),_("li",[v._v("使用 "),_("code",[v._v("System.out.println(a);")])])])]),v._v(" "),_("li",[_("p",[v._v("注意事项")]),v._v(" "),_("ul",[_("li",[v._v("变量表示内存中的一个存储区域【不同的变量，类型不同，占用的空间大小不同】")]),v._v(" "),_("li",[v._v("该区域有自己的名称【变量名】和类型【数据类型】")]),v._v(" "),_("li",[v._v("变量必须先声明，后使用，即有顺序")]),v._v(" "),_("li",[v._v("该区域的数据可以在同一类型范围内不断变化")]),v._v(" "),_("li",[v._v("变量在同一个作用域内不能重名")]),v._v(" "),_("li",[v._v("变量 = 变量名 + 值 + 数据类型")])])]),v._v(" "),_("li",[_("p",[v._v("加号的使用")]),v._v(" "),_("ul",[_("li",[v._v("当左右两边都是数值型时，则做加法运算")]),v._v(" "),_("li",[v._v("当左右两边有一方为字符串时，则做拼接运算")]),v._v(" "),_("li",[v._v("运算顺序，是从左到右")])])])]),v._v(" "),_("h4",{attrs:{id:"数据类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[v._v("#")]),v._v(" 数据类型")]),v._v(" "),_("ol",[_("li",[v._v("Java数据类型分为两大类：基本数据类型和引用数据类型")]),v._v(" "),_("li",[v._v("基本数据类型有8种：数值型[byte,short,int,long,float,double],char,boolean")]),v._v(" "),_("li",[v._v("引用类型[类，接口，数组]")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("整数类型细节")]),v._v(" "),_("ul",[_("li",[v._v("Java各整数类型有固定的范围和字段长度，不受具体OS【操作系统】的影响，以保证java程序的可移植性")]),v._v(" "),_("li",[v._v("Java的整型常量默认为int型，声明long型常量须后加'|'或'L'")]),v._v(" "),_("li",[v._v("Java程序中变量常声明为int型，除非不足以表示大数，才使用long")]),v._v(" "),_("li",[v._v("bit：计算机中的最小存储单元。byte：计算机中基本存储单元，1byte = 8bit")]),v._v(" "),_("li",[v._v("当把一个具体的数赋给byte时，先判断该数是否在byte范围内，如果是就可以")])])]),v._v(" "),_("li",[_("p",[v._v("浮点类型")]),v._v(" "),_("ul",[_("li",[v._v("关于浮点数在机器中存放形式的简单说明，浮点数 = 符号位 + 指数位 + 尾数位")]),v._v(" "),_("li",[v._v("尾数部分可能丢失，造成精度损失(小数都是近似值)")])])]),v._v(" "),_("li",[_("p",[v._v("浮点类型细节")]),v._v(" "),_("ul",[_("li",[v._v("与整数类型类型，Java浮点类型也有固定的范围和字段长度，不受具体OS的影响。")]),v._v(" "),_("li",[v._v("Java的浮点型常量默认为double型，声明float型常量，须后加'f'或'F'")]),v._v(" "),_("li",[v._v("浮点型常量有两种表示形式\n"),_("ul",[_("li",[v._v("十进制数形式：如 5.12   512.0f   .512")]),v._v(" "),_("li",[v._v("科学计数法形式：如 5.12e2[5.12*10的2次方]   5.12E-2[5.12/10的2次方]")])])]),v._v(" "),_("li",[v._v("通常情况下，应该使用double型，因为它比float型更精确")]),v._v(" "),_("li",[v._v("浮点数使用陷阱：2.7和8.1/3比较"),_("strong",[v._v("对运算结果是小数的进行相等判断时，要小心，应该是以两个数的差值的绝对值，在某个精度范围内判断")])])])]),v._v(" "),_("li",[_("p",[v._v("字符类型细节")]),v._v(" "),_("ul",[_("li",[v._v("字符常量是用单引号括起来 的单个字符")]),v._v(" "),_("li",[v._v("Java中还允许使用转义字符'\\'来将其后的字符转变为特殊字符型常量")]),v._v(" "),_("li",[v._v("在Java中，char的本质是一个整数，在输出时，是unicode码对应的字符")]),v._v(" "),_("li",[v._v("可以直接给char赋一个整数，然后输出时，会按照对应的unicode字符输出")]),v._v(" "),_("li",[v._v("char类型是可以进行运算的，相当于一个整数，因为它都对应有Unicode码")])])]),v._v(" "),_("li",[_("p",[v._v("字符编码表")]),v._v(" "),_("ul",[_("li",[v._v("ASCII")]),v._v(" "),_("li",[v._v("Unicode：固定大小的编码，使用两个字节表示字符，汉字和字母统一都是占用两个字节")]),v._v(" "),_("li",[v._v("utf-8：大小可变的编码，字母使用1个字节，汉字使用3个字节")]),v._v(" "),_("li",[v._v("gbk：字母使用1个字节，汉字使用2个字节")]),v._v(" "),_("li",[v._v("gb2312：gb2312<gbk")]),v._v(" "),_("li",[v._v("big5:繁体中文，台湾，香港")])])]),v._v(" "),_("li",[_("p",[v._v("布尔类型")]),v._v(" "),_("ul",[_("li",[v._v("只占1个字节")]),v._v(" "),_("li",[v._v("不可以使用0或非0的整数替代false和true，这点和C语言不同")])])])]),v._v(" "),_("h4",{attrs:{id:"数据类型转换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据类型转换"}},[v._v("#")]),v._v(" 数据类型转换")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("自动类型转换")]),v._v(" "),_("ul",[_("li",[v._v("当Java程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数据类型，这个就是自动类型转换")]),v._v(" "),_("li",[v._v("从小到大（char，int，long，float，double）（byte，short，int，long，float，double）")])])]),v._v(" "),_("li",[_("p",[v._v("自动类型转换细节")]),v._v(" "),_("ul",[_("li",[v._v("有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算")]),v._v(" "),_("li",[v._v("当我们把精度(容量)大的数据类型赋值给精度(容量)小的数据类型时，就会报错，反之就会进行自动类型转换")]),v._v(" "),_("li",[v._v("(byte，short)和char之间不会相互自动转换")]),v._v(" "),_("li",[v._v("byte，short，char他们三者可以计算，在计算时首先转换为int类型")]),v._v(" "),_("li",[v._v("boolean不参与转换")]),v._v(" "),_("li",[v._v("自动提升原则：表达式结果的类型自动提升为操作数中最大的类型")])])]),v._v(" "),_("li",[_("p",[v._v("强制类型转换")]),v._v(" "),_("ul",[_("li",[v._v("自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符()，但可能造成精度降低或溢出，格外要注意")])])]),v._v(" "),_("li",[_("p",[v._v("强制类型转换细节")]),v._v(" "),_("ul",[_("li",[v._v("当进行数据从大到小，就需要使用到强制转换")]),v._v(" "),_("li",[v._v("强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级")]),v._v(" "),_("li",[v._v("char类型可以保存int的常量值，但不能保存int的变量值，需要强转")]),v._v(" "),_("li",[v._v("byte和short类型在进行运算时，当做int类型处理")])])]),v._v(" "),_("li",[_("p",[v._v("String数据类型与基本数据类型转换")]),v._v(" "),_("ul",[_("li",[v._v('基本类型转String类型：将基本类型的值+""即可')]),v._v(" "),_("li",[v._v("String类型转基本数据类型：通过基本类型的包装类调用parseXX方法即可"),_("code",[v._v("int num = Integer.parseInt(str);")])]),v._v(" "),_("li",[v._v("把字符串转成字符char：指把字符串的第一个字符得到"),_("code",[v._v("str.charAt(0)")])]),v._v(" "),_("li",[v._v('在将String类型转成基本数据类型 时，要确保String类型能够转成有效的数据，比如我们可以把"123"，转成一个整数，但是不能把"hello"转成一个整数')]),v._v(" "),_("li",[v._v("如果格式不正确，就会抛出异常，程序就会终止，这个问题在异常处理章节中，会处理")])])])]),v._v(" "),_("h3",{attrs:{id:"运算符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#运算符"}},[v._v("#")]),v._v(" 运算符")]),v._v(" "),_("p",[v._v("运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等")]),v._v(" "),_("ol",[_("li",[v._v("算术运算符：是对数值类型的变量进行运算的，有+、-、/、%、++、--\n"),_("ol",[_("li",[v._v("%的本质是a % b = a - (a / b) * b")]),v._v(" "),_("li",[v._v("有小数运算时，得到的结果是近似值")])])]),v._v(" "),_("li",[v._v("赋值运算符：就是将某个运算后的值，赋给指定的变量，有=、+=、-=、*=、/=、%=\n"),_("ol",[_("li",[v._v("运算顺序从右往左")]),v._v(" "),_("li",[v._v("赋值运算符的左边只能是变量，右边可以是变量、表达式、常量值")]),v._v(" "),_("li",[v._v("复合赋值运算符等价于下面的效果")]),v._v(" "),_("li",[v._v("复合赋值运算符会进行类型转换")])])]),v._v(" "),_("li",[v._v("关系运算符【比较运算符】：结果都是boolean型，经常用在if结构的条件中或循环结构的条件中，如==、!=、<、>、<=、>=、instanceof\n"),_("ol",[_("li",[v._v("关系运算符的结果都是boolean型，也就是要么是true，要么是false")]),v._v(" "),_("li",[v._v("关系运算符 组成的表达式，我们称为关系表达式")]),v._v(" "),_("li",[v._v('比较运算符"=="不能误写成"="')])])]),v._v(" "),_("li",[v._v("逻辑运算符：用于连接多个条件（多个关系表达式），最终结果也是一个boolean值，有短路与&&、短路或||、取反!、逻辑与&、逻辑或|、逻辑异或^\n"),_("ol",[_("li",[v._v("&&和&的区别：&&短路与中如果第一个条件为false，则第二个条件不会判断，最终结果为false；&逻辑与中不管第一个条件是否为false，第二个条件都要判断")]),v._v(" "),_("li",[v._v("||和|的区别：||短路或中如果第一个条件为true，则第二个条件不会判断，最终结果为true；|逻辑或中不管第一个条件是否为true，第二个条件都要判断")]),v._v(" "),_("li",[v._v("逻辑异或a^b：当a和b不同时，则结果为true，否则为false")])])]),v._v(" "),_("li",[v._v("位运算符")]),v._v(" "),_("li",[v._v("三元运算符：条件表达式?表达式1:表达式2\n"),_("ol",[_("li",[v._v("如果条件表达式为true，运算后的结果是表达式1")]),v._v(" "),_("li",[v._v("如果条件表达式结果为false，运算后的结果是表达式2")]),v._v(" "),_("li",[v._v("表达式1和表达式2要为可以赋给接收变量的类型（或可以自动转换）")]),v._v(" "),_("li",[v._v("三元运算符可以转成if--else语句")]),v._v(" "),_("li",[v._v("三元运算符是一个整体")])])])]),v._v(" "),_("p",[v._v("优先级")]),v._v(" "),_("ul",[_("li",[v._v("运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序")]),v._v(" "),_("li",[v._v("只有单目运算符、赋值运算符是从右向左运算的")]),v._v(" "),_("li",[v._v("优先级排序大致\n"),_("ul",[_("li",[v._v("()，{}等")]),v._v(" "),_("li",[v._v("单目运算符")]),v._v(" "),_("li",[v._v("算术运算符")]),v._v(" "),_("li",[v._v("位移运算符")]),v._v(" "),_("li",[v._v("比较运算符")]),v._v(" "),_("li",[v._v("逻辑运算符")]),v._v(" "),_("li",[v._v("三元运算符")]),v._v(" "),_("li",[v._v("赋值运算符")])])])]),v._v(" "),_("h4",{attrs:{id:"标识符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#标识符"}},[v._v("#")]),v._v(" 标识符")]),v._v(" "),_("p",[v._v("概念")]),v._v(" "),_("ul",[_("li",[v._v("Java对各种变量、方法和类等命名时使用的字符序列称为标识符")]),v._v(" "),_("li",[v._v("凡是自己可以起名字的地方都叫标识符")])]),v._v(" "),_("p",[v._v("命名规则（必须遵守）")]),v._v(" "),_("ul",[_("li",[v._v("由26个英文字母大小写，0-9，_或$组成")]),v._v(" "),_("li",[v._v("数字不可以开头")]),v._v(" "),_("li",[v._v("不可以使用关键字和保留字，但能包含关键字和保留字")]),v._v(" "),_("li",[v._v("Java中严格区分大小写，长度无限制")]),v._v(" "),_("li",[v._v("标识符不能包含空格")])]),v._v(" "),_("p",[v._v("命名规范（更加专业）")]),v._v(" "),_("ul",[_("li",[v._v("包名：多单词组成时所有字母都小写")]),v._v(" "),_("li",[v._v("类名、接口名：多单词组成时，所有单词的首字母大写")]),v._v(" "),_("li",[v._v("变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写")]),v._v(" "),_("li",[v._v("常量名：所有字母都大写，多单词时每个单词用下划线连接")])]),v._v(" "),_("h4",{attrs:{id:"键盘输入语句"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#键盘输入语句"}},[v._v("#")]),v._v(" 键盘输入语句")]),v._v(" "),_("p",[v._v("介绍")]),v._v(" "),_("p",[v._v("在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。需要一个扫描器（对象），就是Scanner")]),v._v(" "),_("p",[v._v("步骤")]),v._v(" "),_("ul",[_("li",[v._v("导入该类的所在包 java.util.*")]),v._v(" "),_("li",[v._v("创建该类对象（声明变量）")]),v._v(" "),_("li",[v._v("调用里面的功能")])]),v._v(" "),_("p",[_("code",[v._v("Scanner myScanner = new Scanner(System.in)")])]),v._v(" "),_("h4",{attrs:{id:"二进制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二进制"}},[v._v("#")]),v._v(" 二进制")]),v._v(" "),_("ul",[_("li",[v._v("二进制是逢2进位的进位制，0、1是基本算符")]),v._v(" "),_("li",[v._v("现代的电子计算机技术全部采用的是二进制，因为它只使用0、1两个数字符号，非常简单方便，易于用电子方式实现，计算机内部处理的信息，都是采用二进制数来表示的，二进制数用0和1两个数字及其组合来表示任何数。进位的规则是“逢2进1”，数字1在不同的位上代表不同的值，按从右至左的次序，这个值以二倍递增。")])]),v._v(" "),_("h5",{attrs:{id:"原码、反码、补码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#原码、反码、补码"}},[v._v("#")]),v._v(" 原码、反码、补码")]),v._v(" "),_("ol",[_("li",[v._v("二进制的最高位是符号位：0表示正数，1表示负数")]),v._v(" "),_("li",[v._v("正数的原码，反码，补码都一样（三码合一）")]),v._v(" "),_("li",[v._v("负数的反码=它的原码符号位不变，其它位取反")]),v._v(" "),_("li",[v._v("负数的补码=它的反码+1，负数的反码=负数的补码-1")]),v._v(" "),_("li",[v._v("0的反码，补码都是0")]),v._v(" "),_("li",[v._v("java没有无符号数，换言之，java中的数都是有符号的")]),v._v(" "),_("li",[v._v("在计算机运算的时候，都是以补码的方式来运算的")]),v._v(" "),_("li",[v._v("当我们看运算结果的时候，要看他的原码")])]),v._v(" "),_("h5",{attrs:{id:"位运算"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#位运算"}},[v._v("#")]),v._v(" 位运算")]),v._v(" "),_("ul",[_("li",[v._v("按位与&：两位全为1，结果为1，否则为0")]),v._v(" "),_("li",[v._v("按位或|：两位有一个为1，结果为1，否则为0")]),v._v(" "),_("li",[v._v("按位异或^：两位一个为0，一个为1，结果为1，否则为0")]),v._v(" "),_("li",[v._v("按位取反~：0->1，1->0")]),v._v(" "),_("li",[v._v("算术右移>>：低位溢出，符号位不变，并用符号位补溢出的高位")]),v._v(" "),_("li",[v._v("算术左移<<：符号位不变，低位补0")]),v._v(" "),_("li",[v._v("逻辑右移>>>也叫无符号右移，运算规则是：低位溢出，高位补0")]),v._v(" "),_("li",[v._v("特别说明：没有<<<符号")])]),v._v(" "),_("h3",{attrs:{id:"控制结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#控制结构"}},[v._v("#")]),v._v(" 控制结构")]),v._v(" "),_("h4",{attrs:{id:"流程控制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#流程控制"}},[v._v("#")]),v._v(" 流程控制")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("顺序控制：程序从上到下逐行地执行，中间没有任何判断和跳转")])]),v._v(" "),_("li",[_("p",[v._v("分支控制")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("单分支")]),v._v(" "),_("p",[v._v("基本语法：")]),v._v(" "),_("p",[_("code",[v._v("if(条件表达式){")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("执行代码块;(可以有多条语句。)")])]),v._v(" "),_("p",[_("code",[v._v("}")])]),v._v(" "),_("p",[v._v("说明：当条件表达式为true时，就会执行{}的代码。如果为false，就不执行。特别说明，如果{}中只有一条语句，则可以不用{}，建议写上{}")])]),v._v(" "),_("li",[_("p",[v._v("双分支")]),v._v(" "),_("p",[v._v("基本语法：")]),v._v(" "),_("p",[_("code",[v._v("if(条件表达式){")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("执行代码块1;")])]),v._v(" "),_("p",[_("code",[v._v("}else{")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("执行代码块2;")])]),v._v(" "),_("p",[_("code",[v._v("}")])]),v._v(" "),_("p",[v._v("说明：当条件表达式成立，即执行代码块1，否则执行代码块2。如果执行代码块只有一条语句，则{}可以省略，否则，不能省略。")])]),v._v(" "),_("li",[_("p",[v._v("多分支")]),v._v(" "),_("p",[v._v("基本语法：")]),v._v(" "),_("p",[_("code",[v._v("if(条件表达式1){")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("执行代码块1;")])]),v._v(" "),_("p",[_("code",[v._v("}else if(条件表达式2){")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("执行代码块2;")])]),v._v(" "),_("p",[_("code",[v._v("}")])]),v._v(" "),_("p",[_("code",[v._v("......")])]),v._v(" "),_("p",[_("code",[v._v("else{")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("执行代码块n;")])]),v._v(" "),_("p",[_("code",[v._v("}")])]),v._v(" "),_("p",[v._v("说明：")]),v._v(" "),_("ol",[_("li",[v._v("当条件表达式1成立时，即执行代码块1")]),v._v(" "),_("li",[v._v("如果表达式1不成立，才去判断表达式2是否成立")]),v._v(" "),_("li",[v._v("如果表达式2成立，就执行代码块2")]),v._v(" "),_("li",[v._v("以此类推，如果所有的表达式都不成立")]),v._v(" "),_("li",[v._v("则执行else的代码块，注意，只能有一个执行入口")]),v._v(" "),_("li",[v._v("多分支可以没有else，如果所有的条件表达式都不成立，则一个执行入口都没有")]),v._v(" "),_("li",[v._v("如果有else，如果所有的条件表达式都不成立，则默认执行else代码块")])])]),v._v(" "),_("li",[_("p",[v._v("嵌套分支")]),v._v(" "),_("p",[v._v("基本介绍：在一个分支结构中又完整的嵌套了另一个完整的分支结构，里面的分支的结构称为内分支外面的分支结构称为外层分支。规范：不要超过3层（可读性不好）")]),v._v(" "),_("p",[v._v("基本语法")]),v._v(" "),_("p",[_("code",[v._v("if(){")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("if(){")])]),v._v(" "),_("p",[v._v("​\t\t"),_("code",[v._v("//if-else")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("}else{")])]),v._v(" "),_("p",[v._v("​\t\t"),_("code",[v._v("//if-else")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("}")])]),v._v(" "),_("p",[_("code",[v._v("}")])])]),v._v(" "),_("li",[_("p",[v._v("switch分支结构")]),v._v(" "),_("p",[v._v("基本语法")]),v._v(" "),_("p",[_("code",[v._v("switch(表达式){")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("case 常量1:语句块1;break;")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("case 常量2:语句块2;break;")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("...")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("case 常量n:语句块n;break;")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("default:default语句块;break;")])]),v._v(" "),_("p",[_("code",[v._v("}")])]),v._v(" "),_("p",[v._v("说明：")]),v._v(" "),_("ol",[_("li",[v._v("switch关键字，表示switch分支")]),v._v(" "),_("li",[v._v("表达式对应一个值")]),v._v(" "),_("li",[v._v("case 常量1:当表达式的值等于常量1，就执行语句块1")]),v._v(" "),_("li",[v._v("break：表示退出switch")]),v._v(" "),_("li",[v._v("如果和case 常量 1匹配，就执行语句块1，如果没有匹配，就继续匹配case 常量2")]),v._v(" "),_("li",[v._v("如果一个都没有匹配上，执行default")])]),v._v(" "),_("p",[v._v("switch注意事项与细节讨论")]),v._v(" "),_("ol",[_("li",[v._v("表达式数据类型，应和case后的常量类型一致，或者是可以自动转成可以相互比较的类型，比如输入的是字符，而常量是int")]),v._v(" "),_("li",[v._v("switch(表达式)中表达式的返回值必须是：(byte,short,int,char,enum,String)")]),v._v(" "),_("li",[v._v("case子句中的值必须是常量，而不能是变量")]),v._v(" "),_("li",[v._v("default子句是可选的，当没有匹配的case时，执行default")]),v._v(" "),_("li",[v._v("break语句用来执行完一个case分支后使程序跳出switch语句块；如果没有写break，程序会顺序执行到switch结尾")])])])])]),v._v(" "),_("li",[_("p",[v._v("循环控制")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("for循环控制")]),v._v(" "),_("p",[v._v("基本介绍：就是让你的代码可以循环的执行")]),v._v(" "),_("p",[v._v("基本语法")]),v._v(" "),_("p",[_("code",[v._v("for(循环变量初始化;循环条件;循环变量迭代){循环操作(可以多条语句);}")])]),v._v(" "),_("p",[v._v("说明")]),v._v(" "),_("ol",[_("li",[v._v("for关键字，表示循环控制")]),v._v(" "),_("li",[v._v("for有四要素：循环变量初始化；循环条件；循环操作；循环变量迭代")]),v._v(" "),_("li",[v._v("循环操作，这里可以有多条语句，也就是我们要循环执行的代码")]),v._v(" "),_("li",[v._v("如果循环操作只有一条语句，可以省略{}，建议不要省略")])]),v._v(" "),_("p",[v._v("注意事项和细节说明")]),v._v(" "),_("ol",[_("li",[v._v("循环条件是返回一个布尔值的表达式")]),v._v(" "),_("li",[v._v("for(;循环判断条件;)中的初始化和变量迭代可以写到其它地方，但是两边的分号不能省略")]),v._v(" "),_("li",[v._v("循环初始值可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开")])]),v._v(" "),_("p",[v._v("编程思想")]),v._v(" "),_("ol",[_("li",[v._v("化繁为简：即将复杂的需求，拆解成简单的需求，逐步完成")]),v._v(" "),_("li",[v._v("先死后活：先考虑固定的值，然后转成可以灵活变化的值")])])]),v._v(" "),_("li",[_("p",[v._v("while循环控制")]),v._v(" "),_("p",[v._v("基本语法")]),v._v(" "),_("p",[_("code",[v._v("循环变量初始化;")])]),v._v(" "),_("p",[_("code",[v._v("while(循环条件){")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("循环体(语句);")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("循环变量迭代;")])]),v._v(" "),_("p",[_("code",[v._v("}")])]),v._v(" "),_("p",[v._v("说明")]),v._v(" "),_("ol",[_("li",[v._v("while循环也有四要素")]),v._v(" "),_("li",[v._v("只是四要素放的位置，不一样")])])]),v._v(" "),_("li",[_("p",[v._v("do...while循环控制")]),v._v(" "),_("p",[v._v("基本语法")]),v._v(" "),_("p",[_("code",[v._v("循环变量初始化;")])]),v._v(" "),_("p",[_("code",[v._v("do{")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("循环体(语句);")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("循环变量迭代;")])]),v._v(" "),_("p",[_("code",[v._v("}while(循环条件);")])]),v._v(" "),_("p",[v._v("说明")]),v._v(" "),_("ol",[_("li",[v._v("do while是关键字")]),v._v(" "),_("li",[v._v("也有循环四要素，只是位置不一样")]),v._v(" "),_("li",[v._v("先执行，再判断，也就是说，一定会执行一次")]),v._v(" "),_("li",[v._v("最后有一个分号;")]),v._v(" "),_("li",[v._v("while和do...while区别举例：要账")])]),v._v(" "),_("p",[v._v("注意事项和细节说明")]),v._v(" "),_("ol",[_("li",[v._v("循环条件是返回一个布尔值的表达式")]),v._v(" "),_("li",[v._v("do...while循环是先执行，再判断，因此它至少执行一次")])])]),v._v(" "),_("li",[_("p",[v._v("多重循环控制")]),v._v(" "),_("p",[v._v("介绍")]),v._v(" "),_("ol",[_("li",[v._v("将一个循环放在另一个循环体内，就形成了嵌套循环。其中，for，while，do...while均可以作为外层循环和内层循环。【建议一般使用两层，最多不要超过3层，否则，代码的可读性很差】")]),v._v(" "),_("li",[v._v("实质上，嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环 的循环条件为false时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的循环【听不懂，走案例】")]),v._v(" "),_("li",[v._v("设外层循环次数为m次，内层为n次，则内层循环体实际上需要执行m*n次")])])]),v._v(" "),_("li",[_("p",[v._v("跳转控制语句break")]),v._v(" "),_("p",[v._v("基本介绍：break语句用于终止某个语句块的执行，一般使用在switch或者循环中")]),v._v(" "),_("p",[v._v("基本语法：")]),v._v(" "),_("p",[_("code",[v._v("{")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("......")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("break;")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("......")])]),v._v(" "),_("p",[_("code",[v._v("}")])]),v._v(" "),_("p",[v._v("注意事项和细节说明")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("break语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是哪一层语句块")])]),v._v(" "),_("li",[_("p",[v._v("标签的基本使用")]),v._v(" "),_("p",[_("code",[v._v("label1:{......")])]),v._v(" "),_("p",[_("code",[v._v("label2:\t{......")])]),v._v(" "),_("p",[_("code",[v._v("label3:\t\t{......")])]),v._v(" "),_("p",[v._v("​\t\t\t"),_("code",[v._v("break label2;")])]),v._v(" "),_("p",[v._v("​\t\t\t"),_("code",[v._v("......")])]),v._v(" "),_("p",[v._v("​\t\t"),_("code",[v._v("}")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("}")])]),v._v(" "),_("p",[_("code",[v._v("}")])]),v._v(" "),_("ol",[_("li",[v._v("break语句可以指定退出哪层")]),v._v(" "),_("li",[v._v("label1是标签，由程序员指定")]),v._v(" "),_("li",[v._v("break后指定到哪个label就退出到哪里")]),v._v(" "),_("li",[v._v("在实际的开发中，尽量不要使用标签")]),v._v(" "),_("li",[v._v("如果没有指定break，默认退出最近的循环体")])])])])]),v._v(" "),_("li",[_("p",[v._v("跳转控制语句continue")]),v._v(" "),_("p",[v._v("基本介绍")]),v._v(" "),_("ol",[_("li",[v._v("continue语句用于结束本次循环，继续执行下一次循环")]),v._v(" "),_("li",[v._v("continue语句出现多层嵌套的循环语句体中，可以通过标签指明要跳过的是哪一层循环，这个和前面的标签的 使用的规则一样")])]),v._v(" "),_("p",[v._v("基本语法")]),v._v(" "),_("p",[_("code",[v._v("{")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("......")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("continue;")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("......")])]),v._v(" "),_("p",[_("code",[v._v("}")])])]),v._v(" "),_("li",[_("p",[v._v("跳转控制语句return")]),v._v(" "),_("p",[v._v("介绍：return使用在方法，表示跳出所在的方法")]),v._v(" "),_("p",[v._v("注意：如果return写在main方法，退出程序")])])])])]),v._v(" "),_("h3",{attrs:{id:"数组、排序和查找"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数组、排序和查找"}},[v._v("#")]),v._v(" 数组、排序和查找")]),v._v(" "),_("h4",{attrs:{id:"数组"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[v._v("#")]),v._v(" 数组")]),v._v(" "),_("p",[v._v("数组介绍：数组可以存放多个同一类型的数据。数组也是一种数据类型，是引用类型。即：数组就是一组数据")]),v._v(" "),_("h5",{attrs:{id:"数组的使用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数组的使用"}},[v._v("#")]),v._v(" 数组的使用")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("使用方式1-动态初始化")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("数组的定义：")]),v._v(" "),_("p",[v._v("数据类型 数组名[] = new 数据类型[大小]  或者  数据类型[] 数组名 = new 数据类型[大小]")]),v._v(" "),_("p",[_("code",[v._v("int a[] = new int[5];\t//创建了一个数组，名字a，存放5个int")])]),v._v(" "),_("p",[v._v("说明：这是定义数组的一种方法。")])]),v._v(" "),_("li",[_("p",[v._v("数组的引用：数组名[下标/索引]，数组的下标从0开始。比如：你要使用a数组的第3个数  a[2]")])])])]),v._v(" "),_("li",[_("p",[v._v("使用方式2-动态初始化")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("先声明数组")]),v._v(" "),_("p",[v._v("语法：数据类型 数组名[];  也可以  数据类型[] 数组名;")]),v._v(" "),_("p",[_("code",[v._v("int a[]; 或者 int[] a;")])])]),v._v(" "),_("li",[_("p",[v._v("创建数组")]),v._v(" "),_("p",[v._v("语法：数组名 = new 数据类型[大小];")]),v._v(" "),_("p",[_("code",[v._v("a = new int[10];")])])])])]),v._v(" "),_("li",[_("p",[v._v("使用方式3-静态初始化")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("初始化数组")]),v._v(" "),_("p",[v._v("语法：数据类型 数组名[] = {元素值，元素值，...}")]),v._v(" "),_("p",[_("code",[v._v("int a[] = {2, 5, 6, 7, 8, 89, 90, 34, 56}")])])])])]),v._v(" "),_("li",[_("p",[v._v("数组的使用注意事项和细节")]),v._v(" "),_("ol",[_("li",[v._v("数组是多个相同类型数据的组合，实现对这些数据的统一管理")]),v._v(" "),_("li",[v._v("数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用")]),v._v(" "),_("li",[v._v("数组创建后，如果没有赋值，有默认值。int 0，short 0，byte 0，long 0，float 0，double 0.0，char \\u0000，boolean false，String null")]),v._v(" "),_("li",[v._v("使用数组的步骤：(1)声明数组并开辟空间 (2)给数组各个元素赋值 (3)使用数组")]),v._v(" "),_("li",[v._v("数组的下标是从0开始的")]),v._v(" "),_("li",[v._v("数组下标必须在指定范围内使用，否则报：下标越界异常，比如"),_("code",[v._v("int[] arr = new int[5]; //则有效下标为0-4")])]),v._v(" "),_("li",[v._v("数组属引用类型，数组型数据是对象(object)")])])])]),v._v(" "),_("h5",{attrs:{id:"数组赋值机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数组赋值机制"}},[v._v("#")]),v._v(" 数组赋值机制")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("基本数据类型赋值，这个值就是具体的数据，而且相互不影响")]),v._v(" "),_("p",[_("code",[v._v("int n1 = 2;")])]),v._v(" "),_("p",[_("code",[v._v("int n2 = n1;")])])]),v._v(" "),_("li",[_("p",[v._v("数组在默认情况下是引用传递，赋的值是地址")])])]),v._v(" "),_("h5",{attrs:{id:"数组添加"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数组添加"}},[v._v("#")]),v._v(" 数组添加")]),v._v(" "),_("p",[v._v("要求：实现动态的给数组添加元素效果，实现对数组扩容")]),v._v(" "),_("ol",[_("li",[v._v("原始数组使用静态分配"),_("code",[v._v("int[] arr = {1, 2, 3}")])]),v._v(" "),_("li",[v._v("增加的元素，直接放在数组的最后"),_("code",[v._v("arr = {1, 2, 3, 4}")])]),v._v(" "),_("li",[v._v("用户可以通过如下方法来决定是否继续添加，添加成功，是否继续？y/n")])]),v._v(" "),_("h4",{attrs:{id:"排序"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#排序"}},[v._v("#")]),v._v(" 排序")]),v._v(" "),_("h5",{attrs:{id:"排序的介绍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#排序的介绍"}},[v._v("#")]),v._v(" 排序的介绍")]),v._v(" "),_("p",[v._v("排序是将一群数据，依指定的顺序进行排列的过程")]),v._v(" "),_("p",[v._v("分类")]),v._v(" "),_("ol",[_("li",[v._v("内部排序：指将需要处理的所有数据都加载到内部存储器中进行排序。包括（交换式排序法、选择式排序法和插入式排序法）；")]),v._v(" "),_("li",[v._v("外部排序法：数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括（合并排序法和直接合并排序法）。")])]),v._v(" "),_("h5",{attrs:{id:"冒泡排序"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#冒泡排序"}},[v._v("#")]),v._v(" 冒泡排序")]),v._v(" "),_("p",[v._v("基本思想：通过对待排序序列从后向前（从下标较大的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就像水底下的气泡一样逐渐向上冒")]),v._v(" "),_("p",[v._v("特点：")]),v._v(" "),_("ol",[_("li",[v._v("我们一共有5个元素")]),v._v(" "),_("li",[v._v("一共进行了4轮排序，可以看成是外层循环")]),v._v(" "),_("li",[v._v("每1轮排序可以确定一个数的位置，比如第1轮排序确定最大数，第2轮排序确定第2大的数位置，依次类推")]),v._v(" "),_("li",[v._v("当进行比较时，如果前面的数大于后面的数，就交换")]),v._v(" "),_("li",[v._v("每轮比较在减少4->3->2->1")])]),v._v(" "),_("h4",{attrs:{id:"查找"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#查找"}},[v._v("#")]),v._v(" 查找")]),v._v(" "),_("p",[v._v("介绍：在java中，我们常用的查找有两种：")]),v._v(" "),_("ol",[_("li",[v._v("顺序查找")]),v._v(" "),_("li",[v._v("二分查找")])]),v._v(" "),_("h4",{attrs:{id:"二维数组"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二维数组"}},[v._v("#")]),v._v(" 二维数组")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("使用方式1：动态初始化")]),v._v(" "),_("ol",[_("li",[v._v("语法：类型[][] 数组名 = new 类型[大小][大小]")]),v._v(" "),_("li",[v._v("比如："),_("code",[v._v("int a[][] = new int[2][3]")])])])]),v._v(" "),_("li",[_("p",[v._v("使用方式2：动态初始化")]),v._v(" "),_("ol",[_("li",[v._v("先声明：类型 数组名[][];")]),v._v(" "),_("li",[v._v("再定义（开辟空间）数组名 = new 类型[大小][大小];")]),v._v(" "),_("li",[v._v("赋值（有默认值，比如int类型的就是0）")])])]),v._v(" "),_("li",[_("p",[v._v("使用方式3：动态初始化-列数不确定")]),v._v(" "),_("ol",[_("li",[v._v("看需求：动态创建二维数组，并输出")])])]),v._v(" "),_("li",[_("p",[v._v("使用方式4：静态初始化")]),v._v(" "),_("ol",[_("li",[v._v("定义：类型 数组名[][] = \\{{值1,值2...},{值1,值2...},{值1,值2...}\\}")])]),v._v(" "),_("blockquote",[_("p",[v._v("备注：需要去除反斜杠来看，否则会报错，页面无法显示")])]),v._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[v._v("使用即可[固定方式访问]")])])]),v._v(" "),_("li",[_("p",[v._v("使用细节和注意事项")]),v._v(" "),_("ol",[_("li",[v._v("声明方式："),_("code",[v._v("int[][] y")]),v._v("或者"),_("code",[v._v("int[] y[]")]),v._v("或者"),_("code",[v._v("int y[][]")])]),v._v(" "),_("li",[v._v("二维数组实际上是由多个一维数组组成的，它的各个一维数组的长度可以相同，也可以不同")])])])]),v._v(" "),_("h3",{attrs:{id:"面向对象编程-基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#面向对象编程-基础"}},[v._v("#")]),v._v(" 面向对象编程（基础）")]),v._v(" "),_("h4",{attrs:{id:"类与对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类与对象"}},[v._v("#")]),v._v(" 类与对象")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("使用现有技术解决")]),v._v(" "),_("ol",[_("li",[v._v("单独的定义变量解决")]),v._v(" "),_("li",[v._v("使用数组解决")])])]),v._v(" "),_("li",[_("p",[v._v("现有技术解决的缺点分析")]),v._v(" "),_("ul",[_("li",[v._v("不利于数据的管理")]),v._v(" "),_("li",[v._v("效率低==》引出我们的新知识点-类与对象、哲学、道家")]),v._v(" "),_("li",[v._v("java设计者引入类与对象（OOP），根本原因就是现有的技术，不能完美的解决新的需求")])])]),v._v(" "),_("li",[_("p",[v._v("类与对象的关系")]),v._v(" "),_("ul",[_("li",[v._v("类就是数据类型")]),v._v(" "),_("li",[v._v("对象就是一个具体的实例")])])]),v._v(" "),_("li",[_("p",[v._v("类与对象的区别与联系")]),v._v(" "),_("ul",[_("li",[v._v("类是抽象的，概念的，代表一类事物，即它是数据类型")]),v._v(" "),_("li",[v._v("对象是具体的，实际的，代表一个具体事物，即实例")]),v._v(" "),_("li",[v._v("类是对象的模板，对象是类的一个个体，对应一个实例")])])]),v._v(" "),_("li",[_("p",[v._v("属性/成员变量")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("基本介绍")]),v._v(" "),_("ol",[_("li",[v._v("从概念或叫法上看：成员变量 = 属性 = field（字段）（即成员变量是用来表示属性的，授课中，统一叫属性）")]),v._v(" "),_("li",[v._v("属性是类的一个组成部分，一般是基本数据类型，也可是引用类型（对象，数组）")])])]),v._v(" "),_("li",[_("p",[v._v("注意事项和细节说明")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("属性的定义语法同变量，示例：访问修饰符 属性类型 属性名；")]),v._v(" "),_("p",[v._v("修饰符：控制属性的访问范围：public，proctected，default，private")])]),v._v(" "),_("li",[_("p",[v._v("属性的定义类型可以为任意类型，包含基本类型或引用类型")])]),v._v(" "),_("li",[_("p",[v._v("属性如果不赋值，有默认值，规则和数组一致")])])])])])]),v._v(" "),_("li",[_("p",[v._v("创建对象")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("先声明再创建")]),v._v(" "),_("p",[_("code",[v._v("Cat cat;")])]),v._v(" "),_("p",[_("code",[v._v("cat = new Cat();")])])]),v._v(" "),_("li",[_("p",[v._v("直接创建")]),v._v(" "),_("p",[_("code",[v._v("Cat cat = new Cat();")])])])])]),v._v(" "),_("li",[_("p",[v._v("访问属性")]),v._v(" "),_("p",[v._v("基本语法：对象名.属性名;")])]),v._v(" "),_("li",[_("p",[v._v("类和对象的内存分配机制")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("Java内存的结构分析")]),v._v(" "),_("ol",[_("li",[v._v("栈：一般存放基本数据类型（局部变量）")]),v._v(" "),_("li",[v._v("堆：存放对象（Cat cat，数组等）")]),v._v(" "),_("li",[v._v("方法区：常量池（常量，比如字符串），类加载信息")]),v._v(" "),_("li",[v._v("示意图[Cat(name,age,price)]")])])]),v._v(" "),_("li",[_("p",[v._v("Java创建对象的流程简单分析")]),v._v(" "),_("ol",[_("li",[v._v("先加载Person类信息（属性和方法信息，只会加载一次）")]),v._v(" "),_("li",[v._v("在堆中分配空间，进行默认初始化（看规则）")]),v._v(" "),_("li",[v._v("把地址赋给p，p就指向对象")]),v._v(" "),_("li",[v._v("进行指定初始化，比如 "),_("code",[v._v('p.name = "jack"')])])])])])])]),v._v(" "),_("h4",{attrs:{id:"成员方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#成员方法"}},[v._v("#")]),v._v(" 成员方法")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("基本介绍：在某些情况下，我们需要定义成员方法（简称方法）。比如人类：除了有一些 属性外（年龄，姓名...），我们人类还有一些行为比如：可以说话、跑步...，通过学习，还可以做算术题。这时就要用成员方法才能完成")])]),v._v(" "),_("li",[_("p",[v._v("方法调用小结")]),v._v(" "),_("ol",[_("li",[v._v("当程序执行到方法时，就会开辟一个独立的空间（栈空间）")]),v._v(" "),_("li",[v._v("当方法执行完毕，或者执行到return语句时，就会返回")]),v._v(" "),_("li",[v._v("返回到调用方法的地方")]),v._v(" "),_("li",[v._v("返回后，继续执行方法后面的代码")]),v._v(" "),_("li",[v._v("当main方法（栈）执行完毕，整个程序退出")])])]),v._v(" "),_("li",[_("p",[v._v("成员方法的好处")]),v._v(" "),_("ul",[_("li",[v._v("提高代码的复用性")]),v._v(" "),_("li",[v._v("可以将实现的细节封装起来，然后供其他用户来调用即可")])])]),v._v(" "),_("li",[_("p",[v._v("成员方法的定义")]),v._v(" "),_("p",[_("code",[v._v("public 返回数据类型 方法名(参数列表...){//方法体")])]),v._v(" "),_("p",[_("code",[v._v("语句;")])]),v._v(" "),_("p",[_("code",[v._v("return 返回值;")])]),v._v(" "),_("p",[_("code",[v._v("}")])]),v._v(" "),_("ol",[_("li",[v._v("参数列表：表示成员方法输入cal(int n)")]),v._v(" "),_("li",[v._v("数据类型（返回类型）：表示成员方法输出，void表示没有返回值")]),v._v(" "),_("li",[v._v("方法主体：表示为了实现某一功能代码块")]),v._v(" "),_("li",[v._v("return语句不是必须的")]),v._v(" "),_("li",[v._v("老韩提示：结合前面的题示意图，来理解")])])]),v._v(" "),_("li",[_("p",[v._v("注意事项和使用细节")]),v._v(" "),_("ul",[_("li",[v._v("修饰符（作用是控制方法使用的范围）（有四种：public，protected，默认，private）")]),v._v(" "),_("li",[v._v("返回类型\n"),_("ol",[_("li",[v._v("一个方法最多有一个返回值")]),v._v(" "),_("li",[v._v("返回类型可以为任意类型，包含基本类型或引用类型（数组，对象）")]),v._v(" "),_("li",[v._v("如果方法要求有返回数据类型，则方法体中最后的执行语句必须为return；而且要求返回值类型必须和return的值类型一致或兼容")]),v._v(" "),_("li",[v._v("如果方法是void，则方法体中可以没有return语句，或者只写return")])])]),v._v(" "),_("li",[v._v("方法名：遵循驼峰命名法，最好见名知义")]),v._v(" "),_("li",[v._v("参数列表\n"),_("ol",[_("li",[v._v("一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开，比如"),_("code",[v._v("getSum(int n1, int n2)")])]),v._v(" "),_("li",[v._v("参数类型可以为任意类型，包含基本类型或引用类型")]),v._v(" "),_("li",[v._v("调用带参的方法时，一定对应着参数列表传入相同类型或兼容类型的参数")]),v._v(" "),_("li",[v._v("方法定义时的参数称为形式参数，简称形参；方法调用时的参数称为实际参数，简称实参，实参和形参的类型要一致或兼容、个数、顺序必须一致")])])]),v._v(" "),_("li",[v._v("方法体：里面写完成功能的具体的语句，可以为输入、输出、变量、运算、分支、循环、方法调用，但里面不能再定义方法！即：方法不能嵌套定义")]),v._v(" "),_("li",[v._v("方法细节调用说明\n"),_("ol",[_("li",[v._v("同一个类中的方法调用：直接调用即可")]),v._v(" "),_("li",[v._v("跨类中的方法A类调用B类方法：需要通过对象名调用。比如 对象名.方法名(参数);")]),v._v(" "),_("li",[v._v("特别说明：跨类的方法调用和方法的访问修饰符相关")])])])])]),v._v(" "),_("li",[_("p",[v._v("成员方法传参机制")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("基本数据类型的传参机制：基本数据类型，传递的是值（值拷贝），形参的任何改变不影响实参！")])]),v._v(" "),_("li",[_("p",[v._v("引用数据类型的传参机制：引用类型传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参！")])])])]),v._v(" "),_("li",[_("p",[v._v("方法递归调用")]),v._v(" "),_("p",[v._v("基本介绍：简单的说：递归就是方法自己调用自己，每次调用时传入不同的变量。递归有助于编程者解决复杂问题，同时可以让代码变得简洁。")]),v._v(" "),_("p",[v._v("解决的问题")]),v._v(" "),_("ol",[_("li",[v._v("各种数学问题如：8皇后问题，汉诺塔，阶乘问题，迷宫问题，球和篮子的问题（google编程大赛）")]),v._v(" "),_("li",[v._v("各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等")]),v._v(" "),_("li",[v._v("将用栈解决的问题--\x3e递归代码比较简洁")])])]),v._v(" "),_("li",[_("p",[v._v("递归重要规则")]),v._v(" "),_("ol",[_("li",[v._v("执行一个方法时，就创建一个新的受保护的独立空间（栈空间）")]),v._v(" "),_("li",[v._v("方法的局部变量是独立的，不会相互影响，比如n变量")]),v._v(" "),_("li",[v._v("如果方法中使用的是引用类型变量（比如数组），就会共享该引用类型的数据")]),v._v(" "),_("li",[v._v("递归必须向退出递归的条件逼近，否则就是无限递归，出现StackOverflowError，死龟了:）")]),v._v(" "),_("li",[v._v("当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕")])])])]),v._v(" "),_("h4",{attrs:{id:"重载-overload"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#重载-overload"}},[v._v("#")]),v._v(" 重载（overload）")]),v._v(" "),_("ul",[_("li",[v._v("基本介绍：Java中允许同一个类中，多个同名方法的存在，但要求形参列表不一致！比如："),_("code",[v._v("System.out.println();")]),v._v("out是PrintStream类型")]),v._v(" "),_("li",[v._v("好处\n"),_("ol",[_("li",[v._v("减轻了起名的麻烦")]),v._v(" "),_("li",[v._v("减轻了记名的麻烦")])])]),v._v(" "),_("li",[v._v("注意事项和使用细节\n"),_("ol",[_("li",[v._v("方法名：必须相同")]),v._v(" "),_("li",[v._v("形参列表：必须不同（形参类型或个数或顺序，至少有一样不同，参数名无要求）")]),v._v(" "),_("li",[v._v("返回类型：无要求")])])])]),v._v(" "),_("h4",{attrs:{id:"可变参数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#可变参数"}},[v._v("#")]),v._v(" 可变参数")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("基本概念：Java允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法")])]),v._v(" "),_("li",[_("p",[v._v("基本语法")]),v._v(" "),_("p",[_("code",[v._v("访问修饰符 返回类型 方法名(数据类型...形参名){}")])]),v._v(" "),_("p",[v._v("使用可变参数时，可以当作数组来使用")])]),v._v(" "),_("li",[_("p",[v._v("注意事项和使用细节")]),v._v(" "),_("ol",[_("li",[v._v("可变参数的实参可以为0个或任意多个")]),v._v(" "),_("li",[v._v("可变参数的实参可以为数组")]),v._v(" "),_("li",[v._v("可变参数的本质就是数组")]),v._v(" "),_("li",[v._v("可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后")]),v._v(" "),_("li",[v._v("一个形参列表中只能出现一个可变参数")])])])]),v._v(" "),_("h4",{attrs:{id:"作用域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[v._v("#")]),v._v(" 作用域")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("基本使用")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("在Java编程中，主要的变量就是属性（成员变量）和局部变量")])]),v._v(" "),_("li",[_("p",[v._v("我们说的局部变量一般是指在成员方法中定义的变量")])]),v._v(" "),_("li",[_("p",[v._v("Java中作用域的分类")]),v._v(" "),_("p",[v._v("全局变量：也就是属性，作用域为整个类体")]),v._v(" "),_("p",[v._v("局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中！")])]),v._v(" "),_("li",[_("p",[v._v("全局变量可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值")])])])]),v._v(" "),_("li",[_("p",[v._v("注意事项和细节说明")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("属性和局部变量可以重名，访问时遵循就近原则")])]),v._v(" "),_("li",[_("p",[v._v("在同一个作用域中，比如在同一个成员方法中，两个局部变量，不能重名")])]),v._v(" "),_("li",[_("p",[v._v("属性生命周期较长，伴随着对象的创建而创建，伴随着对象的死亡而死亡。局部变量，生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而死亡。即在一次方法调用过程中。")])]),v._v(" "),_("li",[_("p",[v._v("作用域不同")]),v._v(" "),_("p",[v._v("全局变量：可以被本类使用，或其他类使用（通过对象调用）")]),v._v(" "),_("p",[v._v("局部变量：只能在本类中对应的方法中使用")])]),v._v(" "),_("li",[_("p",[v._v("修饰符不同")]),v._v(" "),_("p",[v._v("全局变量/属性可以加修饰符")]),v._v(" "),_("p",[v._v("局部变量不可以加修饰符")])])])])]),v._v(" "),_("h4",{attrs:{id:"构造器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#构造器"}},[v._v("#")]),v._v(" 构造器")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("基本语法")]),v._v(" "),_("p",[_("code",[v._v("[修饰符] 方法名(形参列表){")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("方法体;")])]),v._v(" "),_("p",[_("code",[v._v("}")])])]),v._v(" "),_("li",[_("p",[v._v("说明")]),v._v(" "),_("ol",[_("li",[v._v("构造器的修饰符可以默认")]),v._v(" "),_("li",[v._v("构造器没有返回值")]),v._v(" "),_("li",[v._v("方法名和类名字必须一样")]),v._v(" "),_("li",[v._v("参数列表和成员方法一样的规则")]),v._v(" "),_("li",[v._v("构造器的调用由系统完成")])])]),v._v(" "),_("li",[_("p",[v._v("基本介绍")]),v._v(" "),_("p",[v._v("构造方法又叫构造器（constructor），是类的一种特殊的方法，它的主要作用是完成对新对象的初始化")]),v._v(" "),_("p",[v._v("特点：")]),v._v(" "),_("ol",[_("li",[v._v("方法名和类名相同")]),v._v(" "),_("li",[v._v("没有返回值")]),v._v(" "),_("li",[v._v("在创建对象时，系统会自动的调用该类的构造器完成对对象的初始化")])])]),v._v(" "),_("li",[_("p",[v._v("注意事项和使用细节")]),v._v(" "),_("ol",[_("li",[v._v("一个类可以定义多个不同的构造器，即构造器重载")]),v._v(" "),_("li",[v._v("构造器名和类名要相同")]),v._v(" "),_("li",[v._v("构造器没有返回值")]),v._v(" "),_("li",[v._v("构造器是完成对象的初始化，并不是创建对象")]),v._v(" "),_("li",[v._v("在创建对象时，系统自动的调用该类的构造方法")]),v._v(" "),_("li",[v._v("如果程序员没有定义构造方法，系统会自动给类生成一个默认无参构造器（也叫默认构造器）")]),v._v(" "),_("li",[v._v("一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下")])])]),v._v(" "),_("li",[_("p",[v._v("反编译指令 "),_("code",[v._v("javap 文件名.class")])])]),v._v(" "),_("li",[_("p",[v._v("对象创建流程信息")]),v._v(" "),_("ol",[_("li",[v._v("加载Person类信息（Person.class），只会加载一次")]),v._v(" "),_("li",[v._v("在堆中分配空间（地址）")]),v._v(" "),_("li",[v._v("完成对象初始化【3.1 默认初始化-给类型默认初始值；3.2 显式初始化-"),_("code",[v._v("int age = 10;")]),v._v("；3.3 构造器的初始化】")]),v._v(" "),_("li",[v._v("在对象在堆中的地址，返回给P（P是对象名，也可以理解成是对象的引用）")])])])]),v._v(" "),_("h4",{attrs:{id:"this"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[v._v("#")]),v._v(" this")]),v._v(" "),_("ul",[_("li",[v._v("概念：Jav a虚拟机会给每个对象分配this，代表当前对象")]),v._v(" "),_("li",[v._v("注意事项和使用细节\n"),_("ol",[_("li",[v._v("this关键字可以用来访问本类的属性、方法、构造器")]),v._v(" "),_("li",[v._v("this用于区分当前类的属性和局部变量")]),v._v(" "),_("li",[v._v("访问成员方法的语法：this.方法名(参数列表);")]),v._v(" "),_("li",[v._v("访问构造器语法：this(参数列表);注意只能在构造器中使用（即只能在构造器中访问另外一个构造器，必须放在第一条语句）")]),v._v(" "),_("li",[v._v("this不能在类定义的外部使用，只能在类定义的方法中使用")])])])]),v._v(" "),_("h3",{attrs:{id:"面向对象编程-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#面向对象编程-中级"}},[v._v("#")]),v._v(" 面向对象编程（中级）")]),v._v(" "),_("h4",{attrs:{id:"idea"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#idea"}},[v._v("#")]),v._v(" IDEA")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("IDEA的基本介绍和使用：IDEA是以项目的概念，来管理我们的java源码的")])]),v._v(" "),_("li",[_("p",[v._v("常用快捷键")]),v._v(" "),_("ul",[_("li",[v._v("删除当前行，默认是 ctrl + Y，自己配置 ctrl + d")]),v._v(" "),_("li",[v._v("复制当前行，自己配置 ctrl + alt + 向下光标")]),v._v(" "),_("li",[v._v("补全代码 alt + /")]),v._v(" "),_("li",[v._v("添加注释和取消注释 ctrl + /【第一次是添加注释，第二次是取消注释】")]),v._v(" "),_("li",[v._v("导入该行需要的类，先配置auto import，然后使用 alt + enter 即可")]),v._v(" "),_("li",[v._v("快速格式化代码 ctrl + alt + L")]),v._v(" "),_("li",[v._v("快速运行程序，自己定义 alt + R")]),v._v(" "),_("li",[v._v("生成构造方法等 alt + insert 【提高开发效率】")]),v._v(" "),_("li",[v._v("查看一个类的层级关系 ctrl + H【学习继承后，非常有用】")]),v._v(" "),_("li",[v._v("将光标放在一个方法上，输入 ctrl + B，可以选择定位到哪个类的方法【学继承后，非常有用】")]),v._v(" "),_("li",[v._v("自动的分配变量名，通过在后面 .var")])])]),v._v(" "),_("li",[_("p",[v._v("模板/自定义模板")]),v._v(" "),_("p",[v._v("file -> settings -> editor -> Live templates")])])]),v._v(" "),_("h4",{attrs:{id:"包"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#包"}},[v._v("#")]),v._v(" 包")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("三大作用")]),v._v(" "),_("ul",[_("li",[v._v("区分相同名字的类")]),v._v(" "),_("li",[v._v("当类很多时，可以很好的管理类【看Java API文档】")]),v._v(" "),_("li",[v._v("控制访问范围")])])]),v._v(" "),_("li",[_("p",[v._v("基本语法")]),v._v(" "),_("p",[_("code",[v._v("package com.hspedu;")])]),v._v(" "),_("ol",[_("li",[v._v("package关键字，表示打包")]),v._v(" "),_("li",[v._v("com.hspedu：表示包名")])])]),v._v(" "),_("li",[_("p",[v._v("包的本质：包实际上就是创建不同的文件夹来保存类文件")])]),v._v(" "),_("li",[_("p",[v._v("包的命名")]),v._v(" "),_("p",[v._v("命名规 则：只能包含数字、字母、下划线、小圆点，但不能是关键字或保留字")]),v._v(" "),_("p",[v._v("命名规范：一般是小写字母 + 小圆点，一般是"),_("code",[v._v("com.公司名.项目名.业务逻辑块")])])]),v._v(" "),_("li",[_("p",[v._v("常用的包")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("java.lang.*")]),v._v("，lang包是基本包，默认引入，不需要再引入")]),v._v(" "),_("li",[_("code",[v._v("java.util.*")]),v._v("，util包，系统提供的工具包，工具类，使Scanner")]),v._v(" "),_("li",[_("code",[v._v("java.net.*")]),v._v("，网络包，网络开发")]),v._v(" "),_("li",[_("code",[v._v("java.awt.*")]),v._v("，是做java的界面开发，GUI")])])]),v._v(" "),_("li",[_("p",[v._v("引入包：语法："),_("code",[v._v("import 包;")])])]),v._v(" "),_("li",[_("p",[v._v("注意事项和使用细节")]),v._v(" "),_("ol",[_("li",[v._v("package 的作用是声明当前类所在的包，需要放在class 的最上面，一个类中最多只有一句package")]),v._v(" "),_("li",[v._v("import 指令，位置放在package的下面，在类定义前面，可以有多句且没有顺序要求")])])])]),v._v(" "),_("h4",{attrs:{id:"访问修饰符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#访问修饰符"}},[v._v("#")]),v._v(" 访问修饰符")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("基本介绍：java提供四种访问控制修饰符号控制方法和属性（成员变量）的访问权限（范围）")]),v._v(" "),_("ol",[_("li",[v._v("公开级别：用public修饰，对外公开")]),v._v(" "),_("li",[v._v("受保护级别：用protected修饰，对子类和同一个包中的类公开")]),v._v(" "),_("li",[v._v("默认级别：没有修饰符号，向同一个包的类公开")]),v._v(" "),_("li",[v._v("私有级别：用private修饰，只有类本身可以访问，不对外公开")])])]),v._v(" "),_("li",[_("p",[v._v("使用的注意事项")]),v._v(" "),_("ol",[_("li",[v._v("修饰符可以用来修饰类中的属性，成员方法以及类")]),v._v(" "),_("li",[v._v("只有默认的和public才能修饰类！，并且遵循上述访问权限的特点")]),v._v(" "),_("li",[v._v("成员方法的访问规则和属性完全一样")])])])]),v._v(" "),_("h4",{attrs:{id:"封装"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#封装"}},[v._v("#")]),v._v(" 封装")]),v._v(" "),_("p",[v._v("面向对象编程三大特征：封装、继承和多态")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("介绍：封装就是把抽象出的数据【属性】和对数据的操作【方法】封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作【方法】，才能对数据进行操作")])]),v._v(" "),_("li",[_("p",[v._v("封装的理解和好处")]),v._v(" "),_("ol",[_("li",[v._v("隐藏实现细节")]),v._v(" "),_("li",[v._v("可以对数据进行验证，保证安全合理")])])]),v._v(" "),_("li",[_("p",[v._v("封装实现步骤")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("将属性进行私有化【不能直接修改属性】")])]),v._v(" "),_("li",[_("p",[v._v("提供一个公共的(public)set方法，用于对属性判断并赋值")]),v._v(" "),_("p",[_("code",[v._v("public void setXxx(类型 参数名){")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("属性 = 参数名;\t//加入数据验证的业务逻辑")])]),v._v(" "),_("p",[_("code",[v._v("}")])])]),v._v(" "),_("li",[_("p",[v._v("提供一个公共的(public)get方法，用于获取属性的值")]),v._v(" "),_("p",[_("code",[v._v("public XX getXxx(){//权限判断")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("return xx;")])]),v._v(" "),_("p",[_("code",[v._v("}")])])])])])]),v._v(" "),_("h4",{attrs:{id:"继承"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[v._v("#")]),v._v(" 继承")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("基本介绍：继承可以解决代码复用，让我们的编程更加靠近人类思维，当多个类存在相同的属性（变量）和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过extends来声明继承父类即可")])]),v._v(" "),_("li",[_("p",[v._v("基本语法")]),v._v(" "),_("p",[_("code",[v._v("class 子类 extends 父类{}")])]),v._v(" "),_("ol",[_("li",[v._v("子类就会自动拥有父类定义的属性和方法")]),v._v(" "),_("li",[v._v("父类又叫超类，基类")]),v._v(" "),_("li",[v._v("子类又叫派生类")])])]),v._v(" "),_("li",[_("p",[v._v("继承细节问题")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问，但是私有属性和方法不能在子类直接访问，要通过公共的方法去访问")])]),v._v(" "),_("li",[_("p",[v._v("子类必须调用父类的构造器，完成父类的初始化")])]),v._v(" "),_("li",[_("p",[v._v("当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过")])]),v._v(" "),_("li",[_("p",[v._v("如果希望指定去调用父类的某个构造器，则显式的调用 一下super(参数列表)")])]),v._v(" "),_("li",[_("p",[v._v("super在使用时，需要放在构造器第一行(super只能在构造器中使用)")])]),v._v(" "),_("li",[_("p",[v._v("super()和this()都只能放在构造器第一行，因此这两个方法不能共存在一个构造器")])]),v._v(" "),_("li",[_("p",[v._v("java所有类都是Object类的子类，Object类是所有类的基类")])]),v._v(" "),_("li",[_("p",[v._v("父类构造器的调用不限于直接父类！将一直往上追溯直到Object类（顶级父类）")])]),v._v(" "),_("li",[_("p",[v._v("子类最多只能继承一个父类（指直接继承），即java中是单继承机制")])]),v._v(" "),_("li",[_("p",[v._v("不能滥用继承 ，子类和父类之间必须满足is-a的逻辑关系")]),v._v(" "),_("p",[_("code",[v._v("Person is a Music?")])]),v._v(" "),_("p",[_("code",[v._v("Person Music")])]),v._v(" "),_("p",[_("code",[v._v("Music extends Person\t// 不合理")])]),v._v(" "),_("p",[_("code",[v._v("Animal")])]),v._v(" "),_("p",[_("code",[v._v("Cat extends Animal\t// 合理")])])])])]),v._v(" "),_("li",[_("p",[v._v("继承本质：当子类对象创建好后，建立查找的关系")])])]),v._v(" "),_("h4",{attrs:{id:"多态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多态"}},[v._v("#")]),v._v(" 多态")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("基本介绍：方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。")])]),v._v(" "),_("li",[_("p",[v._v("具体体现")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("方法的多态，重写和重载就体现多态")])]),v._v(" "),_("li",[_("p",[v._v("对象的多态")]),v._v(" "),_("p",[v._v("（1）一个对象的编译类型和运行类型可以不一致")]),v._v(" "),_("p",[v._v("（2）编译类型在定义对象时，就确定了，不能改变")]),v._v(" "),_("p",[v._v("（3）运行类型是可以变化的，通过getClass()来查看运行")]),v._v(" "),_("p",[v._v("（4）编译类型看定义时 = 号的左边，运行类型看 = 号的右边")])])])]),v._v(" "),_("li",[_("p",[v._v("注意事项和细节讨论")]),v._v(" "),_("p",[v._v("前提：两个对象（类）存在继承关系")]),v._v(" "),_("p",[v._v("向上转型")]),v._v(" "),_("ol",[_("li",[v._v("本质：父类的引用指向了子类的对象")]),v._v(" "),_("li",[v._v("语法：父类类型 引用名 = new 子类类型();")]),v._v(" "),_("li",[v._v("特点：编译类型看左边，运行类型看右边。可以调用父类中的所有成员（需遵守访问权限），不能调用 子类中的特有成员；最终运行效果看子类的具体实现！")])]),v._v(" "),_("p",[v._v("向下转型")]),v._v(" "),_("ol",[_("li",[v._v("语法：子类类型 引用名 = （子类类型） 父类引用;")]),v._v(" "),_("li",[v._v("只能强转父类的引用，不能强转父类的对象")]),v._v(" "),_("li",[v._v("要求父类的引用必须指向的是当前目标类型的对象")]),v._v(" "),_("li",[v._v("当向下转型后， 可以调用子类类型中所有的成员")])]),v._v(" "),_("p",[v._v("属性没有重写之说！属性的值看编译类型")]),v._v(" "),_("p",[v._v("instanceof 比较操作符，用于判断对象的运行类型是否为XX类型或XX类型的子类型")])]),v._v(" "),_("li",[_("p",[v._v("Java动态绑定机制")]),v._v(" "),_("ol",[_("li",[v._v("当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定")]),v._v(" "),_("li",[v._v("当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用")])])]),v._v(" "),_("li",[_("p",[v._v("多态的应用")]),v._v(" "),_("ol",[_("li",[v._v("多态数组：数组的定义类型为父类类型，里面保存的实际元素类型为子类类型")]),v._v(" "),_("li",[v._v("多态参数：方法定义的形参类型为父类类型，实参类型允许为子类类型")])])])]),v._v(" "),_("h4",{attrs:{id:"super"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#super"}},[v._v("#")]),v._v(" Super")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("基本介绍：super代表父类的引用，用于访问父类的属性、方法、构造器")])]),v._v(" "),_("li",[_("p",[v._v("基本语法")]),v._v(" "),_("ol",[_("li",[v._v("访问父类的属性，但不能访问父类的private属性"),_("code",[v._v("super.方法名(参数列表);")])]),v._v(" "),_("li",[v._v("访问父类的方法，不能访问父类的private方法"),_("code",[v._v("super.方法名(参数列表);")])]),v._v(" "),_("li",[v._v("访问父类的构造器："),_("code",[v._v("super(参数列表);")]),v._v("只能放在构造器的第一句，只能出现一句！")])])]),v._v(" "),_("li",[_("p",[v._v("super给编程带来的便利")]),v._v(" "),_("ol",[_("li",[v._v("调用父类的构造器的好处（分工明确，父类属性由父类初始化，子类的属性由子类初始化）")]),v._v(" "),_("li",[v._v("当子类中有和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果！")]),v._v(" "),_("li",[v._v("super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类（上级类）中都有同名的成员，使用super访问遵循就近原则")])])]),v._v(" "),_("li",[_("p",[v._v("super和this的比较")]),v._v(" "),_("ol",[_("li",[v._v("访问属性：this访问本类中的属性，如果本类没有此属性则从父类中继续查找；super访问父类中的属性")]),v._v(" "),_("li",[v._v("调用方法：this访问本类中的方法，如果本类没有此方法则从父类继续查找；super直接访问父类中的方法")]),v._v(" "),_("li",[v._v("调用构造器：this调用本类构造器，必须放在构造器的首行；super调用父类构造器，必须放在子类构造器的首行")]),v._v(" "),_("li",[v._v("特殊：this表示当前对象；super子类中访问父类对象")])])])]),v._v(" "),_("h4",{attrs:{id:"overwrite"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#overwrite"}},[v._v("#")]),v._v(" overwrite")]),v._v(" "),_("ul",[_("li",[v._v("基本介绍：方法覆盖就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这个方法覆盖了父类的那个方法")]),v._v(" "),_("li",[v._v("注意事项和使用细节：方法重写也叫方法覆盖\n"),_("ol",[_("li",[v._v("子类的方法的参数，方法名称，要和父类方法的参数，方法名称完全一样")]),v._v(" "),_("li",[v._v("子类方法的  返回类型和父类方法返回类型一样，或者是父类返回类型的子类")]),v._v(" "),_("li",[v._v("子类方法不能缩小父类方法的访问权限")])])])]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("名称")]),v._v(" "),_("th",[v._v("发生范围")]),v._v(" "),_("th",[v._v("方法名")]),v._v(" "),_("th",[v._v("形参列表")]),v._v(" "),_("th",[v._v("返回类型")]),v._v(" "),_("th",[v._v("修饰符")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("重载(overload)")]),v._v(" "),_("td",[v._v("本类")]),v._v(" "),_("td",[v._v("必须一样")]),v._v(" "),_("td",[v._v("类型，个数或者顺序至少有一个不同")]),v._v(" "),_("td",[v._v("无需求")]),v._v(" "),_("td",[v._v("无需求")])]),v._v(" "),_("tr",[_("td",[v._v("重写(override)")]),v._v(" "),_("td",[v._v("父子类")]),v._v(" "),_("td",[v._v("必须一样")]),v._v(" "),_("td",[v._v("相同")]),v._v(" "),_("td",[v._v("子类重写的方法，返回的类型和父类返回的类型一致，或者是其子类")]),v._v(" "),_("td",[v._v("子类方法不能缩小父类方法的访问范围")])])])]),v._v(" "),_("h4",{attrs:{id:"object类详解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#object类详解"}},[v._v("#")]),v._v(" Object类详解")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("equals方法")]),v._v(" "),_("p",[v._v("==和equals的对比")]),v._v(" "),_("p",[v._v("==是一个比较运算符")]),v._v(" "),_("ol",[_("li",[v._v("==：既可以判断基本类型，又可以判断引用类型")]),v._v(" "),_("li",[v._v("==：如果判断基本类型，判断的是值是否相等")]),v._v(" "),_("li",[v._v("==：如果判断引用类型，判断的是地址是否相等，即判定是不是同一个对象")]),v._v(" "),_("li",[v._v("equals：是Object类中的方法，只能判断引用类型")]),v._v(" "),_("li",[v._v("默认判断的是地址是否相等 ，子类中往往重写该方法，用于判断内容是否相等")])])]),v._v(" "),_("li",[_("p",[v._v("hashCode方法")]),v._v(" "),_("ol",[_("li",[v._v("提高具有哈希结构的容器的效率")]),v._v(" "),_("li",[v._v("两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！")]),v._v(" "),_("li",[v._v("两个引用，如果指向的是不同对象，则哈希值是不一样的")]),v._v(" "),_("li",[v._v("哈希值主要根据地址号来的！不能完全将哈希值等价于地址")])])]),v._v(" "),_("li",[_("p",[v._v("toString方法")]),v._v(" "),_("ul",[_("li",[v._v("基本介绍：默认返回：全类名 + @ + 哈希值的十六进制，【查看Object的toString方法】子类往往重写toString方法，用于返回对象的属性信息")]),v._v(" "),_("li",[v._v("重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式")]),v._v(" "),_("li",[v._v("当直接输出一个对象时，toString方法会被默认的调用")])])]),v._v(" "),_("li",[_("p",[v._v("finalize方法")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作")])]),v._v(" "),_("li",[_("p",[v._v("什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize方法")])]),v._v(" "),_("li",[_("p",[v._v("垃圾回收机制的调用，是由系统来决定（即有自己的GC算法），也可以通过System.gc()主动触发垃圾回收机制")]),v._v(" "),_("p",[v._v("提示：我们在实际开发中，几乎不会运用finalize，所以更多就是为了应付面试")])])])])]),v._v(" "),_("h4",{attrs:{id:"断点调试-debug"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#断点调试-debug"}},[v._v("#")]),v._v(" 断点调试（debug）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("一个实际需求")]),v._v(" "),_("ol",[_("li",[v._v("在开发中，新手程序员在查找错误时，这时老程序员就会温馨提示，可以用断点调试一步一步的看源码执行的过程，从而发现错误所在")]),v._v(" "),_("li",[v._v("重要提示：在断点调试过程中，是运行状态，是以对象的运行类型来执行的")])])]),v._v(" "),_("li",[_("p",[v._v("断点调试介绍")]),v._v(" "),_("ol",[_("li",[v._v("断点调试是指在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。进行分析从而找到这个Bug")]),v._v(" "),_("li",[v._v("断点调试也是程序员必须掌握的技能")]),v._v(" "),_("li",[v._v("断点调试也能帮助我们查看java底层源代码的执行过程，提高程序员的Java水平")])])]),v._v(" "),_("li",[_("p",[v._v("快捷键")]),v._v(" "),_("p",[v._v("F7（跳入）：跳入方法内、F8（跳过）：逐行执行代码、shift+F8（跳出）：跳出方法、F9（resume，执行到下一个断点）")])]),v._v(" "),_("li",[_("p",[v._v("断点技巧：断点可以在debug过程中，动态的下断点")])])])])}),[],!1,null,null,null);_.default=a.exports}}]);