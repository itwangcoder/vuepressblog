(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{448:function(v,_,t){"use strict";t.r(_);var i=t(2),a=Object(i.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"java基础-韩顺平"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java基础-韩顺平"}},[v._v("#")]),v._v(" Java基础---韩顺平")]),v._v(" "),_("h2",{attrs:{id:"二、提高编程能力"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、提高编程能力"}},[v._v("#")]),v._v(" 二、提高编程能力")]),v._v(" "),_("h3",{attrs:{id:"面向对象编程-高级部分"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#面向对象编程-高级部分"}},[v._v("#")]),v._v(" 面向对象编程（高级部分）")]),v._v(" "),_("h4",{attrs:{id:"类变量和类方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类变量和类方法"}},[v._v("#")]),v._v(" 类变量和类方法")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("类变量内存布局")]),v._v(" "),_("p",[v._v("static变量是对象共享，不管static变量在哪里，共识")]),v._v(" "),_("ol",[_("li",[v._v("static变量是同一个类所有对象共享")]),v._v(" "),_("li",[v._v("static变量，在类加载的时候就生成了")])])]),v._v(" "),_("li",[_("p",[v._v("什么是类变量：类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量。")])]),v._v(" "),_("li",[_("p",[v._v("类变量定义")]),v._v(" "),_("p",[v._v("定义语法：")]),v._v(" "),_("p",[_("code",[v._v("访问修饰符 static 数据类型 变量名;[推荐]")])]),v._v(" "),_("p",[_("code",[v._v("static 访问修饰符 数据类型 变量名;")])]),v._v(" "),_("p",[v._v("访问类变量：类名.类变量名【推荐】 或者 对象名.类变量名【静态变量的访问修饰符的访问权限和范围和普通属性是一样的】")])]),v._v(" "),_("li",[_("p",[v._v("类变量注意事项和细节讨论")]),v._v(" "),_("ol",[_("li",[v._v("当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量（静态变量）")]),v._v(" "),_("li",[v._v("类变量是该类的所有对象共享的，而实例变量是每个对象独享的")]),v._v(" "),_("li",[v._v("加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量")]),v._v(" "),_("li",[v._v("类变量可以通过类名.类变量名 或者 对象名.类变量名来访问，但java设计者推荐我们使用类名.类变量名方式访问【前提是满足访问修饰符的访问权限和范围】")]),v._v(" "),_("li",[v._v("实例变量不能通过 类名.类变量名 方式访问")]),v._v(" "),_("li",[v._v("类变量是在类加载时就初始化了，也就是说，即使你没有创建对象，只要类加载了，就可以使用类变量了")]),v._v(" "),_("li",[v._v("类变量的生命周期是随类的加载开始，随着类的消亡而销毁")])])]),v._v(" "),_("li",[_("p",[v._v("类方法基本介绍：")]),v._v(" "),_("p",[v._v("也叫静态方法，形式如下")]),v._v(" "),_("p",[_("code",[v._v("访问修饰符 static 数据返回类型 方法名(){}")]),v._v("【推荐】")]),v._v(" "),_("p",[_("code",[v._v("static 访问修饰符 数据返回类型 方法名(){}")])])]),v._v(" "),_("li",[_("p",[v._v("类方法的调用：")]),v._v(" "),_("p",[v._v("使用方式：类名.类方法名 或者 对象名.类方法名【前提是满足访问修饰符的访问权限和范围】")])]),v._v(" "),_("li",[_("p",[v._v("经典使用场景：当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率")])]),v._v(" "),_("li",[_("p",[v._v("类方法使用注意事项和细节讨论")]),v._v(" "),_("ol",[_("li",[v._v("类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：类方法中无this的参数；普通方法中隐含着this的参数")]),v._v(" "),_("li",[v._v("类方法可以通过类名调用，也可以通过对象名调用")]),v._v(" "),_("li",[v._v("普通方法和对象有关，需要通过对象名调用，比如对象名.方法名（参数），不能通过类名调用")]),v._v(" "),_("li",[v._v("类方法中不允许使用和对象有关的关键字，比如this和super。普通方法（成员方法）可以")]),v._v(" "),_("li",[v._v("类方法（静态方法）中只能访问静态变量或静态方法")]),v._v(" "),_("li",[v._v("普通成员方法，既可以访问（非静态）普通变量（方法），也可以访问静态变量（方法）")])]),v._v(" "),_("p",[v._v("小结：静态方法，只能访问静态的成员，非静态的方法，可以访问静态成员和非静态成员（必须遵守访问权限）")])])]),v._v(" "),_("h4",{attrs:{id:"理解main方法语法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#理解main方法语法"}},[v._v("#")]),v._v(" 理解main方法语法")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("深入理解main方法")]),v._v(" "),_("ol",[_("li",[v._v("java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public")]),v._v(" "),_("li",[v._v("java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static")]),v._v(" "),_("li",[v._v("该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数")]),v._v(" "),_("li",[v._v("java执行的程序 参数1 参数2 参数3")])])]),v._v(" "),_("li",[_("p",[v._v("特别提示")]),v._v(" "),_("ol",[_("li",[v._v("在main()方法中，我们可以直接调用main方法所在类的静态方法或静态属性")]),v._v(" "),_("li",[v._v("但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员")])])])]),v._v(" "),_("h4",{attrs:{id:"代码块"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#代码块"}},[v._v("#")]),v._v(" 代码块")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("基本介绍")]),v._v(" "),_("p",[v._v("代码化块又称为初始化块，属于类中的成员【即是类的一部分】，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来。")]),v._v(" "),_("p",[v._v("但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用")])]),v._v(" "),_("li",[_("p",[v._v("基本语法")]),v._v(" "),_("p",[_("code",[v._v("[修饰符]{")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("代码")])]),v._v(" "),_("p",[_("code",[v._v("};")])]),v._v(" "),_("p",[v._v("注意：")]),v._v(" "),_("ol",[_("li",[v._v("修饰符可选，要写的话，也只能写static")]),v._v(" "),_("li",[v._v("代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块")]),v._v(" "),_("li",[v._v("逻辑语句可以为任何逻辑语句（输入、输出、方法调用、循环、判断等）")]),v._v(" "),_("li",[v._v(";号可以写上，也可以省略")])])]),v._v(" "),_("li",[_("p",[v._v("代码块的好处")]),v._v(" "),_("ol",[_("li",[v._v("相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化的操作")]),v._v(" "),_("li",[v._v("如果多个构造器中都有重复的语句，可以抽到初始化块中，提高代码的重用性")])])]),v._v(" "),_("li",[_("p",[v._v("代码块使用注意事项和细节讨论")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次。如果是普通代码块，每创建一个对象，就执行")])]),v._v(" "),_("li",[_("p",[v._v("类什么时候被加载：")]),v._v(" "),_("p",[v._v("①创建对象实例时")]),v._v(" "),_("p",[v._v("②创建子类对象实例，父类也会被加载")]),v._v(" "),_("p",[v._v("③使用类的静态成员时（静态属性，静态方法）")])]),v._v(" "),_("li",[_("p",[v._v("普通的代码块，在创建对象实例时，会被隐式的调用。被创建一次，就会调用一次。如果只是使用类的静态成员时，普通代码块并不会执行。")])]),v._v(" "),_("li",[_("p",[v._v("创建一个对象时，在一个类调用顺序是：")]),v._v(" "),_("p",[v._v("①调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码和多个静态变量初始化，则按他们定义的顺序调用）")]),v._v(" "),_("p",[v._v("②调用普通代码块和普通属性的初始化（注意：普通代码块和普通属性初始化调用的优先级一样，如果多个普通代码块和多个普通属性初始化，则按定义顺序调用）")]),v._v(" "),_("p",[v._v("③调用构造方法")])]),v._v(" "),_("li",[_("p",[v._v("构造方法（构造器）的最前面其实隐含了super()和调用普通代码块，新写一个类演示【截图+说明】，静态相关的代码块，属性初始化，在类加载时，就执行完毕，因此是优先于构造器和普通代码块执行的")])]),v._v(" "),_("li",[_("p",[v._v("创建一个子类对象时（继承关系），他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下 ：")]),v._v(" "),_("p",[v._v("①父类的静态代码块和静态属性（优先级一样，按定义顺序执行）")]),v._v(" "),_("p",[v._v("②子类的静态代码块和静态属性（优先级一样，按定义顺序执行）")]),v._v(" "),_("p",[v._v("③父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）")]),v._v(" "),_("p",[v._v("④父类的构造方法")]),v._v(" "),_("p",[v._v("⑤子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）")]),v._v(" "),_("p",[v._v("⑥子类的构造方法")])]),v._v(" "),_("li",[_("p",[v._v("静态代码块只能调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员")])])])])]),v._v(" "),_("h4",{attrs:{id:"单例设计模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#单例设计模式"}},[v._v("#")]),v._v(" 单例设计模式")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("什么是设计模式")]),v._v(" "),_("ol",[_("li",[v._v("静态方法和属性的经典使用")]),v._v(" "),_("li",[v._v("设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式就像是经典的棋谱，不同的棋局，我们使用不同的棋谱。")])])]),v._v(" "),_("li",[_("p",[v._v("什么是单例模式")]),v._v(" "),_("ol",[_("li",[v._v("所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法")]),v._v(" "),_("li",[v._v("单例模式有两种方式：①饿汉式 ②懒汉式")])])]),v._v(" "),_("li",[_("p",[v._v("单例设计模式应用步骤")]),v._v(" "),_("ol",[_("li",[v._v("构造器私有化 ==》 防止直接new")]),v._v(" "),_("li",[v._v("类的内部创建对象")]),v._v(" "),_("li",[v._v("向外暴露一个静态的公共方法。getInstance")]),v._v(" "),_("li",[v._v("代码实现")])])]),v._v(" "),_("li",[_("p",[v._v("饿汉式VS懒汉式")]),v._v(" "),_("ol",[_("li",[v._v("二者最主要的区别在于创建对象的时机不同：饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建")]),v._v(" "),_("li",[v._v("饿汉式不存在线程安全问题，懒汉式存在线程安全问题")]),v._v(" "),_("li",[v._v("饿汉式存在浪费资源的可能。因为如果程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题")]),v._v(" "),_("li",[v._v("在我们javaSE标准类中，java.lang.Runtime就是经典的单例模式")])])])]),v._v(" "),_("h4",{attrs:{id:"final关键字"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#final关键字"}},[v._v("#")]),v._v(" final关键字")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("基本介绍")]),v._v(" "),_("p",[v._v("final中文意思：最后的，最终的。")]),v._v(" "),_("p",[v._v("final可以修饰类、属性、方法和局部变量")]),v._v(" "),_("p",[v._v("在某些情况下，程序员可能有以下需求，就会使用到final：")]),v._v(" "),_("ol",[_("li",[v._v("当不希望类被继承时，可以用final修饰")]),v._v(" "),_("li",[v._v("当不希望父类的某个方法被子类覆盖/重写（override）时，可以用final关键字修饰")]),v._v(" "),_("li",[v._v("当不希望类的某个属性的值被修改，可以用final修饰")]),v._v(" "),_("li",[v._v("当不希望某个局部变量被修改，可以使用final修饰")])])]),v._v(" "),_("li",[_("p",[v._v("final使用注意事项和细节讨论")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("final修饰的属性又叫常量，一般用XX_XX_XX来命名")])]),v._v(" "),_("li",[_("p",[v._v("final修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以在如下位置之一【选择一个位置赋初值即可】")]),v._v(" "),_("p",[v._v("①定义时：如public final double TAX_RATE = 0.08;")]),v._v(" "),_("p",[v._v("②在构造器中")]),v._v(" "),_("p",[v._v("③在代码块中")])]),v._v(" "),_("li",[_("p",[v._v("如果final修饰的属性是静态的，则初始化的位置只能是")]),v._v(" "),_("p",[v._v("①定义时")]),v._v(" "),_("p",[v._v("②在静态代码块不能在构造器中赋值")])]),v._v(" "),_("li",[_("p",[v._v("final类不能继承，但是可以实例化对象")])]),v._v(" "),_("li",[_("p",[v._v("如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承")])]),v._v(" "),_("li",[_("p",[v._v("一般来说，如果一个类已经是final类了，就没有必要再将方法修饰成final方法")])]),v._v(" "),_("li",[_("p",[v._v("final不能修饰构造方法（即构造器）")])]),v._v(" "),_("li",[_("p",[v._v("final和static往往搭配使用，效率更高，不会导致类加载，底层编译器做了优化处理")])]),v._v(" "),_("li",[_("p",[v._v("包装类（Integer，Double，Float，Boolean等都是final），String也是final类")])])])])]),v._v(" "),_("h4",{attrs:{id:"抽象类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#抽象类"}},[v._v("#")]),v._v(" 抽象类")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("当父类的某些方法，需要声明，但是又不确定如何实现时，可以将其声明为抽象方法，那么 这个类就是抽象类")])]),v._v(" "),_("li",[_("p",[v._v("抽象类快速入门：当父类的一些方法不能确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰该类就是抽象类")])]),v._v(" "),_("li",[_("p",[v._v("所谓抽象方法就是没有实现的方法，所谓没有实现就是指，没有方法体，当一个类中存在抽象方法时，需要将该类声明为abstract类，一般来说，抽象类会被继承，有其子类来实现抽象方法")])]),v._v(" "),_("li",[_("p",[v._v("抽象类的介绍")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("用abstract关键字来修饰一个类时，这个类就叫抽象类")]),v._v(" "),_("p",[_("code",[v._v("访问修饰符 abstract 类名{}")])])]),v._v(" "),_("li",[_("p",[v._v("用abstract关键字来修饰一个方法时，这个方法就是抽象方法")]),v._v(" "),_("p",[_("code",[v._v("访问修饰符 abstract 返回类型 方法名(参数列表);//没有方法体")])])]),v._v(" "),_("li",[_("p",[v._v("抽象类的价值更多作用是在于设计 ，是设计者设计好后，让子类继承并实现抽象类()")])])])]),v._v(" "),_("li",[_("p",[v._v("抽象类使用的注意事项和细节讨论")]),v._v(" "),_("ol",[_("li",[v._v("抽象类不能被实例化")]),v._v(" "),_("li",[v._v("抽象类不一定要包含abstract方法。也就是说，抽象类可以没有abstract方法")]),v._v(" "),_("li",[v._v("一旦类包含了abstract方法，则这个类必须声明为abstract")]),v._v(" "),_("li",[v._v("abstract只能修饰类和方法，不能修饰属性和其它的")]),v._v(" "),_("li",[v._v("抽象类可以有任意成员【因为抽象类本质还是类】，比如：非抽象方法、构造器、静态属性等等")]),v._v(" "),_("li",[v._v("抽象方法不能有主体，即不能实现")]),v._v(" "),_("li",[v._v("如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类")]),v._v(" "),_("li",[v._v("抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的")])])]),v._v(" "),_("li",[_("p",[v._v("抽象类实践-模板设计模式")]),v._v(" "),_("p",[v._v("需求")]),v._v(" "),_("ol",[_("li",[v._v("有多个类，完成不同的任务job")]),v._v(" "),_("li",[v._v("要求能够得到各自完成任务的时间")])]),v._v(" "),_("p",[v._v("其它")])])]),v._v(" "),_("h4",{attrs:{id:"接口"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[v._v("#")]),v._v(" 接口")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("基本介绍")]),v._v(" "),_("p",[v._v("接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，在根据具体情况把这些方法写出来。语法：")]),v._v(" "),_("p",[_("code",[v._v("interface 接口名{")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("//属性")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("//方法（1.抽象方法：可以省略abstract关键字 2.默认实现方法：jdk8后，需要使用default关键字修饰 3.静态方法：jdk8后）")])]),v._v(" "),_("p",[_("code",[v._v("}")])]),v._v(" "),_("p",[_("code",[v._v("class 类名 implements 接口{")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("自己属性")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("自己方法")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("必须实现的接口的抽象方法")])]),v._v(" "),_("p",[_("code",[v._v("}")])]),v._v(" "),_("p",[v._v("小结：")]),v._v(" "),_("ol",[_("li",[v._v("在JDK7.0前，接口里的所有方法都没有方法体，即都是抽象方法")]),v._v(" "),_("li",[v._v("JDK8.0后接口 类可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现")])])]),v._v(" "),_("li",[_("p",[v._v("注意事项和细节")]),v._v(" "),_("ol",[_("li",[v._v("接口不能被实例化")]),v._v(" "),_("li",[v._v("接口中所有的方法是public方法，接口中抽象方法，可以不用abstract修饰")]),v._v(" "),_("li",[v._v("一个普通类实现接口，就必须将该接口的所有方法都实现")]),v._v(" "),_("li",[v._v("抽象类实现接口，可以不用实现接口的方法")]),v._v(" "),_("li",[v._v("一个类同时可以实现多个接口")]),v._v(" "),_("li",[v._v("接口中的属性，只能是final的，而且是public static final修饰符。比如：int a = 1;实际上是public static final int a = 1;（必须初始化）")]),v._v(" "),_("li",[v._v("接口中属性的访问形式：接口名.属性名")]),v._v(" "),_("li",[v._v("一个接口不能继承其它的类，但是可以继承多个别的接口")]),v._v(" "),_("li",[v._v("接口的修饰符只能是public和默认，这点和类的修饰符是一样的")])])]),v._v(" "),_("li",[_("p",[v._v("继承类VS实现接口")]),v._v(" "),_("p",[v._v("当子类继承了父类，就自动的拥有父类的功能。如果子类需要扩展功能，可以通过实现接口的方式扩展。可以理解，实现接口是对java单继承机制的一种补充")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("接口和继承解决的问题不同")]),v._v(" "),_("p",[v._v("继承的价值主要在于：解决代码的复用性和可维护性")]),v._v(" "),_("p",[v._v("接口的价值主要在于：设计，设计好各种规范（方法），让其它类去实现这些方法")])]),v._v(" "),_("li",[_("p",[v._v("接口比继承更加灵活")]),v._v(" "),_("p",[v._v("接口比继承更加灵活，继承是满足is-a的关系，而接口只需满足like-a的关系")])]),v._v(" "),_("li",[_("p",[v._v("接口在一定程度上实现代码解耦【即接口规范性+动态绑定】")])])])]),v._v(" "),_("li",[_("p",[v._v("接口的多态特性")]),v._v(" "),_("ol",[_("li",[v._v("多态参数：在前面的Usb接口案例，Usb usb，既可以接收手机对象，又可以接收相机对象，就体现了接口多态（接口引用可以指向实现了接口的类的对象）")]),v._v(" "),_("li",[v._v("多态数组")]),v._v(" "),_("li",[v._v("接口存在多态传递现象")])])])]),v._v(" "),_("h4",{attrs:{id:"内部类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内部类"}},[v._v("#")]),v._v(" 内部类")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("基本介绍")]),v._v(" "),_("p",[v._v("一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类（inner class），嵌套其他类的类称为外部类（outer class）。是我们类的第五大成员【属性、方法、构造器、代码块、内部类】，内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系")])]),v._v(" "),_("li",[_("p",[v._v("基本语法")]),v._v(" "),_("p",[_("code",[v._v("class Outer{//外部类")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("class Inner{//内部类")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("}")])]),v._v(" "),_("p",[_("code",[v._v("}")])]),v._v(" "),_("p",[_("code",[v._v("class Other{//外部其他类")])]),v._v(" "),_("p",[_("code",[v._v("}")])])]),v._v(" "),_("li",[_("p",[v._v("内部类的分类")]),v._v(" "),_("ul",[_("li",[v._v("定义在外部类的局部位置上（比如方法内）：\n"),_("ol",[_("li",[v._v("局部内部类（有类名）")]),v._v(" "),_("li",[v._v("匿名内部类（没有类名，重点）")])])]),v._v(" "),_("li",[v._v("定义在外部类的成员位置上：\n"),_("ol",[_("li",[v._v("成员内部类（没用static修饰）")]),v._v(" "),_("li",[v._v("静态内部类（使用static修饰）")])])])])]),v._v(" "),_("li",[_("p",[v._v("局部内部类的使用")]),v._v(" "),_("p",[v._v("说明：局部内部类是定义在外部类的局部位置，比如方法中，并且有类名")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("可以直接访问外部类的所有成员、包含私有的")])]),v._v(" "),_("li",[_("p",[v._v("不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但是可以使用final修饰，因为局部变量也可以使用final")])]),v._v(" "),_("li",[_("p",[v._v("作用域：仅仅在定义它的方法或代码块中")])]),v._v(" "),_("li",[_("p",[v._v("局部内部类---访问----\x3e外部类的成员【访问方式：直接访问】")])]),v._v(" "),_("li",[_("p",[v._v("外部类---访问----\x3e局部内部类的成员")]),v._v(" "),_("p",[v._v("访问方式：创建对象，再访问（注意：必须在作用域内）")])]),v._v(" "),_("li",[_("p",[v._v("外部其他类---不能访问----\x3e局部内部类（因为局部内部类地位是一个局部变量）")])]),v._v(" "),_("li",[_("p",[v._v("如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问")])])])]),v._v(" "),_("li",[_("p",[v._v("匿名内部类的使用")]),v._v(" "),_("p",[v._v("(1)本质是类(2)内部类(3)该类没有名字(4)同时还是一个对象")]),v._v(" "),_("p",[v._v("说明：匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("匿名内部类的基本语法")]),v._v(" "),_("p",[_("code",[v._v("new 类或接口(参数列表){")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("类体")])]),v._v(" "),_("p",[_("code",[v._v("};")])])]),v._v(" "),_("li",[_("p",[v._v("匿名内部类的语法比较奇特，请大家注意，因为匿名内部类既是一个类的定义，同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征，对前面代码分析可以看出这个特点，因此可以调用匿名内部类方法")])]),v._v(" "),_("li",[_("p",[v._v("可以直接访问外部类的所有成员，包含私有的")])]),v._v(" "),_("li",[_("p",[v._v("不能添加访问修饰符，因为它的地位就是一个局部变量")])]),v._v(" "),_("li",[_("p",[v._v("作用域：仅仅在定义它的方法或代码块中")])]),v._v(" "),_("li",[_("p",[v._v("匿名内部类---访问----\x3e外部类成员【访问方式：直接访问】")])]),v._v(" "),_("li",[_("p",[v._v("外部其他类---不能访问----\x3e匿名内部类（因为匿名内部类地位是一个局部变量）")])]),v._v(" "),_("li",[_("p",[v._v("如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问")])])])]),v._v(" "),_("li",[_("p",[v._v("成员内部类的使用")]),v._v(" "),_("p",[v._v("说明：成员内部类是定义在外部类的成员位置，并且没有static修饰")]),v._v(" "),_("ol",[_("li",[v._v("可以直接访问外部类的所有成员，包含私有的")]),v._v(" "),_("li",[v._v("可以添加任意访问修饰符（public、protected、默认、private），因为它的地位就是一个成员")]),v._v(" "),_("li",[v._v("作用域：和外部类的其他成员一样，为整个类体比如前面案例，在外部类的成员方法中创建成员内部类对象，再调用方法")]),v._v(" "),_("li",[v._v("成员内部类---访问----\x3e外部类（比如：属性）【访问方式：直接访问】")]),v._v(" "),_("li",[v._v("外部类---访问----\x3e内部类（说明）访问方式：创建对象，再访问")]),v._v(" "),_("li",[v._v("外部其他类---访问---\x3e成员内部类")]),v._v(" "),_("li",[v._v("如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问")])])]),v._v(" "),_("li",[_("p",[v._v("静态内部类的使用")]),v._v(" "),_("p",[v._v("说明：静态内部类是定义在外部类的成员位置，并且有static修饰")]),v._v(" "),_("ol",[_("li",[v._v("可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员")]),v._v(" "),_("li",[v._v("可以添加任意访问修饰符（public、protected、默认、private），因为它的地位就是一个成员")]),v._v(" "),_("li",[v._v("作用域：同其他的成员，为整个类体")]),v._v(" "),_("li",[v._v("静态内部类---访问----\x3e外部类（比如：静态属性）【访问方式：直接访问所有静态成员】")]),v._v(" "),_("li",[v._v("外部类---访问----\x3e静态内部类 访问方式：创建对象，再访问")]),v._v(" "),_("li",[v._v("外部其他类---访问----\x3e静态内部类")]),v._v(" "),_("li",[v._v("如果外部类和静态内部类的成员重名时，静态内部类访问的时候，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.成员）去访问")])])])]),v._v(" "),_("h3",{attrs:{id:"枚举和注解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#枚举和注解"}},[v._v("#")]),v._v(" 枚举和注解")]),v._v(" "),_("h4",{attrs:{id:"枚举介绍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#枚举介绍"}},[v._v("#")]),v._v(" 枚举介绍")]),v._v(" "),_("p",[v._v("枚举是一组常量的集合")]),v._v(" "),_("ul",[_("li",[v._v("枚举的二种实现方式\n"),_("ol",[_("li",[v._v("自定义实现枚举")]),v._v(" "),_("li",[v._v("使用enum关键字实现枚举")])])])]),v._v(" "),_("h4",{attrs:{id:"自定义类实现枚举"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#自定义类实现枚举"}},[v._v("#")]),v._v(" 自定义类实现枚举")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("实现")]),v._v(" "),_("ol",[_("li",[v._v("不需要提供setXxx方法，因为枚举对象通常为只读")]),v._v(" "),_("li",[v._v("对枚举对象/属性使用final + static共同修饰，实现底层优化")]),v._v(" "),_("li",[v._v("枚举对象名通常使用全部大写，常量的命名规范")]),v._v(" "),_("li",[v._v("枚举对象根据需要，也可以有多个属性")])])]),v._v(" "),_("li",[_("p",[v._v("自定义类实现枚举特点")]),v._v(" "),_("ol",[_("li",[v._v("构造器私有化")]),v._v(" "),_("li",[v._v("本类内部创建一组对象")]),v._v(" "),_("li",[v._v("对外暴露对象（通过为对象添加public final static 修饰符）")]),v._v(" "),_("li",[v._v("可以提供get方法，但是不要提供set")])])])]),v._v(" "),_("h4",{attrs:{id:"enum关键字实现枚举"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#enum关键字实现枚举"}},[v._v("#")]),v._v(" enum关键字实现枚举")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("enum关键字实现枚举注意事项")]),v._v(" "),_("ol",[_("li",[v._v("当我们使用enum关键字开发一个枚举类时，默认会继承Enum类，而且是一个final类")]),v._v(" "),_("li",[v._v('传统的public static final Season2 SPRING = new Season2("春天","温暖"); 简化成SPRING("春天","温暖")，这里必须知道，它调用的是哪个构造器')]),v._v(" "),_("li",[v._v("如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略")]),v._v(" "),_("li",[v._v('当有多个枚举对象时，使用","间隔，最后有一个分号结尾')]),v._v(" "),_("li",[v._v("枚举对象必须放在枚举类的行首")])])]),v._v(" "),_("li",[_("p",[v._v("enum常用方法说明")]),v._v(" "),_("p",[v._v("说明：使用关键字enum时，会隐式继承Enum类，这样我们就可以使用Enum类相关的方法")]),v._v(" "),_("p",[_("code",[v._v("public abstract class Enum<E extends Enum<E>> implements Comparable<E>,Serializable{}")])]),v._v(" "),_("ol",[_("li",[v._v("toString：Enum类已经重写过了，返回的是当前对象名，子类可以重写该方法，用于返回对象的属性信息")]),v._v(" "),_("li",[v._v("name：返回当前对象名（常量名），子类中不能重写")]),v._v(" "),_("li",[v._v("ordinal：返回当前对象的位置号，默认从0开始")]),v._v(" "),_("li",[v._v("values：返回当前枚举类中所有的常量")]),v._v(" "),_("li",[v._v("valueOf：将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常！")]),v._v(" "),_("li",[v._v("compareTo：比较两个枚举常量，比较的就是位置号！")])])]),v._v(" "),_("li",[_("p",[v._v("enum实现接口")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("使用enum关键字后，就不能再继承其它类了，因为enum会隐式继承Enum，而Java是单继承机制")])]),v._v(" "),_("li",[_("p",[v._v("枚举类和普通类一样，可以实现接口，如下形式")]),v._v(" "),_("p",[_("code",[v._v("enum 类名 implements 接口1,接口2{}")])])])])])]),v._v(" "),_("h4",{attrs:{id:"jdk内置的基本注解类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jdk内置的基本注解类型"}},[v._v("#")]),v._v(" JDK内置的基本注解类型")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("注解的理解")]),v._v(" "),_("ol",[_("li",[v._v("注解（Annotation）也称为元数据（Metadata），用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息")]),v._v(" "),_("li",[v._v("和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息")]),v._v(" "),_("li",[v._v("在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替java EE旧版中所遗留的繁冗代码和XML配置等。")])])]),v._v(" "),_("li",[_("p",[v._v("基本的Annotation介绍")]),v._v(" "),_("p",[v._v("使用Annotation时要在其前面增加@符号，并把该Annotation当成一个修饰符使用。用于修饰它支持的程序元素")]),v._v(" "),_("p",[v._v("三个基本的Annotation：")]),v._v(" "),_("ol",[_("li",[v._v("@Override：限定某个方法，是重写父类方法，该注解只能用于方法")]),v._v(" "),_("li",[v._v("@Deprecated：用于表示某个程度元素（类，方法等）已过时")]),v._v(" "),_("li",[v._v("@SuppressWarnings：抑制编译器警告")])]),v._v(" "),_("p",[v._v("补充说明：")]),v._v(" "),_("p",[v._v("@interface：不是interface，是注解类，是jdk5.0之后加入的")])]),v._v(" "),_("li",[_("p",[v._v("Override使用说明")]),v._v(" "),_("ol",[_("li",[v._v("@Override表示指定重写父类的方法（从编译层面验证），如果父类没有fly方法，则会报错")]),v._v(" "),_("li",[v._v("如果不写@Override注解 ，而父类仍有public void fly(){}，仍然构成重写")]),v._v(" "),_("li",[v._v("@Override只能修饰方法，不能修饰其它类、包、属性等等")]),v._v(" "),_("li",[v._v("查看@Override注解源码为@Target(ElementType.METHOD)，说明只能修饰方法")]),v._v(" "),_("li",[v._v("@Target是修饰注解的注解，称为元注解")])])]),v._v(" "),_("li",[_("p",[v._v("@Deprecated的说明")]),v._v(" "),_("ol",[_("li",[v._v("用于表示某个程序元素（类，方法等）已过时")]),v._v(" "),_("li",[v._v("可以修饰方法、类、字段、包、参数等等")]),v._v(" "),_("li",[v._v("@Target(value={CONSTRUCTOR,FIELD,LOCAL_VARIABLE,METHOD,PACKAGE,PARAMETER,TYPE})")]),v._v(" "),_("li",[v._v("@Deprecated的作用可以做到新旧版本的兼容和过渡")])])]),v._v(" "),_("li",[_("p",[v._v("@SuppressWarnings说明")]),v._v(" "),_("ol",[_("li",[v._v("unchecked：是忽略没有检查的警告")]),v._v(" "),_("li",[v._v("rawtypes：是忽略没有指定泛型的警告（传参时没有指定泛型的警告错误）")]),v._v(" "),_("li",[v._v("unused：是忽略没有使用某个变量的警告错误")]),v._v(" "),_("li",[v._v("@SuppressWarnings：可以修饰的程序元素为，查看@Target")]),v._v(" "),_("li",[v._v("生成@SuppressWarnings时，不用背，直接点击左侧的黄色提示，就可以选择（注意可以指定生成的位置）")])])])]),v._v(" "),_("h4",{attrs:{id:"元注解-对注解进行注解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#元注解-对注解进行注解"}},[v._v("#")]),v._v(" 元注解：对注解进行注解")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("元注解的基本介绍")]),v._v(" "),_("p",[v._v("JDK的元Annotation用于修饰其他Annotation")])]),v._v(" "),_("li",[_("p",[v._v("元注解的种类（使用不多，了解，不用深入研究）")]),v._v(" "),_("ol",[_("li",[v._v("Retention：指定注解的作用范围，三种SOURCE，CLASS，RUNTIME")]),v._v(" "),_("li",[v._v("Target：指定注解可以在哪些地方使用")]),v._v(" "),_("li",[v._v("Documented：指定该注解是否会在javadoc体现")]),v._v(" "),_("li",[v._v("Inherited：子类会继承父类注解")])])]),v._v(" "),_("li",[_("p",[v._v("@Retention注解")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("说明")]),v._v(" "),_("p",[v._v("只能用于修饰一个Annotation定义，用于指定该Annotation可以保留多长时间，@Retention包含一个RetentionPolicy类型的成员变量，使用@Rentention时必须为该value成员变量指定值")])]),v._v(" "),_("li",[_("p",[v._v("@Retention的三种值")]),v._v(" "),_("ol",[_("li",[v._v("RetentionPolicy.SOURCE：编译器使用后，直接丢弃这种策略的注释")]),v._v(" "),_("li",[v._v("RetentionPolicy.CLASS：编译器将把注释记录在class文件中，当运行Java程序时，JVM不会保留注释，这是默认值")]),v._v(" "),_("li",[v._v("RetentionPolicy.RUNTIME：编译器将把注释记录在class文件中，当运行Java程序时，JVM会保留注释，程序可以通过反射获取该注释")])])]),v._v(" "),_("li",[_("p",[v._v("@Override说明：Override的作用域在SOURCE，当编译器编译 时生效，不会写入到.class文件，也不会再runtime（运行时）生效")])]),v._v(" "),_("li",[_("p",[v._v("@Target说明：用于修饰Annotation定义，用于指定被修饰的Annotation能用于修饰哪些程序元素。@Target也包含一个名为value的成员变量")])])])]),v._v(" "),_("li",[_("p",[v._v("@Inherited注解")]),v._v(" "),_("p",[v._v("被它修饰的Annotation将具有继承性，如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解")]),v._v(" "),_("p",[v._v("说明：实际应用中，使用较少，了解即可")])])]),v._v(" "),_("h3",{attrs:{id:"异常-exception"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#异常-exception"}},[v._v("#")]),v._v(" 异常-Exception")]),v._v(" "),_("h4",{attrs:{id:"异常的概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#异常的概念"}},[v._v("#")]),v._v(" 异常的概念")]),v._v(" "),_("ul",[_("li",[v._v("基本概念：Java语言中，将程序执行中发生的不正常情况称为“异常”。（开发过程中的语法错误和逻辑错误不是异常）")]),v._v(" "),_("li",[v._v("执行过程中所发生的异常事件可分为两类\n"),_("ol",[_("li",[v._v("Error（错误）：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError【栈溢出】和OOM（out of memory），Error是严重错误，程序会崩溃")]),v._v(" "),_("li",[v._v("Exception：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等等，Exception分为两大类：运行时异常【程序运行时，发生的异常】和编译时异常【编程时，编译器检查出的异常】")])])])]),v._v(" "),_("h4",{attrs:{id:"异常体系图"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#异常体系图"}},[v._v("#")]),v._v(" 异常体系图")]),v._v(" "),_("ul",[_("li",[v._v("小结\n"),_("ol",[_("li",[v._v("异常分为两大类，运行时异常和编译时异常")]),v._v(" "),_("li",[v._v("运行时异常，编译器不要求强制处置的异常。编译器检查不出来，一般是指编程时的逻辑错误，是程序员应该避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常")]),v._v(" "),_("li",[v._v("对于运行时异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响")]),v._v(" "),_("li",[v._v("编译时异常，是编译器要求必须处置的异常。")])])])]),v._v(" "),_("h4",{attrs:{id:"常见的异常"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见的异常"}},[v._v("#")]),v._v(" 常见的异常")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("常见的运行时异常包括")]),v._v(" "),_("ol",[_("li",[v._v("NullPointerException空指针异常：当应用程序试图在需要对象的地方使用null时，抛出该异常")]),v._v(" "),_("li",[v._v("ArithmeticException数学运算异常：当出现异常的运算条件时，抛出此异常")]),v._v(" "),_("li",[v._v("ArrayIndexOutOfBoundsException数组下标越界异常：用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引")]),v._v(" "),_("li",[v._v("ClassCastException类型转换异常：当试图将对象强制转换为不是实例的子类时，抛出该异常")]),v._v(" "),_("li",[v._v("NumberFormatException数字格式不正确异常[]：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式，抛出该异常 = 》使用异常我们可以确保输入是满足条件数字")])])]),v._v(" "),_("li",[_("p",[v._v("编译异常")]),v._v(" "),_("p",[v._v("介绍：编译异常是指在编译期间，就必须处理的异常，否则代码不能通过编译")]),v._v(" "),_("p",[v._v("常见的编译异常")]),v._v(" "),_("ul",[_("li",[v._v("SQLException // 操作数据库时，查询表可能发生异常")]),v._v(" "),_("li",[v._v("IOException // 操作文件时，发生的异常")]),v._v(" "),_("li",[v._v("FileNotFoundException // 当操作一个不存在的文件时，发生异常")]),v._v(" "),_("li",[v._v("ClassNotFoundException // 加载类，而该类不存在时，异常")]),v._v(" "),_("li",[v._v("EOFException // 操作文件，到文件末尾，发生异常")]),v._v(" "),_("li",[v._v("IllegalArguementException // 参数异常")])])])]),v._v(" "),_("h4",{attrs:{id:"异常处理概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#异常处理概念"}},[v._v("#")]),v._v(" 异常处理概念")]),v._v(" "),_("ul",[_("li",[v._v("基本介绍：异常处理就是当异常发生时，对异常处理的方式")]),v._v(" "),_("li",[v._v("异常处理的方式\n"),_("ol",[_("li",[v._v("try-catch-finally：程序员在代码中捕获发生的异常，自行处理")]),v._v(" "),_("li",[v._v("throws：将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是JVM")])])])]),v._v(" "),_("h4",{attrs:{id:"异常处理分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#异常处理分类"}},[v._v("#")]),v._v(" 异常处理分类")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("try-catch异常处理")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("try-catch方式处理异常说明")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("Java提供try和catch块来处理异常。try块用于包含可能出错的代码。catch块用于处理try块中发生的异常。可以根据需要在程序中有多个数量的try...catch块")])]),v._v(" "),_("li",[_("p",[v._v("基本语法")]),v._v(" "),_("p",[_("code",[v._v("try{")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("// 可疑代码")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("// 将异常生成对应的异常对象，传递给catch块")])]),v._v(" "),_("p",[_("code",[v._v("}catch(异常){")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("// 对异常的处理")])]),v._v(" "),_("p",[_("code",[v._v("}")])])])])]),v._v(" "),_("li",[_("p",[v._v("try-catch方式处理异常-注意事项")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("如果异常发生了，则异常发生后面的代码不会执行，直接进入到catch块")])]),v._v(" "),_("li",[_("p",[v._v("如果异常没有发生，则顺序执行try的代码块，不会进入到catch")])]),v._v(" "),_("li",[_("p",[v._v("如果希望不管是否发生异常，都执行某段代码（比如关闭连接，释放资源等）则使用如下代码-finally{}")]),v._v(" "),_("p",[_("code",[v._v("try{")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("// 可疑代码")])]),v._v(" "),_("p",[_("code",[v._v("}catch(异常){")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("// ...")])]),v._v(" "),_("p",[_("code",[v._v("}finally{")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("// 释放资源等")])]),v._v(" "),_("p",[_("code",[v._v("}")])])]),v._v(" "),_("li",[_("p",[v._v("可以有多个catch语句，捕获不同的异常（进行不同的业务处理），要求父类异常在后，子类异常在前，比如（Exception在后，NullPointerException在前），如果发生异常，只会匹配一个catch")]),v._v(" "),_("p",[_("code",[v._v("try{")])]),v._v(" "),_("p",[_("code",[v._v("}catch(NullPointerException e){")])]),v._v(" "),_("p",[_("code",[v._v("}catch(Exception e){")])]),v._v(" "),_("p",[_("code",[v._v("}finally{")])]),v._v(" "),_("p",[_("code",[v._v("}")])])]),v._v(" "),_("li",[_("p",[v._v("可以进行try-finally配合使用，这种用法相当于没有捕获异常，因此程序会直接崩掉/退出 。应用场景，就是执行一段代码，不管是否发生异常，都必须执行某个业务逻辑")]),v._v(" "),_("p",[_("code",[v._v("try{")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("//代码...")])]),v._v(" "),_("p",[_("code",[v._v("}finally{")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("//总是执行")])]),v._v(" "),_("p",[_("code",[v._v("}")])])])])]),v._v(" "),_("li",[_("p",[v._v("try-catch-finally执行顺序小结")]),v._v(" "),_("ol",[_("li",[v._v("如果没有出现异常，则执行try块中所有语句，不执行catch块中语句，如果有finally，最后还需要执行finally里面的语句")]),v._v(" "),_("li",[v._v("如果出现异常，则try块中异常发生后，try块剩下的语句不再执行。将执行catch块中的语句，如果有finally，最后还需要执行finally里面的语句")])])])])]),v._v(" "),_("li",[_("p",[v._v("throws异常处理")]),v._v(" "),_("ul",[_("li",[v._v("基本介绍\n"),_("ol",[_("li",[v._v("如果一个方法（中的语句执行时）可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理")]),v._v(" "),_("li",[v._v("在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类")])])]),v._v(" "),_("li",[v._v("注意事项和使用细节\n"),_("ol",[_("li",[v._v("对于编译异常，程序中必须处理，比如try-catch或者throws")]),v._v(" "),_("li",[v._v("对于运行时异常，程序中如果没有处理，默认就是throws的方式处理")]),v._v(" "),_("li",[v._v("子类重写父类的方法时，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常的类型的子类型")]),v._v(" "),_("li",[v._v("在throws过程中，如果有方法try-catch，就相当于处理异常，就可以不必throws")])])])])])]),v._v(" "),_("h4",{attrs:{id:"自定义异常"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#自定义异常"}},[v._v("#")]),v._v(" 自定义异常")]),v._v(" "),_("ul",[_("li",[v._v("基本概念：当程序中出现了某些“错误”，但该错误信息并没有在Throwable子类中描述处理，这个时候可以自己设计异常类，用于描述该错误信息")]),v._v(" "),_("li",[v._v("自定义异常的步骤\n"),_("ol",[_("li",[v._v("定义类：自定义异常类名继承Exception或RuntimeException")]),v._v(" "),_("li",[v._v("如果继承Exception，属于编译异常")]),v._v(" "),_("li",[v._v("如果继承RuntimeException，属于运行异常（一般来说，继承RuntimeException）")])])])]),v._v(" "),_("h4",{attrs:{id:"throw和throws的对比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#throw和throws的对比"}},[v._v("#")]),v._v(" throw和throws的对比")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th"),v._v(" "),_("th",[v._v("意义")]),v._v(" "),_("th",[v._v("位置")]),v._v(" "),_("th",[v._v("后面跟的东西")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("throws")]),v._v(" "),_("td",[v._v("异常处理的一种方式")]),v._v(" "),_("td",[v._v("方法声明处")]),v._v(" "),_("td",[v._v("异常类型")])]),v._v(" "),_("tr",[_("td",[v._v("throw")]),v._v(" "),_("td",[v._v("手动生成异常对象的关键字")]),v._v(" "),_("td",[v._v("方法体中")]),v._v(" "),_("td",[v._v("异常对象")])])])]),v._v(" "),_("h3",{attrs:{id:"常用类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常用类"}},[v._v("#")]),v._v(" 常用类")]),v._v(" "),_("h4",{attrs:{id:"包装类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#包装类"}},[v._v("#")]),v._v(" 包装类")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("包装类的分类")]),v._v(" "),_("ol",[_("li",[v._v("针对八种基本数据类型相应的引用类型—包装类")]),v._v(" "),_("li",[v._v("有了类的特点，就可以调用类中的方法")])]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"center"}},[v._v("基本数据类型")]),v._v(" "),_("th",{staticStyle:{"text-align":"center"}},[v._v("包装类")])])]),v._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"center"}},[v._v("boolean")]),v._v(" "),_("td",{staticStyle:{"text-align":"center"}},[v._v("Boolean")])]),v._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[v._v("char")]),v._v(" "),_("td",{staticStyle:{"text-align":"center"}},[v._v("Character")])]),v._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[v._v("byte")]),v._v(" "),_("td",{staticStyle:{"text-align":"center"}},[v._v("Byte")])]),v._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[v._v("short")]),v._v(" "),_("td",{staticStyle:{"text-align":"center"}},[v._v("Short")])]),v._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[v._v("int")]),v._v(" "),_("td",{staticStyle:{"text-align":"center"}},[v._v("Integer")])]),v._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[v._v("long")]),v._v(" "),_("td",{staticStyle:{"text-align":"center"}},[v._v("Long")])]),v._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[v._v("float")]),v._v(" "),_("td",{staticStyle:{"text-align":"center"}},[v._v("Float")])]),v._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[v._v("double")]),v._v(" "),_("td",{staticStyle:{"text-align":"center"}},[v._v("Double")])])])]),v._v(" "),_("p",[v._v("父类：Number——Byte、Short、Integer、Long、Float、Double")])]),v._v(" "),_("li",[_("p",[v._v("包装类和基本数据的转换")]),v._v(" "),_("ol",[_("li",[v._v("Jdk5前的手动装箱和拆箱方式，装箱：基本类型->包装类型，反之，拆箱")]),v._v(" "),_("li",[v._v("jdk5之后（含jdk5）的自动装箱和拆箱方式")]),v._v(" "),_("li",[v._v("自动装箱底层调用的是valueOf方法，比如Integer.valueOf()")])]),v._v(" "),_("p",[_("code",[v._v("// 基本类型---\x3e包装类型【手动装箱】")])]),v._v(" "),_("p",[_("code",[v._v("int i = 10;")])]),v._v(" "),_("p",[_("code",[v._v("Integer i1 = new Integer(i);")])]),v._v(" "),_("p",[_("code",[v._v("Integer i2 = Integer.valueOf(i);")])]),v._v(" "),_("p",[_("code",[v._v("// 包装类型---\x3e基本类型【手动拆箱】")])]),v._v(" "),_("p",[_("code",[v._v("Integer j = new Integer(99);")])]),v._v(" "),_("p",[_("code",[v._v("int j1 = j.intValue();")])])]),v._v(" "),_("li",[_("p",[v._v("包装类和String类型的相互转换")]),v._v(" "),_("p",[_("code",[v._v("// 包装类---\x3eString")])]),v._v(" "),_("p",[_("code",[v._v("// 方式1")])]),v._v(" "),_("p",[_("code",[v._v('String str1 = i + "";')])]),v._v(" "),_("p",[_("code",[v._v("// 方式2")])]),v._v(" "),_("p",[_("code",[v._v("String str2 = i.toString();")])]),v._v(" "),_("p",[_("code",[v._v("// 方法3")])]),v._v(" "),_("p",[_("code",[v._v("String str3 = String.valueOf(i);")])]),v._v(" "),_("p",[_("code",[v._v("// String ---\x3e包装类")])]),v._v(" "),_("p",[_("code",[v._v("// 使用自动装箱")])]),v._v(" "),_("p",[_("code",[v._v("Integer i2 = Integer.parseInt(str);")])]),v._v(" "),_("p",[_("code",[v._v("// 构造器")])]),v._v(" "),_("p",[_("code",[v._v("Integer i3 = new Integer(str);")])])]),v._v(" "),_("li",[_("p",[v._v("Integer类和Character类的常用方法")]),v._v(" "),_("ul",[_("li",[v._v("Integer.MIN_VALUE：返回最小值")]),v._v(" "),_("li",[v._v("Integer.MAX_VALUE：返回最大值")]),v._v(" "),_("li",[v._v("Character.isDigit('a')：判断是不是数字")]),v._v(" "),_("li",[v._v("Character.isLetter('a')：判断是不是字母")]),v._v(" "),_("li",[v._v("Character.isUpperCase('a')：判断是不是大写")]),v._v(" "),_("li",[v._v("Character.isLowerCase('a')：判断是不是小写")]),v._v(" "),_("li",[v._v("Character.isWhitespace('a')：判断是不是空格")]),v._v(" "),_("li",[v._v("Character.toUpperCase('a')：转成大写")]),v._v(" "),_("li",[v._v("Character.toLowerCase('A')：转成小写")])])])]),v._v(" "),_("h4",{attrs:{id:"string类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#string类"}},[v._v("#")]),v._v(" String类")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("String类的理解和创建对象")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("String对象用于保存字符串，也就是一组字符序列")])]),v._v(" "),_("li",[_("p",[v._v("字符串常量对象是用双引号括起的字符序列")])]),v._v(" "),_("li",[_("p",[v._v("字符串的字符使用Unicode字符编码，一个字符（不区分字母还是汉字）占两个字节")])]),v._v(" "),_("li",[_("p",[v._v("String类比较常用构造方法")]),v._v(" "),_("ul",[_("li",[v._v("String s1 = new String();")]),v._v(" "),_("li",[v._v("String s2 = new String(String original);")]),v._v(" "),_("li",[v._v("String s3 = new String(char[] a);")]),v._v(" "),_("li",[v._v("String s4 = new String(char[] a, int startIndex, int count)")])])]),v._v(" "),_("li",[_("p",[v._v("注意：String实现了Serializable，说明String可以串行化（数据可以在网络传输）；String实现了Comparable接口，说明String对象可以比较")])]),v._v(" "),_("li",[_("p",[v._v("String是final类，不能被其他的类继承")])]),v._v(" "),_("li",[_("p",[v._v("String有属性private final char value[];用于存放字符串内容")])]),v._v(" "),_("li",[_("p",[v._v("一定要注意：value是一个final类型，（value指向的地址）不可修改：即value不能指向新的地址，但是单个字符内容是可以变化")])])])]),v._v(" "),_("li",[_("p",[v._v("创建String对象的两种方式")]),v._v(" "),_("ol",[_("li",[v._v('方式一：直接赋值 String s = "hspedu";')]),v._v(" "),_("li",[v._v('方式二：调用构造器 String s = new String("hspedu");')])])]),v._v(" "),_("li",[_("p",[v._v("两种创建String对象的区别")]),v._v(" "),_("p",[v._v('方式一：直接赋值 String s = "hsp";')]),v._v(" "),_("p",[v._v('方式二：调用构造器 String s2 = new String("hsp");')]),v._v(" "),_("ol",[_("li",[v._v('方式一：先从常量池查看是否有"hsp"数据空间，如果有，直接指向；如果没有则重新创建，然后指向。s最终指向的是常量池的空间地址')]),v._v(" "),_("li",[v._v('方式二：先在堆中创建空间，里面维护了value属性，指向常量池的hsp空间。如果常量池没有"hsp"，重新创建，如果有，直接通过value指向。最终指向的是堆中的空间地址')])])]),v._v(" "),_("li",[_("p",[v._v("字符串的特性")]),v._v(" "),_("ol",[_("li",[v._v("String是一个final类，代表不可变的字符序列")]),v._v(" "),_("li",[v._v("字符串是不可变的。一个字符串对象一旦被分配，其内容 是不可变的")]),v._v(" "),_("li",[v._v("编译器会做一个优化，判断创建的常量池对象，是否有引用指向"),_("code",[v._v('String a = "hello" + "abc"; =》 String a = "Helloabc";')])]),v._v(" "),_("li",[v._v('重要规则，String c1 = "ab" + "cd"；常量相加，看的是池。String c1 = a + b；变量相加，是在堆中')])])]),v._v(" "),_("li",[_("p",[v._v("String类的常用方法：String类是保存字符串常量的。每次更新都需要重新开辟空间，效率较低，因此java设计者还提供了StringBuilder和StringBuffer来增强String的功能，并提高效率")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("equals：区分大小写，判断内容是否相等")])]),v._v(" "),_("li",[_("p",[v._v("equalsIgnoreCase：忽略大小写的判断内容是否相等")])]),v._v(" "),_("li",[_("p",[v._v("length：获取字符的个数，字符串的长度")])]),v._v(" "),_("li",[_("p",[v._v("indexOf：获取字符在字符串中第1次出现的索引，索引从0开始，如果找不到，返回-1")])]),v._v(" "),_("li",[_("p",[v._v("lastIndexOf：获取字符在字符串中最后1次出现的索引，索引从0开始，如找不到，返回-1")])]),v._v(" "),_("li",[_("p",[v._v("substring：截取指定范围的子串")])]),v._v(" "),_("li",[_("p",[v._v("trim：去前后空格")])]),v._v(" "),_("li",[_("p",[v._v("charAt：获取某索引处的字符，注意不能使用Str[index]这种方式")])]),v._v(" "),_("li",[_("p",[v._v("toUpperCase")])]),v._v(" "),_("li",[_("p",[v._v("toLowerCase")])]),v._v(" "),_("li",[_("p",[v._v("concat：拼接字符串")])]),v._v(" "),_("li",[_("p",[v._v("replace：替换字符串中的字符")])]),v._v(" "),_("li",[_("p",[v._v("split：分割字符串，对于某些分割字符，我们需要转义比如|\\\\等")])]),v._v(" "),_("li",[_("p",[v._v("compare：比较两个字符串的大小")])]),v._v(" "),_("li",[_("p",[v._v("toCharArray：转换成字符数组")])]),v._v(" "),_("li",[_("p",[v._v("format：格式字符串，%s字符串 %c字符串 %d整型 %.2f浮点型")])])])])]),v._v(" "),_("h4",{attrs:{id:"stringbuffer和stringbuilder类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#stringbuffer和stringbuilder类"}},[v._v("#")]),v._v(" StringBuffer和StringBuilder类")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("StringBuffer类基本介绍")]),v._v(" "),_("ul",[_("li",[v._v("java.lang.StringBuffer代表可变的字符序列，可以对字符串内容进行增删")]),v._v(" "),_("li",[v._v("很多方法与String相同，但StringBuffer是可变长度的")]),v._v(" "),_("li",[v._v("StringBuffer是一个容器")]),v._v(" "),_("li",[v._v("其他：\n"),_("ol",[_("li",[v._v("StringBuffer的直接父类是AbstractStringBuilder")]),v._v(" "),_("li",[v._v("StringBuffer实现了Serializable，即StringBuffer的对象可以串行化")]),v._v(" "),_("li",[v._v("在父类中，AbstractStringBuilder有属性char[] value，不是final，该value数组存放字符串内容，引出存放在堆中的")]),v._v(" "),_("li",[v._v("StringBuffer是一个final类，不能被继承")]),v._v(" "),_("li",[v._v("因为StringBuffer字符内容是存在char[] value，所有在变化（增加/删除）不用每次都更换地址（即创建新对象），所以效率高于String")])])])])]),v._v(" "),_("li",[_("p",[v._v("String VS StringBuffer")]),v._v(" "),_("ol",[_("li",[v._v("String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址，效率较低"),_("code",[v._v("// private final char value[];")])]),v._v(" "),_("li",[v._v("StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用每次更新地址，效率较高"),_("code",[v._v("// char[] value; // 这个放在堆")])])])]),v._v(" "),_("li",[_("p",[v._v("StringBuffer的构造器")]),v._v(" "),_("ul",[_("li",[v._v("StringBuffer()：构造一个其中不带字符的字符串缓冲区，其初始容量为16个字符")]),v._v(" "),_("li",[v._v("StringBuffer(CharSequence seq)：public java.lang.StringBuilder(CharSequence seq)构造一个字符串缓冲区，它包含与指定的CharSequence相同的字符")]),v._v(" "),_("li",[v._v("StringBuffer(int capacity)  // capacity[容量]：构造一个不带字符，但具有指定初始容量的字符串缓冲区。即对char[]大小进行指定")]),v._v(" "),_("li",[v._v("StringBuffer(String str)：构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容，char[] 大小就是str.length() + 16")])])]),v._v(" "),_("li",[_("p",[v._v("String和StringBuffer相互转换")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("String--\x3eStringBuffer")]),v._v(" "),_("p",[_("code",[v._v('String s = "hello";')])]),v._v(" "),_("p",[_("code",[v._v("// 方式1 - 对str本身没有影响")])]),v._v(" "),_("p",[_("code",[v._v("StringBuffer b1 = new StringBuffer(s);")])]),v._v(" "),_("p",[_("code",[v._v("// 方式2")])]),v._v(" "),_("p",[_("code",[v._v("StringBuffer b2 = new StringBuffer();")])]),v._v(" "),_("p",[_("code",[v._v("b2.append(s);")])])]),v._v(" "),_("li",[_("p",[v._v("StringBuffer--\x3eString")]),v._v(" "),_("p",[_("code",[v._v("// 方式1")])]),v._v(" "),_("p",[_("code",[v._v("String s2 = b1.toString(); // b1[StringBuffer]")])]),v._v(" "),_("p",[_("code",[v._v("// 方式2")])]),v._v(" "),_("p",[_("code",[v._v("String s3 = new String(b1);")])])])])]),v._v(" "),_("li",[_("p",[v._v("StringBuffer类常见方法")]),v._v(" "),_("ol",[_("li",[v._v("增 append")]),v._v(" "),_("li",[v._v("删 delete(start,end)：删除索引大于等于start&&小于end处的字符")]),v._v(" "),_("li",[v._v("改 replace(start,end,string) //将start---end间的内容替换掉，不含end")]),v._v(" "),_("li",[v._v("查 indexOf //查找子串在字符串第1次出现的索引，如果找不到返回-1")]),v._v(" "),_("li",[v._v("插 insert")]),v._v(" "),_("li",[v._v("获取长度 length")])])]),v._v(" "),_("li",[_("p",[v._v("StringBuilder类基本介绍")]),v._v(" "),_("ol",[_("li",[v._v("一个可变的字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步（StringBuilder不是线程安全的）。该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer要快")]),v._v(" "),_("li",[v._v("在StringBuilder上的主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据。")])])]),v._v(" "),_("li",[_("p",[v._v("StringBuilder常用方法")]),v._v(" "),_("p",[v._v("StringBuilder和StringBuffer均代表可变的字符序列，方法是一样的，所以使用和StringBuffer一样")]),v._v(" "),_("ol",[_("li",[v._v("StringBuilder是final类，不能被继承")]),v._v(" "),_("li",[v._v("继承了AbstractStringBuilder，属性char[] value，内容（对象字符序列）存到value，字符序列是堆中")]),v._v(" "),_("li",[v._v("实现了Serializable接口，序列化（所谓序列化即可以保存类型和数据本身），可以串行化（对象可以网络传输，还可以保存到文件）")]),v._v(" "),_("li",[v._v("StringBuilder的方法，没有做互斥处理，即没有synchronized关键字，因此在单线程的情况下使用StringBuilder")])])]),v._v(" "),_("li",[_("p",[v._v("String、StringBuffer和StringBuilder的比较")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且方法也一样")])]),v._v(" "),_("li",[_("p",[v._v("String：不可变字符序列，效率低，但是复用率高")])]),v._v(" "),_("li",[_("p",[v._v("StringBuffer：可变字符序列、效率较高（增删）、线程安全")])]),v._v(" "),_("li",[_("p",[v._v("StringBuilder：可变字符序列、效率最高、线程不安全")])]),v._v(" "),_("li",[_("p",[v._v("String使用注意说明：")]),v._v(" "),_("p",[v._v('string s = "a";// 创建了一个字符串')]),v._v(" "),_("p",[v._v('s += "b"; // 实际上原来的“a”字符串对象已经丢弃了，现在又产生了一个字符串s+"b"（也就是"ab"）。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能=> 结论：如果我们对String做大量修改，不要使用String')])])])]),v._v(" "),_("li",[_("p",[v._v("String、StringBuffer和StringBuilder的选择")]),v._v(" "),_("ol",[_("li",[v._v("如果字符串存在大量的修改操作，一般使用StringBuffer或StringBuilder")]),v._v(" "),_("li",[v._v("如果字符串存在大量的修改操作，并在单线程的情况，使用StringBuilder")]),v._v(" "),_("li",[v._v("如果字符串存在大量的修改操作，并在多线程的情况，使用StringBuffer")]),v._v(" "),_("li",[v._v("如果我们字符串很少修改，被多个对象引用，使用String，比如配置信息等")])])])]),v._v(" "),_("h4",{attrs:{id:"math类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#math类"}},[v._v("#")]),v._v(" Math类")]),v._v(" "),_("ul",[_("li",[v._v("基本介绍：Math类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数")]),v._v(" "),_("li",[v._v("方法一览\n"),_("ol",[_("li",[v._v("abs 绝对值")]),v._v(" "),_("li",[v._v("pow 求幂")]),v._v(" "),_("li",[v._v("ceil 向上取整")]),v._v(" "),_("li",[v._v("floor 向下取整")]),v._v(" "),_("li",[v._v("round 四舍五入")]),v._v(" "),_("li",[v._v("sqrt 求开方")]),v._v(" "),_("li",[v._v("random 求随机数")]),v._v(" "),_("li",[v._v("max 求两个数的最大值")]),v._v(" "),_("li",[v._v("min 求两个数的最小值")])])])]),v._v(" "),_("h4",{attrs:{id:"date日期类、calendar日历类以及新的日期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#date日期类、calendar日历类以及新的日期"}},[v._v("#")]),v._v(" Date日期类、Calendar日历类以及新的日期")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("第一代日期类")]),v._v(" "),_("ol",[_("li",[v._v("Date：精确到毫秒，代表特定的瞬间")]),v._v(" "),_("li",[v._v("SimpleDateFormat：格式和解析日期的类，SimpleDateFormat格式化和解析日期的具体类。它允许格式化（日期->文本）、解析（文本->日期）和规范化")])])]),v._v(" "),_("li",[_("p",[v._v("第二代日期类")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("第二代日期类，主要就是Calendar类（日历）")]),v._v(" "),_("p",[_("code",[v._v("public abstract class Calendar extends Object implements Serializable,Cloneable,Comparable<Calendar>")])])]),v._v(" "),_("li",[_("p",[v._v("Calendar类是一个抽象类，它为特定瞬间与一组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法")])])])]),v._v(" "),_("li",[_("p",[v._v("第三代日期类")]),v._v(" "),_("p",[v._v("前面两代日期类的不足分析")]),v._v(" "),_("p",[v._v("JDK1.0中包含一个java.util.Date类，但是它的大多数方法已经在JDK1.1引入Calendar类之后被弃用了。而Calendar也存在问题是：")]),v._v(" "),_("ol",[_("li",[v._v("可变性：像日期和时间这样的类应该是不可变的")]),v._v(" "),_("li",[v._v("偏移性：Date中的年份是从1900开始的，而月份都从0开始")]),v._v(" "),_("li",[v._v("格式化：格式化只对Date有用，Calendar则不行")]),v._v(" "),_("li",[v._v("此外，它们也不是线程安全的；不能处理闰秒等（每隔2天，多出1s）")])])]),v._v(" "),_("li",[_("p",[v._v("第三代日期类常见方法")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("LocalDate（日期）、LocalTime（时间）、LocalDateTime（日期时间）")]),v._v(" "),_("p",[v._v("LocalDate只包含日期，可以获取日期字段")]),v._v(" "),_("p",[v._v("LocalTime只包含时间，可以获取时间字段")]),v._v(" "),_("p",[v._v("LocalDateTime包含日期+时间，可以获取日期和时间字段")])]),v._v(" "),_("li",[_("p",[v._v("DateTimeFormatter格式日期类")]),v._v(" "),_("p",[v._v("类似于SimpleDateFormat")]),v._v(" "),_("p",[v._v("DateTimeFormat dtf = DateTimeFormatter.ofPattern(格式);")]),v._v(" "),_("p",[v._v("String str = dtf.format(日期对象);")])]),v._v(" "),_("li",[_("p",[v._v("Instant时间戳")]),v._v(" "),_("p",[v._v("类似于Date")]),v._v(" "),_("p",[v._v("提供了一系列和Date类转换的方式")]),v._v(" "),_("p",[v._v("Instant -----\x3eDate：")]),v._v(" "),_("p",[v._v("Date date = Date.from(instant);")]),v._v(" "),_("p",[v._v("Date -----\x3eInstant：")]),v._v(" "),_("p",[v._v("Instant instant = date.toInstant();")])]),v._v(" "),_("li",[_("p",[v._v("第三代日期类更多方法")]),v._v(" "),_("ul",[_("li",[v._v("LocalDateTime类")]),v._v(" "),_("li",[v._v("MonthDay类：检查重复事件")]),v._v(" "),_("li",[v._v("是否是闰年")]),v._v(" "),_("li",[v._v("增加日期的某个部分")]),v._v(" "),_("li",[v._v("使用plus方法测试增加时间的某个部分")]),v._v(" "),_("li",[v._v("使用minus方法测试查看一年前和一年后的日期")])])])])])]),v._v(" "),_("h4",{attrs:{id:"system类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#system类"}},[v._v("#")]),v._v(" System类")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("System类常见方法")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("exit退出当前程序")])]),v._v(" "),_("li",[_("p",[v._v("arraycopy：复制数组元素，比较适合底层调用，一般使用Arrays.copyOf完成复制数组")]),v._v(" "),_("p",[_("code",[v._v("int[] src = {1, 2, 3};")])]),v._v(" "),_("p",[_("code",[v._v("int[] dest = new int[3];")])]),v._v(" "),_("p",[_("code",[v._v("System.arraycopy(src, 0, dest, 0, 3);")])])]),v._v(" "),_("li",[_("p",[v._v("currentTimeMillens：返回当前时间距离1970-1-1的毫秒数")])]),v._v(" "),_("li",[_("p",[v._v("gc：运行垃圾回收机制System.gc()")])])])])]),v._v(" "),_("h4",{attrs:{id:"arrays类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#arrays类"}},[v._v("#")]),v._v(" Arrays类")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("常见方法")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("toString返回数组的字符串形式"),_("code",[v._v("Arrays.toString(arr)")])])]),v._v(" "),_("li",[_("p",[v._v("sort排序（自然排序和定制排序）"),_("code",[v._v("Integer arr[] = {1, -1, 7, 0, 89};")])])]),v._v(" "),_("li",[_("p",[v._v("binarySearch通过二分搜索法进行查找，要求必须排好序"),_("code",[v._v("int index = Arrays.binarySearch(arr, 3);")])])]),v._v(" "),_("li",[_("p",[v._v("copyOf 数组元素的复制"),_("code",[v._v("Integer[] newArr = Arrays.copyOf(arr, arr.length);")])])]),v._v(" "),_("li",[_("p",[v._v("fill数组元素的填充"),_("code",[v._v("Integer[] num = new Integer[]{9, 3, 2};")])]),v._v(" "),_("p",[_("code",[v._v("Arrays.fill(num, 99);")])])]),v._v(" "),_("li",[_("p",[v._v("equals比较两个数组元素内容是否完全一致"),_("code",[v._v("boolean equals = Arrays.equals(arr, arr2);")])])]),v._v(" "),_("li",[_("p",[v._v("asList将一组值，转换成list"),_("code",[v._v("List<Integer> asList = Arrays.asList(2, 3, 4, 5, 6, 1);")])]),v._v(" "),_("p",[_("code",[v._v('System.out.println("asList=" + asList);')])])])])])]),v._v(" "),_("h4",{attrs:{id:"biginteger类和bigdecimal类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#biginteger类和bigdecimal类"}},[v._v("#")]),v._v(" BigInteger类和BigDecimal类")]),v._v(" "),_("ul",[_("li",[v._v("应用场景\n"),_("ol",[_("li",[v._v("BigInteger适合保存比较大的整型")]),v._v(" "),_("li",[v._v("BigDecimal适合保存精度更高的浮点型（小数）")])])]),v._v(" "),_("li",[v._v("BigInteger和BigDecimal常见方法\n"),_("ol",[_("li",[v._v("add 加")]),v._v(" "),_("li",[v._v("subtract 减")]),v._v(" "),_("li",[v._v("multiply 乘")]),v._v(" "),_("li",[v._v("divide 除")])])])]),v._v(" "),_("h3",{attrs:{id:"集合"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#集合"}},[v._v("#")]),v._v(" 集合")]),v._v(" "),_("h4",{attrs:{id:"集合框架体系"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#集合框架体系"}},[v._v("#")]),v._v(" 集合框架体系")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("数组的不足")]),v._v(" "),_("ol",[_("li",[v._v("长度开始时必须指定，而且一旦指定，不能更改")]),v._v(" "),_("li",[v._v("保存的必须为同一类型的元素")]),v._v(" "),_("li",[v._v("使用数组进行增加元素的示意代码，比较麻烦")])])]),v._v(" "),_("li",[_("p",[v._v("集合的理解和好处")]),v._v(" "),_("ol",[_("li",[v._v("可以动态保存任意多个对象，使用比较方便！")]),v._v(" "),_("li",[v._v("提供了一系列方便的操作对象的方法：add、remove、set、get等")]),v._v(" "),_("li",[v._v("使用集合添加，删除新元素的示意代码，简洁明了")])])]),v._v(" "),_("li",[_("p",[v._v("集合框架图")]),v._v(" "),_("p",[_("img",{attrs:{src:"Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9B%BE.png",alt:""}})]),v._v(" "),_("p",[v._v("解读：")]),v._v(" "),_("ol",[_("li",[v._v("集合主要是两组（单列集合，双列集合）")]),v._v(" "),_("li",[v._v("Collection接口有两个重要的子接口 List  Set，他们的实现子类都是单列集合")]),v._v(" "),_("li",[v._v("Map接口的实现子类，是双列集合，存放的是 key-value")])])])]),v._v(" "),_("h4",{attrs:{id:"collection接口"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#collection接口"}},[v._v("#")]),v._v(" Collection接口")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("Collection接口实现类的特点")]),v._v(" "),_("ol",[_("li",[v._v("collection实现子类可以存放多个元素，每个元素可以是Object")]),v._v(" "),_("li",[v._v("有些Collection的实现类，可以存放重复的元素，有些不可以")]),v._v(" "),_("li",[v._v("有些Collection的实现类，有些是有序的（List），有些不是有序的（Set）")]),v._v(" "),_("li",[v._v("Collection接口没有直接的实现子类，是通过它的子接口Set和List来实现的")])])]),v._v(" "),_("li",[_("p",[v._v("Collection接口常用方法")]),v._v(" "),_("ol",[_("li",[v._v("add：添加单个元素")]),v._v(" "),_("li",[v._v("remove：删除指定元素")]),v._v(" "),_("li",[v._v("contains：查找元素是否存在")]),v._v(" "),_("li",[v._v("size：获取元素个数")]),v._v(" "),_("li",[v._v("isEmpty：判断是否为空")]),v._v(" "),_("li",[v._v("clear：清空")]),v._v(" "),_("li",[v._v("addAll：添加多个元素")]),v._v(" "),_("li",[v._v("containsAll：查找多个元素是否都存在")]),v._v(" "),_("li",[v._v("removeAll：删除多个元素")])])]),v._v(" "),_("li",[_("p",[v._v("Collection接口遍历元素方式1-使用Iterator（迭代器）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("基本介绍")]),v._v(" "),_("p",[_("img",{attrs:{src:"Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/Iterator%E7%BB%93%E6%9E%84.png",alt:""}})]),v._v(" "),_("ol",[_("li",[v._v("Iterator对象称为迭代器，主要用于遍历Collection集合中的元素")]),v._v(" "),_("li",[v._v("所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器")]),v._v(" "),_("li",[v._v("Iterator的结构")]),v._v(" "),_("li",[v._v("Iterator仅用于遍历集合，Iterator本身并不存放对象")])])]),v._v(" "),_("li",[_("p",[v._v("迭代器的执行原理")]),v._v(" "),_("p",[_("code",[v._v("Iterator iterator = coll.iterator();//得到一个集合的迭代器")])]),v._v(" "),_("p",[_("code",[v._v("//hasNext()：判断是否还有下一个元素")])]),v._v(" "),_("p",[_("code",[v._v("while(iterator.hasNext()){")])]),v._v(" "),_("p",[_("code",[v._v("//next()作用：①指针下移 ②将下移以后集合位置上的元素返回")])]),v._v(" "),_("p",[_("code",[v._v("System.out.println(iterator.next());")])]),v._v(" "),_("p",[_("code",[v._v("}")])]),v._v(" "),_("p",[_("img",{attrs:{src:"Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86.png",alt:""}})]),v._v(" "),_("p",[v._v("注意：在调用iterator.nexxt()方法之前必须调用iterator.hasNext()进行检测。若不调用，且下一条记录无效，直接调用iterator.next()会抛出NoSuchElementException异常。")])])])]),v._v(" "),_("li",[_("p",[v._v("Collection接口遍历对象方式2-for循环增强")]),v._v(" "),_("p",[v._v("增强for循环，可以代替iterator迭代器，特点：增强for就是简化版的iterator，本质一样。只能用于遍历集合或数组。")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("基本语法")]),v._v(" "),_("p",[_("code",[v._v("for(元素类型 元素名：集合名或数组名){")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("访问元素")])]),v._v(" "),_("p",[_("code",[v._v("}")])])])])]),v._v(" "),_("li",[_("p",[v._v("List接口和常用方法")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("List接口基本介绍")]),v._v(" "),_("p",[v._v("List接口是Collection接口的子接口")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("List集合类中元素有序(即添加顺序和取出顺序一致)、且可重复")])]),v._v(" "),_("li",[_("p",[v._v("List集合中的每个元素都有其对应的顺序索引，即支持索引")])]),v._v(" "),_("li",[_("p",[v._v("List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素")])]),v._v(" "),_("li",[_("p",[v._v("JDK API中List接口的实现类有：")]),v._v(" "),_("p",[v._v("常用的有：ArrayList、LinkedList和Vector")])])])]),v._v(" "),_("li",[_("p",[v._v("List接口的常用方法")]),v._v(" "),_("p",[v._v("List集合里添加了一些根据索引来操作集合元素的方法")]),v._v(" "),_("ol",[_("li",[v._v("void add(int index,Object ele)：在index位置插入ele元素")]),v._v(" "),_("li",[v._v("boolean addAll(int index,Collection eles)：从index位置开始将eles中的所有元素添加进来")]),v._v(" "),_("li",[v._v("Object get(int index)：获取指定index位置的元素")]),v._v(" "),_("li",[v._v("int indexOf(Object obj)：返回obj在集合中首次出现的位置")]),v._v(" "),_("li",[v._v("int lastIndexOf(Object obj)：返回obj在当前集合中末次出现的位置")]),v._v(" "),_("li",[v._v("Object remove(int index)：移除指定index位置的元素，并返回此元素")]),v._v(" "),_("li",[v._v("Object set(int index,Object ele)：设置指定index位置的元素为ele，相当于是替换")]),v._v(" "),_("li",[v._v("List subList(int fromIndex,int toIndex)：返回从fromIndex到toIndex位置的子集合")])])]),v._v(" "),_("li",[_("p",[v._v("List的三种遍历方式")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("方式一：使用iterator")]),v._v(" "),_("p",[_("code",[v._v("Iterator iter = col.iterator();")])]),v._v(" "),_("p",[_("code",[v._v("while(iter.hasNext()){")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("Object o = iter.next();")])]),v._v(" "),_("p",[_("code",[v._v("}")])])]),v._v(" "),_("li",[_("p",[v._v("方式二：使用增强for")]),v._v(" "),_("p",[_("code",[v._v("for(Object o:col){")])]),v._v(" "),_("p",[_("code",[v._v("}")])])]),v._v(" "),_("li",[_("p",[v._v("方式三：使用普通for")]),v._v(" "),_("p",[_("code",[v._v("for(int i = 0; i<list.size(); i++){")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("Object object = list.get(i);")])]),v._v(" "),_("p",[v._v("​\t"),_("code",[v._v("System.out.println(object);")])]),v._v(" "),_("p",[_("code",[v._v("}")])]),v._v(" "),_("p",[v._v("说明：使用LinkedList完成使用方式和ArrayList一样")])])])])])]),v._v(" "),_("li",[_("p",[v._v("ArrayList底层结构和源码分析")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("ArrayList的注意事项")]),v._v(" "),_("ol",[_("li",[v._v("permits all elements, including null, ArrayList可以加入null，多个null也可以")]),v._v(" "),_("li",[v._v("ArrayList是由数组来实现数据存储的")]),v._v(" "),_("li",[v._v("ArrayList基本等同于Vector，除了ArrayList是线程不安全(执行效率高)看源码，在多线程情况下，不建议使用ArrayList")])])]),v._v(" "),_("li",[_("p",[v._v("ArrayList的底层操作机制源码分析（重点，难点）")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("ArrayList中维护了一个Object类型的数组elementData")]),v._v(" "),_("p",[_("code",[v._v("transient Object[] elementData;// transient 表示瞬间，短暂的，表示该属性不会被序列化")])])]),v._v(" "),_("li",[_("p",[v._v("当创建对象时，如果使用的是无参构造器，则初始elementData容量为0（jdk7是10）")])]),v._v(" "),_("li",[_("p",[v._v("当添加元素时：先判断是否需要扩容，如果需要扩容，则调用grow方法，否则直接添加元素到合适位置")])]),v._v(" "),_("li",[_("p",[v._v("如果使用的是无参构造器，如果第一次添加，需要扩容的话，则扩容elementData为10，如果需要再次扩容的话，则扩容elementData为1.5倍")])]),v._v(" "),_("li",[_("p",[v._v("如果使用的是指定容量capacity的构造器，则初始elementData容量为capacity")])]),v._v(" "),_("li",[_("p",[v._v("如果使用的是指定容量capacity的构造器，如果需要扩容，则直接扩容elementData为1.5倍")])])]),v._v(" "),_("div",{staticClass:"language-注释 extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("注意：IDEA默认情况下，Debug显示的数据是简化后的，如果希望看到完整的数据，需要做设置Build，Execution，Deployment=》Debugger=》Data Views=》Java中取消勾选Enable alternative view for Collections classes\n")])])])])])]),v._v(" "),_("li",[_("p",[v._v("Vector底层结构和源码剖析")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("Vector的基本介绍")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("Vector类的定义说明")]),v._v(" "),_("div",{staticClass:"language-java extra-class"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("public")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("class")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("Vector")]),_("span",{pre:!0,attrs:{class:"token generics"}},[_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("<")]),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("E")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(">")])]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("extends")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("AbstractList")]),_("span",{pre:!0,attrs:{class:"token generics"}},[_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("<")]),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("E")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(">")])]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("implements")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("List")]),_("span",{pre:!0,attrs:{class:"token generics"}},[_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("<")]),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("E")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(">")])]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("RandomAccess")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("Cloneable")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("Serializable")]),v._v("\n")])])])]),v._v(" "),_("li",[_("p",[v._v("Vector底层也是一个对象数组")]),v._v(" "),_("p",[_("code",[v._v("protected Object[] elementData;")])])]),v._v(" "),_("li",[_("p",[v._v("Vector是线程同步的，即线程安全，Vector类的操作方法带有synchronized")]),v._v(" "),_("div",{staticClass:"language-java extra-class"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("public")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("synchronized")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("E")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token function"}},[v._v("get")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("int")]),v._v(" index"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("if")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("index "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">=")]),v._v(" elementCount"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\n        "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("throw")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("new")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("ArrayIndexOutOfBoundsException")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("index"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("return")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token function"}},[v._v("elementData")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("index"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n")])])])]),v._v(" "),_("li",[_("p",[v._v("在开发中，需要线程同步安全时，考虑使用Vector")])])])]),v._v(" "),_("li",[_("p",[v._v("Vector和ArrayList的比较")]),v._v(" "),_("p",[_("img",{attrs:{src:"Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/Vector%E5%92%8CArrayList%E7%9A%84%E6%AF%94%E8%BE%83.png",alt:""}})])])])]),v._v(" "),_("li",[_("p",[v._v("LinkedList底层结构")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("LinkedList的全面说明")]),v._v(" "),_("ol",[_("li",[v._v("LinkedList实现了双向链表和双端队列特点")]),v._v(" "),_("li",[v._v("可以添加任意元素（元素可以重复），包括null")]),v._v(" "),_("li",[v._v("线程不安全，没有实现同步")])])]),v._v(" "),_("li",[_("p",[v._v("LinkedList的底层操作机制")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("LinkedList底层维护了一个双向链表")])]),v._v(" "),_("li",[_("p",[v._v("LinkedList中维护了两个属性first和last分别指向首结点和尾结点")])]),v._v(" "),_("li",[_("p",[v._v("每个结点（Node对象），里面又维护了prev、next、item三个属性，其中通过prev指向前一个，通过next指向后一个结点。最终实现双向链表")])]),v._v(" "),_("li",[_("p",[v._v("所有LinkedList的元素的添加和删除，不是通过数组完成的，相对来说效率较高")]),v._v(" "),_("p",[_("img",{attrs:{src:"Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/LinkedList%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C%E6%9C%BA%E5%88%B6.png",alt:""}})])])])]),v._v(" "),_("li",[_("p",[v._v("ArrayList和LinkedList的比较")]),v._v(" "),_("p",[_("img",{attrs:{src:"Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/ArrayList%E5%92%8CLinkedList%E7%9A%84%E6%AF%94%E8%BE%83.png",alt:""}})]),v._v(" "),_("p",[v._v("如何选择ArrayList和LinkedList：")]),v._v(" "),_("ol",[_("li",[v._v("如果我们改查的操作多，选择ArrayList")]),v._v(" "),_("li",[v._v("如果我们增删的操作多，选择LinkedList")]),v._v(" "),_("li",[v._v("一般来说，在程序中，80%-90%都是查询，因此大部分情况下会选择ArrayList")]),v._v(" "),_("li",[v._v("在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList，另外一个模块是LinkedList，也就是说，要根据业务来进行选择")])])])])]),v._v(" "),_("li",[_("p",[v._v("Set接口和常用方法")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("Set接口基本介绍")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("无序（添加和取出的顺序不一致），没有索引")])]),v._v(" "),_("li",[_("p",[v._v("不允许重复元素，所以最多包含一个null")])]),v._v(" "),_("li",[_("p",[v._v("JDK API中Set接口的实现类有：")]),v._v(" "),_("p",[_("img",{attrs:{src:"Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/Set%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png",alt:""}})])])])]),v._v(" "),_("li",[_("p",[v._v("Set接口的常用方法")]),v._v(" "),_("p",[v._v("和List接口一样，Set接口也是Collection的子接口，因此，常用方法和Collection接口一样")])]),v._v(" "),_("li",[_("p",[v._v("Set接口的遍历方式")]),v._v(" "),_("p",[v._v("同Collection的遍历方式一样，因为Set接口是Collection接口的子接口。")]),v._v(" "),_("ol",[_("li",[v._v("可以使用迭代器")]),v._v(" "),_("li",[v._v("增强for")]),v._v(" "),_("li",[v._v("不能使用索引的方式来获取")])])])])]),v._v(" "),_("li",[_("p",[v._v("Set接口实现类-HashSet")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("HashSet的全面说明")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("HashSet实现了Set接口")])]),v._v(" "),_("li",[_("p",[v._v("HashSet实际上是HashMap")]),v._v(" "),_("div",{staticClass:"language-java extra-class"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("public")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("HashSet")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n    map "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("new")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("HashMap")]),_("span",{pre:!0,attrs:{class:"token generics"}},[_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("<")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(">")])]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n")])])])]),v._v(" "),_("li",[_("p",[v._v("可以存放null值，但是只能有一个null")])]),v._v(" "),_("li",[_("p",[v._v("HashSet不保证元素是有序的，取决于hash后，再确定索引的结果")])]),v._v(" "),_("li",[_("p",[v._v("不能有重复元素/对象。在前面Set接口使用已经讲过")])])])]),v._v(" "),_("li",[_("p",[v._v("HashSet底层机制说明")]),v._v(" "),_("p",[v._v("分析HashSet底层是HashMap，HashMap底层是（数组+链表+红黑树）")]),v._v(" "),_("p",[_("img",{attrs:{src:"Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/HashSet%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%E8%AF%B4%E6%98%8E.png",alt:""}})]),v._v(" "),_("ul",[_("li",[v._v("分析HashSet的添加元素底层是如何实现(hash()+equals())\n"),_("ol",[_("li",[v._v("HashSet底层是HashMap")]),v._v(" "),_("li",[v._v("添加一个元素时，先得到hash值 -> 会转成 -> 索引值")]),v._v(" "),_("li",[v._v("找到存储数据表table，看这个索引位置是否已经存放的有元素")]),v._v(" "),_("li",[v._v("如果没有，直接加入")]),v._v(" "),_("li",[v._v("如果有，调用equals比较，如果相同，就放弃添加，如果不相同，则添加到最后")]),v._v(" "),_("li",[v._v("在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD（默认是8），并且table的大小>=MIN_TREEIFY_CAPACITY（默认是64），就会进行树化（红黑树)")])])]),v._v(" "),_("li",[v._v("分析HashSet的扩容和转成红黑树机制\n"),_("ol",[_("li",[v._v("HashSet底层是HashMap，第一次添加时，table数组扩容到16，临界值(threshold)是16*加载因子(loadFactor)是0.75=12")]),v._v(" "),_("li",[v._v("如果table数组使用到了临界值12，就会扩容到16*2=32，新的临界值就是32*0.75=24，依次类推")]),v._v(" "),_("li",[v._v("在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)，并且table的大小>=MIN_TREEIFY_CAPACITY(默认是64)，就会进行树化(红黑树)，否则仍然采用数组扩容机制")])])])])])])]),v._v(" "),_("li",[_("p",[v._v("Set接口实现类-LinkedHashSet")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("LinkedHashSet的全面说明")]),v._v(" "),_("ol",[_("li",[v._v("LinkedHashSet是HashSet的子类")]),v._v(" "),_("li",[v._v("LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表")]),v._v(" "),_("li",[v._v("LinkedHashSet根据元素的hashCode值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的")]),v._v(" "),_("li",[v._v("LinkedHashSet不允许添重复元素")])])]),v._v(" "),_("li",[_("p",[v._v("LinkedHashSet底层机制示意图")]),v._v(" "),_("p",[_("img",{attrs:{src:"Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/LinkedHashSet%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.png",alt:""}})]),v._v(" "),_("p",[v._v("说明")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("在LinkedHashSet中维护了一个hash表和双向链表(LinkedHashSet有head和tail)")])]),v._v(" "),_("li",[_("p",[v._v("每一个节点有pre和next属性，这样可以形成双向链表")])]),v._v(" "),_("li",[_("p",[v._v("在添加一个元素时，先求hash值，在求索引，确定该元素在hashtable的位置，然后将添加的元素加入到双向链表(如果已经存在，不添加【原则和和hashset一样】)")]),v._v(" "),_("div",{staticClass:"language-java extra-class"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[v._v("tail"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("next "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" newElement"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 简单指定")]),v._v("\nnewElement"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("pre "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" tail"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\ntail "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" newElement"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])])])]),v._v(" "),_("li",[_("p",[v._v("这样的话，我们遍历LinkedHashSet也能确保插入顺序和遍历顺序一致")])])])])])])]),v._v(" "),_("h4",{attrs:{id:"map接口"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#map接口"}},[v._v("#")]),v._v(" Map接口")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("Map接口和常用方法")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("Map接口实现类的特点")]),v._v(" "),_("p",[v._v("注意：这里讲的是JDK8的Map接口特点")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("Map与Collection并列存在。用于保存具有映射关系的数据：key-value（双列元素）")])]),v._v(" "),_("li",[_("p",[v._v("Map中的key和value可以是任何引用类型的数据，会封装到HashMap$Node对象中")])]),v._v(" "),_("li",[_("p",[v._v("Map中的key不允许重复，原因和HashSet一样，前面分析过源码")])]),v._v(" "),_("li",[_("p",[v._v("Map中的value可以重复")])]),v._v(" "),_("li",[_("p",[v._v("Map的key可以为null，value也可以为null，注意key为null，只能有一个，value为null，可以多个")])]),v._v(" "),_("li",[_("p",[v._v("常用String类作为Map的key")])]),v._v(" "),_("li",[_("p",[v._v("key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value")])]),v._v(" "),_("li",[_("p",[v._v("Map存放数据的key-value示意图，一对k-v是放在一个HashMap$Node中的，有因为Node实现了Entry接口，有些书上也说，一对k-v就是一个Entry")]),v._v(" "),_("p",[_("img",{attrs:{src:"Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/Map%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%89%B9%E7%82%B9.png",alt:""}})])])])]),v._v(" "),_("li",[_("p",[v._v("Map体系的继承图")]),v._v(" "),_("p",[_("img",{attrs:{src:"Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/Map%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%9B%BE.png",alt:""}})])]),v._v(" "),_("li",[_("p",[v._v("Map接口常用方法")]),v._v(" "),_("ol",[_("li",[v._v("put：添加")]),v._v(" "),_("li",[v._v("remove：根据键删除映射关系")]),v._v(" "),_("li",[v._v("get：根据键获取值")]),v._v(" "),_("li",[v._v("size：获取元素个数")]),v._v(" "),_("li",[v._v("isEmpty：判断个数是否为0")]),v._v(" "),_("li",[v._v("clear：清除")]),v._v(" "),_("li",[v._v("containsKey：查找键是否存在")])])]),v._v(" "),_("li",[_("p",[v._v("Map接口遍历方法")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("Map遍历的示意图（比List，和Set复杂点，但是基本原理一样）")])]),v._v(" "),_("li",[_("p",[v._v("Map遍历方式案例演示")]),v._v(" "),_("ol",[_("li",[v._v("containsKey：查找键是否存在")]),v._v(" "),_("li",[v._v("keySet：获取所有的键")]),v._v(" "),_("li",[v._v("entrySet：获取所有关系")]),v._v(" "),_("li",[v._v("values：获取所有的值")])])])])])])]),v._v(" "),_("li",[_("p",[v._v("Map接口实现类-HashMap")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("HashMap小结")]),v._v(" "),_("ol",[_("li",[v._v("Map接口的常用实现类：HashMap、Hashtable和Properties")]),v._v(" "),_("li",[v._v("HashMap是Map接口使用频率最高的实现类")]),v._v(" "),_("li",[v._v("HashMap是以key-val对的方式来存储数据")]),v._v(" "),_("li",[v._v("key不能重复，但是值可以重复，允许使用null键和null值")]),v._v(" "),_("li",[v._v("如果添加相同的key，则会覆盖原来的key-val，等同于修改（key不会替换，val会替换）")]),v._v(" "),_("li",[v._v("与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的")]),v._v(" "),_("li",[v._v("HashMap没有实现同步，因此是线程不安全的，方法没有做同步互斥操作，没有synchronized")])])]),v._v(" "),_("li",[_("p",[v._v("HashMap底层机制及源码剖析")]),v._v(" "),_("p",[_("img",{attrs:{src:"Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/HashMap%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.png",alt:""}})]),v._v(" "),_("ol",[_("li",[v._v("(k,v)是一个Node实现了Map.Entry<K,V>，查看HashMap的源码可以看到")]),v._v(" "),_("li",[v._v("jdk7.0的hashmap底层实现[数组+链表]，jdk8.0底层[数组+链表+红黑树]")])]),v._v(" "),_("p",[v._v("扩容机制：（和HashSet相同）")]),v._v(" "),_("ol",[_("li",[v._v("HashMap底层维护了Node类型的数组table，默认为null")]),v._v(" "),_("li",[v._v("当创建对象时，将加载因子(loadfactor)初始化为0.75")]),v._v(" "),_("li",[v._v("当添加key-val时，通过key的哈希值得到在table的索引。然后判断该索引处是否有元素，如果没有元素直接添加。如果该索引处有元素，继续判断该元素的key和准备加入的key是否相等，如果相等，则直接替换val；如果不相等需要判断是树结构还是链表结构，做出相应处理。如果添加时发现容量不够，则需要扩容")]),v._v(" "),_("li",[v._v("第1次添加，则需要扩容table容量为16，临界值(threshold)为12")]),v._v(" "),_("li",[v._v("以后再扩容，则需要扩容table容量为原来的2倍，临界值为原来的2倍，即24，依此类推")]),v._v(" "),_("li",[v._v("在Java8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD（默认是8），并且table的大小>=MIN_TREEIFY_CAPACITY（默认64），就会进行树化（红黑树）")])])])])]),v._v(" "),_("li",[_("p",[v._v("Map接口实现类-Hashtable")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("HashTable的基本介绍")]),v._v(" "),_("ol",[_("li",[v._v("存放的元素是键值对：即K-V")]),v._v(" "),_("li",[v._v("hashtable的键和值都不能为null，否则会抛出NullPointerException")]),v._v(" "),_("li",[v._v("hashTable使用方法基本上和HashMap一样")]),v._v(" "),_("li",[v._v("hashTable是线程安全的(synchronized)，hashMap是线程不安全的")])])]),v._v(" "),_("li",[_("p",[v._v("Hashtable和HashMap对比")]),v._v(" "),_("p",[_("img",{attrs:{src:"Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/Hashtable%E5%92%8CHashMap%E5%AF%B9%E6%AF%94.png",alt:""}})])])])]),v._v(" "),_("li",[_("p",[v._v("Map接口实现类-Properties")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("基本介绍")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("Properties类继承自Hashtable类并且实现了Map接口，也是使用一种键值对的形式来保存数据")])]),v._v(" "),_("li",[_("p",[v._v("他的使用特点和Hashtable类似")])]),v._v(" "),_("li",[_("p",[v._v("Properties还可以用于从 xxx.properties 文件中，加载数据到Properties类对象，并进行读取和修改")])]),v._v(" "),_("li",[_("p",[v._v("说明：工作后 xxx.properties 文件通常作为配置文件，这个知识点在IO流举例，有兴趣可先看文章")]),v._v(" "),_("p",[v._v("https://www.cnblogs.com/xudong-bupt/p/3758136.html")])])])])])]),v._v(" "),_("li",[_("p",[v._v("总结-开发中如何选择集合实现类")]),v._v(" "),_("p",[v._v("在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行选择，分析如下：")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("先判断存储的类型（一组对象[单列]或一组键值对[双列]）")])]),v._v(" "),_("li",[_("p",[v._v("一组对象[单列]：Collection接口")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("允许重复：List")]),v._v(" "),_("ul",[_("li",[v._v("增删多：LinkedList [底层维护了一个双向链表]")]),v._v(" "),_("li",[v._v("改查多：ArrayList [底层维护了Object类型的可变数组]")])])]),v._v(" "),_("li",[_("p",[v._v("不允许重复：Set")]),v._v(" "),_("ul",[_("li",[v._v("无序：HashSet [底层是HashMap，维护了一个哈希表，即（数组+链表+红黑树）]")]),v._v(" "),_("li",[v._v("排序：TreeSet")]),v._v(" "),_("li",[v._v("插入和取出顺序一致：LinkedHashSet [底层LinkedHashMap的底层HashMap]，维护数组+双向链表")])])])])]),v._v(" "),_("li",[_("p",[v._v("一组键值对[双列]：Map")]),v._v(" "),_("ul",[_("li",[v._v("键无序：HashMap [底层是：哈希表 jdk7：数组+链表，jdk8：数组+链表+红黑树]")]),v._v(" "),_("li",[v._v("键排序：TreeMap")]),v._v(" "),_("li",[v._v("键插入和取出顺序一致：LinkedHashMap")]),v._v(" "),_("li",[v._v("读取文件 Properties")])])])])])]),v._v(" "),_("h4",{attrs:{id:"collections工具类的使用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#collections工具类的使用"}},[v._v("#")]),v._v(" Collections工具类的使用")]),v._v(" "),_("ul",[_("li",[v._v("Collections工具类\n"),_("ul",[_("li",[v._v("Collections工具类介绍\n"),_("ol",[_("li",[v._v("Collections是一个操作Set、List和Map等集合的工具类")]),v._v(" "),_("li",[v._v("Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作")])])]),v._v(" "),_("li",[v._v("排序操作：（均为static方法）\n"),_("ol",[_("li",[v._v("reverse(List)：反转List中元素的顺序")]),v._v(" "),_("li",[v._v("shuffle(List)：对List集合元素进行随机排序")]),v._v(" "),_("li",[v._v("sort(List)：根据元素的自然顺序对指定的List集合元素按升序排序")]),v._v(" "),_("li",[v._v("sort(List, Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序")]),v._v(" "),_("li",[v._v("swap(List, int, int)：将指定list集合中的i处元素和j处元素进行交换")])])]),v._v(" "),_("li",[v._v("查找、替换\n"),_("ol",[_("li",[v._v("Object max(Collection)：根据元素的自然排序，返回给指定集合中的最大元素")]),v._v(" "),_("li",[v._v("Object max(Collection, Comparator)：根据Comparator指定的顺序，返回给定集合中的最大元素")]),v._v(" "),_("li",[v._v("Object min(Collection)")]),v._v(" "),_("li",[v._v("Object min(Collection, Comparator)")]),v._v(" "),_("li",[v._v("int frequency(Collection, Object)：返回指定集合中指定元素的出现次数")]),v._v(" "),_("li",[v._v("void copy(List dest, List src)：将src中的内容复制到dest中")]),v._v(" "),_("li",[v._v("boolean replaceAll(List list, Object oldVal, Object newVal)：使用新值替换List对象的所有旧值")])])])])])])])}),[],!1,null,null,null);_.default=a.exports}}]);