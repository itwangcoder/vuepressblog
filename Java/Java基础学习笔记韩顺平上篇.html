<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java基础学习笔记韩顺平上篇 | itwangcoder&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/vuepressblog/img/logo.png">
    <meta name="description" content="Java基础学习笔记韩顺平上篇">
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/vuepressblog/assets/css/0.styles.e7a65157.css" as="style"><link rel="preload" href="/vuepressblog/assets/js/app.80634c63.js" as="script"><link rel="preload" href="/vuepressblog/assets/js/3.ef187fa4.js" as="script"><link rel="preload" href="/vuepressblog/assets/js/1.93e2b1ee.js" as="script"><link rel="preload" href="/vuepressblog/assets/js/17.ad9b924f.js" as="script"><link rel="preload" href="/vuepressblog/assets/js/9.76c7ad5c.js" as="script"><link rel="prefetch" href="/vuepressblog/assets/js/10.987eeee2.js"><link rel="prefetch" href="/vuepressblog/assets/js/11.e2698b0f.js"><link rel="prefetch" href="/vuepressblog/assets/js/12.d1a773de.js"><link rel="prefetch" href="/vuepressblog/assets/js/13.b1124dce.js"><link rel="prefetch" href="/vuepressblog/assets/js/14.d43425cc.js"><link rel="prefetch" href="/vuepressblog/assets/js/15.301d4ee9.js"><link rel="prefetch" href="/vuepressblog/assets/js/16.fb92ba76.js"><link rel="prefetch" href="/vuepressblog/assets/js/18.b28999b2.js"><link rel="prefetch" href="/vuepressblog/assets/js/19.ae4fe37d.js"><link rel="prefetch" href="/vuepressblog/assets/js/20.8648e605.js"><link rel="prefetch" href="/vuepressblog/assets/js/21.afba39d8.js"><link rel="prefetch" href="/vuepressblog/assets/js/22.a421ec88.js"><link rel="prefetch" href="/vuepressblog/assets/js/23.43bb5f78.js"><link rel="prefetch" href="/vuepressblog/assets/js/24.5300c069.js"><link rel="prefetch" href="/vuepressblog/assets/js/25.e5fe554e.js"><link rel="prefetch" href="/vuepressblog/assets/js/26.d4f0f7c0.js"><link rel="prefetch" href="/vuepressblog/assets/js/27.3d604a05.js"><link rel="prefetch" href="/vuepressblog/assets/js/28.5b15f884.js"><link rel="prefetch" href="/vuepressblog/assets/js/29.f763d748.js"><link rel="prefetch" href="/vuepressblog/assets/js/30.2d33ed3c.js"><link rel="prefetch" href="/vuepressblog/assets/js/31.63dec94e.js"><link rel="prefetch" href="/vuepressblog/assets/js/32.1d419569.js"><link rel="prefetch" href="/vuepressblog/assets/js/33.dd0d73a3.js"><link rel="prefetch" href="/vuepressblog/assets/js/34.11980da6.js"><link rel="prefetch" href="/vuepressblog/assets/js/35.60c39dd1.js"><link rel="prefetch" href="/vuepressblog/assets/js/36.3eb7aee1.js"><link rel="prefetch" href="/vuepressblog/assets/js/37.9b1bc008.js"><link rel="prefetch" href="/vuepressblog/assets/js/38.05776efb.js"><link rel="prefetch" href="/vuepressblog/assets/js/39.7ae3eed8.js"><link rel="prefetch" href="/vuepressblog/assets/js/4.fadd923b.js"><link rel="prefetch" href="/vuepressblog/assets/js/40.fb2393be.js"><link rel="prefetch" href="/vuepressblog/assets/js/41.5f5dec94.js"><link rel="prefetch" href="/vuepressblog/assets/js/42.b9f6299c.js"><link rel="prefetch" href="/vuepressblog/assets/js/43.b3178a1b.js"><link rel="prefetch" href="/vuepressblog/assets/js/5.b07d85ee.js"><link rel="prefetch" href="/vuepressblog/assets/js/6.cdd119e1.js"><link rel="prefetch" href="/vuepressblog/assets/js/7.fe6c61b0.js"><link rel="prefetch" href="/vuepressblog/assets/js/8.d08f9a62.js">
    <link rel="stylesheet" href="/vuepressblog/assets/css/0.styles.e7a65157.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>itwangcoder's blog</h3> <p class="description" data-v-59e6cb88>我的个人网站</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>itwangcoder</span>
          
        <!---->
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepressblog/" class="home-link router-link-active"><img src="/vuepressblog/img/logo.png" alt="itwangcoder's blog" class="logo"> <span class="site-name">itwangcoder's blog</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vuepressblog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><a href="/vuepressblog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><a href="https://www.baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  百度
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><img src="/vuepressblog/img/logo.png" alt="author-avatar" class="personal-img" data-v-1fad0c41> <h3 class="name" data-v-1fad0c41>
    itwangcoder
  </h3> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>31</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>32</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/vuepressblog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><a href="/vuepressblog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><a href="https://www.baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  百度
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>Java基础学习笔记韩顺平上篇</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>itwangcoder</span>
          
        <!---->
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">Java基础学习笔记韩顺平上篇</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>itwangcoder</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>2023/12/19</span></i> <!----> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>韩顺平</span><span class="tag-item" data-v-8a445198>Java</span><span class="tag-item" data-v-8a445198>编程语言</span></i></div></div> <div class="theme-reco-content content__default"><h1 id="java基础-韩顺平"><a href="#java基础-韩顺平" class="header-anchor">#</a> Java基础---韩顺平</h1> <h2 id="一、建立编程思想"><a href="#一、建立编程思想" class="header-anchor">#</a> 一、建立编程思想</h2> <h3 id="学前详解"><a href="#学前详解" class="header-anchor">#</a> 学前详解</h3> <h4 id="就业方向"><a href="#就业方向" class="header-anchor">#</a> 就业方向</h4> <ul><li>Java EE软件工程师</li> <li>大数据软件工程师</li> <li>Android软件工程师</li></ul> <h4 id="应用领域"><a href="#应用领域" class="header-anchor">#</a> 应用领域</h4> <ul><li>企业级应用</li> <li>Android平台应用</li> <li>移动领域应用</li></ul> <h3 id="java概述"><a href="#java概述" class="header-anchor">#</a> Java概述</h3> <p>什么是程序：计算机执行某些操作或解决某个问题而编写的一系列<strong>有序指令的集合</strong></p> <h4 id="java技术体系平台"><a href="#java技术体系平台" class="header-anchor">#</a> Java技术体系平台</h4> <ul><li><p>Java SE标准版——支持面向桌面级应用的Java平台</p></li> <li><p>Java EE企业版——是为开发企业环境下的应用程序提供的一套解决方案</p></li> <li><p>Java ME小型版——支持Java程序运行在移动终端上的平台</p></li></ul> <h4 id="特点"><a href="#特点" class="header-anchor">#</a> 特点</h4> <ol><li>Java语言是面向对象的</li> <li>Java语言是健壮的，Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证</li> <li>Java语言是跨平台性的</li> <li>Java语言是解释型的</li></ol> <h5 id="区别"><a href="#区别" class="header-anchor">#</a> 区别</h5> <p>解释性语言：JavaScript、PHP、Java</p> <p>编译性语言：C/C++</p> <p>区别：解释性语言，编译后的代码，不能直接被机器 执行，需要解释器来执行，编译性语言，编译后的代码，可以直接被机器执行</p> <h4 id="java运行机制及运行过程"><a href="#java运行机制及运行过程" class="header-anchor">#</a> Java运行机制及运行过程</h4> <p>Java核心机制——Java虚拟机【JVM】</p> <h5 id="基本介绍"><a href="#基本介绍" class="header-anchor">#</a> 基本介绍</h5> <ol><li>JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，包括在<strong>JDK</strong>中</li> <li>对于不同的平台，有不同的虚拟机</li> <li>Java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”</li></ol> <h5 id="jdk与jre"><a href="#jdk与jre" class="header-anchor">#</a> JDK与JRE</h5> <ol><li>JDK = JRE + 开发工具集</li> <li>JRE = JVM + Java SE标准类库</li> <li>JDK = JVM + Java SE标准类库 + 开发工具集</li> <li>如果只想运行开发好的.class文件，只需要JRE</li></ol> <h5 id="java执行流程"><a href="#java执行流程" class="header-anchor">#</a> Java执行流程</h5> <p><img src="Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/Java%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt=""></p> <h4 id="java开发注意事项和细节说明"><a href="#java开发注意事项和细节说明" class="header-anchor">#</a> Java开发注意事项和细节说明</h4> <ol><li>Java源文件以.java为扩展名。源文件的基本组成部分是类(class)，如本类中的Hello类</li> <li>Java应用程序的执行入口是main()方法。它有固定的书写格式：<code>public static void main(String[] args){……}</code></li> <li>Java语言严格区分大小写</li> <li>Java方法由一条条语句构成，每个语句以“;”结束</li> <li>大括号都是成对出现的，缺一不可。【习惯，想写{}再写代码】</li> <li>一个源文件中最多只能有一个public类。其他类的个数不限。</li> <li>如果源文件包含一个public类，则文件名必须按该类名命名</li> <li>一个源文件中最多只能有一个public类。其它类的个数不限，也可以将main方法写在非public类中，然后指定运行非public类，这样入口方法就是非public类的main方法</li></ol> <h5 id="java转义字符"><a href="#java转义字符" class="header-anchor">#</a> Java转义字符</h5> <ul><li>\t：一个制表符，实现对齐的功能</li> <li>\n：换行符</li> <li>\\：一个\</li> <li>\&quot;：一个&quot;</li> <li>\'：一个'</li> <li>\r：一个回车——输出后光标会放置当前行首位，后面输出的内容会覆盖之前的内容<code>System.out.println(&quot;好好学习\r天天&quot;);</code>  输出结果为<strong>天天学习</strong></li></ul> <h4 id="java基础知识学习"><a href="#java基础知识学习" class="header-anchor">#</a> Java基础知识学习</h4> <h5 id="java注释"><a href="#java注释" class="header-anchor">#</a> Java注释</h5> <ul><li><p>单行注释：// 注释内容</p></li> <li><p>多行注释：/* 注释内容 */</p></li> <li><p>文档注释：注释内容可以被JDK提供的工具javadoc所解析</p> <p><code>/**</code></p> <p><code>* @author 汪重阳</code></p> <p><code>* @version 1.0</code></p> <p><code>*/</code></p></li></ul> <p><code>javadoc -d d:\\Code\\SUBJAVA\\Test -author -version ChangeChar.java</code></p> <h5 id="java代码规范"><a href="#java代码规范" class="header-anchor">#</a> Java代码规范</h5> <ol><li>类、方法的注释，要以javadoc的方式来写</li> <li>非Java Doc的注释，往往是给代码的维护者看的，着重告述读者为什么这样写，如何修改，注意什么问题等</li> <li>使用tab操作，实现缩进，默认整体向右边移动，时候用shift+tab整体向左移</li> <li>运算符和 = 两边习惯性各加一个空格。如：2 + 4 * 5 + 345 -89</li> <li>源文件使用utf-8编码</li> <li>行宽度不要超过80字符</li> <li>代码编写次行风格和行尾风格</li></ol> <h5 id="dos命令"><a href="#dos命令" class="header-anchor">#</a> DOS命令</h5> <ul><li><p>md 文件路径\\文件名称——创建文件</p></li> <li><p>rd 文件路径\\文件名称——删除文件</p></li> <li><p>dir 查看当前目录的内容</p></li> <li><p>cd</p> <ul><li>cd /D c: 切换到其他盘下</li> <li>cd d:\abc2\test200 切换到当前盘的其他目录下</li> <li>cd .. 切换到上一级</li> <li>cd \ 切换到根目录</li></ul></li> <li><p>tree 查看指定的目录下 的所有子级目录</p></li> <li><p>cls 清屏</p></li> <li><p>exit 退出DOS</p></li> <li><p>copy 拷贝文件</p></li> <li><p>del 删除文件</p></li> <li><p>echo 输入内容到文件</p></li> <li><p>type 显示文本文件的内容</p></li> <li><p>move 剪切</p></li></ul> <h3 id="变量"><a href="#变量" class="header-anchor">#</a> 变量</h3> <p>变量是程序的基本组成单位</p> <p>基本要素：类型、名称、值</p> <ul><li><p>概念：变量相当于内存中一个数据存储空间的表示</p></li> <li><p>使用步骤：也可以<code>int a = 60;</code></p> <ul><li>声明变量 <code>int a;</code></li> <li>赋值 <code>a = 60;</code></li> <li>使用 <code>System.out.println(a);</code></li></ul></li> <li><p>注意事项</p> <ul><li>变量表示内存中的一个存储区域【不同的变量，类型不同，占用的空间大小不同】</li> <li>该区域有自己的名称【变量名】和类型【数据类型】</li> <li>变量必须先声明，后使用，即有顺序</li> <li>该区域的数据可以在同一类型范围内不断变化</li> <li>变量在同一个作用域内不能重名</li> <li>变量 = 变量名 + 值 + 数据类型</li></ul></li> <li><p>加号的使用</p> <ul><li>当左右两边都是数值型时，则做加法运算</li> <li>当左右两边有一方为字符串时，则做拼接运算</li> <li>运算顺序，是从左到右</li></ul></li></ul> <h4 id="数据类型"><a href="#数据类型" class="header-anchor">#</a> 数据类型</h4> <ol><li>Java数据类型分为两大类：基本数据类型和引用数据类型</li> <li>基本数据类型有8种：数值型[byte,short,int,long,float,double],char,boolean</li> <li>引用类型[类，接口，数组]</li></ol> <ul><li><p>整数类型细节</p> <ul><li>Java各整数类型有固定的范围和字段长度，不受具体OS【操作系统】的影响，以保证java程序的可移植性</li> <li>Java的整型常量默认为int型，声明long型常量须后加'|'或'L'</li> <li>Java程序中变量常声明为int型，除非不足以表示大数，才使用long</li> <li>bit：计算机中的最小存储单元。byte：计算机中基本存储单元，1byte = 8bit</li> <li>当把一个具体的数赋给byte时，先判断该数是否在byte范围内，如果是就可以</li></ul></li> <li><p>浮点类型</p> <ul><li>关于浮点数在机器中存放形式的简单说明，浮点数 = 符号位 + 指数位 + 尾数位</li> <li>尾数部分可能丢失，造成精度损失(小数都是近似值)</li></ul></li> <li><p>浮点类型细节</p> <ul><li>与整数类型类型，Java浮点类型也有固定的范围和字段长度，不受具体OS的影响。</li> <li>Java的浮点型常量默认为double型，声明float型常量，须后加'f'或'F'</li> <li>浮点型常量有两种表示形式
<ul><li>十进制数形式：如 5.12   512.0f   .512</li> <li>科学计数法形式：如 5.12e2[5.12*10的2次方]   5.12E-2[5.12/10的2次方]</li></ul></li> <li>通常情况下，应该使用double型，因为它比float型更精确</li> <li>浮点数使用陷阱：2.7和8.1/3比较<strong>对运算结果是小数的进行相等判断时，要小心，应该是以两个数的差值的绝对值，在某个精度范围内判断</strong></li></ul></li> <li><p>字符类型细节</p> <ul><li>字符常量是用单引号括起来 的单个字符</li> <li>Java中还允许使用转义字符'\'来将其后的字符转变为特殊字符型常量</li> <li>在Java中，char的本质是一个整数，在输出时，是unicode码对应的字符</li> <li>可以直接给char赋一个整数，然后输出时，会按照对应的unicode字符输出</li> <li>char类型是可以进行运算的，相当于一个整数，因为它都对应有Unicode码</li></ul></li> <li><p>字符编码表</p> <ul><li>ASCII</li> <li>Unicode：固定大小的编码，使用两个字节表示字符，汉字和字母统一都是占用两个字节</li> <li>utf-8：大小可变的编码，字母使用1个字节，汉字使用3个字节</li> <li>gbk：字母使用1个字节，汉字使用2个字节</li> <li>gb2312：gb2312&lt;gbk</li> <li>big5:繁体中文，台湾，香港</li></ul></li> <li><p>布尔类型</p> <ul><li>只占1个字节</li> <li>不可以使用0或非0的整数替代false和true，这点和C语言不同</li></ul></li></ul> <h4 id="数据类型转换"><a href="#数据类型转换" class="header-anchor">#</a> 数据类型转换</h4> <ul><li><p>自动类型转换</p> <ul><li>当Java程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数据类型，这个就是自动类型转换</li> <li>从小到大（char，int，long，float，double）（byte，short，int，long，float，double）</li></ul></li> <li><p>自动类型转换细节</p> <ul><li>有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算</li> <li>当我们把精度(容量)大的数据类型赋值给精度(容量)小的数据类型时，就会报错，反之就会进行自动类型转换</li> <li>(byte，short)和char之间不会相互自动转换</li> <li>byte，short，char他们三者可以计算，在计算时首先转换为int类型</li> <li>boolean不参与转换</li> <li>自动提升原则：表达式结果的类型自动提升为操作数中最大的类型</li></ul></li> <li><p>强制类型转换</p> <ul><li>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符()，但可能造成精度降低或溢出，格外要注意</li></ul></li> <li><p>强制类型转换细节</p> <ul><li>当进行数据从大到小，就需要使用到强制转换</li> <li>强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级</li> <li>char类型可以保存int的常量值，但不能保存int的变量值，需要强转</li> <li>byte和short类型在进行运算时，当做int类型处理</li></ul></li> <li><p>String数据类型与基本数据类型转换</p> <ul><li>基本类型转String类型：将基本类型的值+&quot;&quot;即可</li> <li>String类型转基本数据类型：通过基本类型的包装类调用parseXX方法即可<code>int num = Integer.parseInt(str);</code></li> <li>把字符串转成字符char：指把字符串的第一个字符得到<code>str.charAt(0)</code></li> <li>在将String类型转成基本数据类型 时，要确保String类型能够转成有效的数据，比如我们可以把&quot;123&quot;，转成一个整数，但是不能把&quot;hello&quot;转成一个整数</li> <li>如果格式不正确，就会抛出异常，程序就会终止，这个问题在异常处理章节中，会处理</li></ul></li></ul> <h3 id="运算符"><a href="#运算符" class="header-anchor">#</a> 运算符</h3> <p>运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等</p> <ol><li>算术运算符：是对数值类型的变量进行运算的，有+、-、/、%、++、--
<ol><li>%的本质是a % b = a - (a / b) * b</li> <li>有小数运算时，得到的结果是近似值</li></ol></li> <li>赋值运算符：就是将某个运算后的值，赋给指定的变量，有=、+=、-=、*=、/=、%=
<ol><li>运算顺序从右往左</li> <li>赋值运算符的左边只能是变量，右边可以是变量、表达式、常量值</li> <li>复合赋值运算符等价于下面的效果</li> <li>复合赋值运算符会进行类型转换</li></ol></li> <li>关系运算符【比较运算符】：结果都是boolean型，经常用在if结构的条件中或循环结构的条件中，如==、!=、&lt;、&gt;、&lt;=、&gt;=、instanceof
<ol><li>关系运算符的结果都是boolean型，也就是要么是true，要么是false</li> <li>关系运算符 组成的表达式，我们称为关系表达式</li> <li>比较运算符&quot;==&quot;不能误写成&quot;=&quot;</li></ol></li> <li>逻辑运算符：用于连接多个条件（多个关系表达式），最终结果也是一个boolean值，有短路与&amp;&amp;、短路或||、取反!、逻辑与&amp;、逻辑或|、逻辑异或^
<ol><li>&amp;&amp;和&amp;的区别：&amp;&amp;短路与中如果第一个条件为false，则第二个条件不会判断，最终结果为false；&amp;逻辑与中不管第一个条件是否为false，第二个条件都要判断</li> <li>||和|的区别：||短路或中如果第一个条件为true，则第二个条件不会判断，最终结果为true；|逻辑或中不管第一个条件是否为true，第二个条件都要判断</li> <li>逻辑异或a^b：当a和b不同时，则结果为true，否则为false</li></ol></li> <li>位运算符</li> <li>三元运算符：条件表达式?表达式1:表达式2
<ol><li>如果条件表达式为true，运算后的结果是表达式1</li> <li>如果条件表达式结果为false，运算后的结果是表达式2</li> <li>表达式1和表达式2要为可以赋给接收变量的类型（或可以自动转换）</li> <li>三元运算符可以转成if--else语句</li> <li>三元运算符是一个整体</li></ol></li></ol> <p>优先级</p> <ul><li>运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序</li> <li>只有单目运算符、赋值运算符是从右向左运算的</li> <li>优先级排序大致
<ul><li>()，{}等</li> <li>单目运算符</li> <li>算术运算符</li> <li>位移运算符</li> <li>比较运算符</li> <li>逻辑运算符</li> <li>三元运算符</li> <li>赋值运算符</li></ul></li></ul> <h4 id="标识符"><a href="#标识符" class="header-anchor">#</a> 标识符</h4> <p>概念</p> <ul><li>Java对各种变量、方法和类等命名时使用的字符序列称为标识符</li> <li>凡是自己可以起名字的地方都叫标识符</li></ul> <p>命名规则（必须遵守）</p> <ul><li>由26个英文字母大小写，0-9，_或$组成</li> <li>数字不可以开头</li> <li>不可以使用关键字和保留字，但能包含关键字和保留字</li> <li>Java中严格区分大小写，长度无限制</li> <li>标识符不能包含空格</li></ul> <p>命名规范（更加专业）</p> <ul><li>包名：多单词组成时所有字母都小写</li> <li>类名、接口名：多单词组成时，所有单词的首字母大写</li> <li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写</li> <li>常量名：所有字母都大写，多单词时每个单词用下划线连接</li></ul> <h4 id="键盘输入语句"><a href="#键盘输入语句" class="header-anchor">#</a> 键盘输入语句</h4> <p>介绍</p> <p>在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。需要一个扫描器（对象），就是Scanner</p> <p>步骤</p> <ul><li>导入该类的所在包 java.util.*</li> <li>创建该类对象（声明变量）</li> <li>调用里面的功能</li></ul> <p><code>Scanner myScanner = new Scanner(System.in)</code></p> <h4 id="二进制"><a href="#二进制" class="header-anchor">#</a> 二进制</h4> <ul><li>二进制是逢2进位的进位制，0、1是基本算符</li> <li>现代的电子计算机技术全部采用的是二进制，因为它只使用0、1两个数字符号，非常简单方便，易于用电子方式实现，计算机内部处理的信息，都是采用二进制数来表示的，二进制数用0和1两个数字及其组合来表示任何数。进位的规则是“逢2进1”，数字1在不同的位上代表不同的值，按从右至左的次序，这个值以二倍递增。</li></ul> <h5 id="原码、反码、补码"><a href="#原码、反码、补码" class="header-anchor">#</a> 原码、反码、补码</h5> <ol><li>二进制的最高位是符号位：0表示正数，1表示负数</li> <li>正数的原码，反码，补码都一样（三码合一）</li> <li>负数的反码=它的原码符号位不变，其它位取反</li> <li>负数的补码=它的反码+1，负数的反码=负数的补码-1</li> <li>0的反码，补码都是0</li> <li>java没有无符号数，换言之，java中的数都是有符号的</li> <li>在计算机运算的时候，都是以补码的方式来运算的</li> <li>当我们看运算结果的时候，要看他的原码</li></ol> <h5 id="位运算"><a href="#位运算" class="header-anchor">#</a> 位运算</h5> <ul><li>按位与&amp;：两位全为1，结果为1，否则为0</li> <li>按位或|：两位有一个为1，结果为1，否则为0</li> <li>按位异或^：两位一个为0，一个为1，结果为1，否则为0</li> <li>按位取反~：0-&gt;1，1-&gt;0</li> <li>算术右移&gt;&gt;：低位溢出，符号位不变，并用符号位补溢出的高位</li> <li>算术左移&lt;&lt;：符号位不变，低位补0</li> <li>逻辑右移&gt;&gt;&gt;也叫无符号右移，运算规则是：低位溢出，高位补0</li> <li>特别说明：没有&lt;&lt;&lt;符号</li></ul> <h3 id="控制结构"><a href="#控制结构" class="header-anchor">#</a> 控制结构</h3> <h4 id="流程控制"><a href="#流程控制" class="header-anchor">#</a> 流程控制</h4> <ul><li><p>顺序控制：程序从上到下逐行地执行，中间没有任何判断和跳转</p></li> <li><p>分支控制</p> <ul><li><p>单分支</p> <p>基本语法：</p> <p><code>if(条件表达式){</code></p> <p>​	<code>执行代码块;(可以有多条语句。)</code></p> <p><code>}</code></p> <p>说明：当条件表达式为true时，就会执行{}的代码。如果为false，就不执行。特别说明，如果{}中只有一条语句，则可以不用{}，建议写上{}</p></li> <li><p>双分支</p> <p>基本语法：</p> <p><code>if(条件表达式){</code></p> <p>​	<code>执行代码块1;</code></p> <p><code>}else{</code></p> <p>​	<code>执行代码块2;</code></p> <p><code>}</code></p> <p>说明：当条件表达式成立，即执行代码块1，否则执行代码块2。如果执行代码块只有一条语句，则{}可以省略，否则，不能省略。</p></li> <li><p>多分支</p> <p>基本语法：</p> <p><code>if(条件表达式1){</code></p> <p>​	<code>执行代码块1;</code></p> <p><code>}else if(条件表达式2){</code></p> <p>​	<code>执行代码块2;</code></p> <p><code>}</code></p> <p><code>......</code></p> <p><code>else{</code></p> <p>​	<code>执行代码块n;</code></p> <p><code>}</code></p> <p>说明：</p> <ol><li>当条件表达式1成立时，即执行代码块1</li> <li>如果表达式1不成立，才去判断表达式2是否成立</li> <li>如果表达式2成立，就执行代码块2</li> <li>以此类推，如果所有的表达式都不成立</li> <li>则执行else的代码块，注意，只能有一个执行入口</li> <li>多分支可以没有else，如果所有的条件表达式都不成立，则一个执行入口都没有</li> <li>如果有else，如果所有的条件表达式都不成立，则默认执行else代码块</li></ol></li> <li><p>嵌套分支</p> <p>基本介绍：在一个分支结构中又完整的嵌套了另一个完整的分支结构，里面的分支的结构称为内分支外面的分支结构称为外层分支。规范：不要超过3层（可读性不好）</p> <p>基本语法</p> <p><code>if(){</code></p> <p>​	<code>if(){</code></p> <p>​		<code>//if-else</code></p> <p>​	<code>}else{</code></p> <p>​		<code>//if-else</code></p> <p>​	<code>}</code></p> <p><code>}</code></p></li> <li><p>switch分支结构</p> <p>基本语法</p> <p><code>switch(表达式){</code></p> <p>​	<code>case 常量1:语句块1;break;</code></p> <p>​	<code>case 常量2:语句块2;break;</code></p> <p>​	<code>...</code></p> <p>​	<code>case 常量n:语句块n;break;</code></p> <p>​	<code>default:default语句块;break;</code></p> <p><code>}</code></p> <p>说明：</p> <ol><li>switch关键字，表示switch分支</li> <li>表达式对应一个值</li> <li>case 常量1:当表达式的值等于常量1，就执行语句块1</li> <li>break：表示退出switch</li> <li>如果和case 常量 1匹配，就执行语句块1，如果没有匹配，就继续匹配case 常量2</li> <li>如果一个都没有匹配上，执行default</li></ol> <p>switch注意事项与细节讨论</p> <ol><li>表达式数据类型，应和case后的常量类型一致，或者是可以自动转成可以相互比较的类型，比如输入的是字符，而常量是int</li> <li>switch(表达式)中表达式的返回值必须是：(byte,short,int,char,enum,String)</li> <li>case子句中的值必须是常量，而不能是变量</li> <li>default子句是可选的，当没有匹配的case时，执行default</li> <li>break语句用来执行完一个case分支后使程序跳出switch语句块；如果没有写break，程序会顺序执行到switch结尾</li></ol></li></ul></li> <li><p>循环控制</p> <ul><li><p>for循环控制</p> <p>基本介绍：就是让你的代码可以循环的执行</p> <p>基本语法</p> <p><code>for(循环变量初始化;循环条件;循环变量迭代){循环操作(可以多条语句);}</code></p> <p>说明</p> <ol><li>for关键字，表示循环控制</li> <li>for有四要素：循环变量初始化；循环条件；循环操作；循环变量迭代</li> <li>循环操作，这里可以有多条语句，也就是我们要循环执行的代码</li> <li>如果循环操作只有一条语句，可以省略{}，建议不要省略</li></ol> <p>注意事项和细节说明</p> <ol><li>循环条件是返回一个布尔值的表达式</li> <li>for(;循环判断条件;)中的初始化和变量迭代可以写到其它地方，但是两边的分号不能省略</li> <li>循环初始值可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开</li></ol> <p>编程思想</p> <ol><li>化繁为简：即将复杂的需求，拆解成简单的需求，逐步完成</li> <li>先死后活：先考虑固定的值，然后转成可以灵活变化的值</li></ol></li> <li><p>while循环控制</p> <p>基本语法</p> <p><code>循环变量初始化;</code></p> <p><code>while(循环条件){</code></p> <p>​	<code>循环体(语句);</code></p> <p>​	<code>循环变量迭代;</code></p> <p><code>}</code></p> <p>说明</p> <ol><li>while循环也有四要素</li> <li>只是四要素放的位置，不一样</li></ol></li> <li><p>do...while循环控制</p> <p>基本语法</p> <p><code>循环变量初始化;</code></p> <p><code>do{</code></p> <p>​	<code>循环体(语句);</code></p> <p>​	<code>循环变量迭代;</code></p> <p><code>}while(循环条件);</code></p> <p>说明</p> <ol><li>do while是关键字</li> <li>也有循环四要素，只是位置不一样</li> <li>先执行，再判断，也就是说，一定会执行一次</li> <li>最后有一个分号;</li> <li>while和do...while区别举例：要账</li></ol> <p>注意事项和细节说明</p> <ol><li>循环条件是返回一个布尔值的表达式</li> <li>do...while循环是先执行，再判断，因此它至少执行一次</li></ol></li> <li><p>多重循环控制</p> <p>介绍</p> <ol><li>将一个循环放在另一个循环体内，就形成了嵌套循环。其中，for，while，do...while均可以作为外层循环和内层循环。【建议一般使用两层，最多不要超过3层，否则，代码的可读性很差】</li> <li>实质上，嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环 的循环条件为false时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的循环【听不懂，走案例】</li> <li>设外层循环次数为m次，内层为n次，则内层循环体实际上需要执行m*n次</li></ol></li> <li><p>跳转控制语句break</p> <p>基本介绍：break语句用于终止某个语句块的执行，一般使用在switch或者循环中</p> <p>基本语法：</p> <p><code>{</code></p> <p>​	<code>......</code></p> <p>​	<code>break;</code></p> <p>​	<code>......</code></p> <p><code>}</code></p> <p>注意事项和细节说明</p> <ol><li><p>break语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是哪一层语句块</p></li> <li><p>标签的基本使用</p> <p><code>label1:{......</code></p> <p><code>label2:	{......</code></p> <p><code>label3:		{......</code></p> <p>​			<code>break label2;</code></p> <p>​			<code>......</code></p> <p>​		<code>}</code></p> <p>​	<code>}</code></p> <p><code>}</code></p> <ol><li>break语句可以指定退出哪层</li> <li>label1是标签，由程序员指定</li> <li>break后指定到哪个label就退出到哪里</li> <li>在实际的开发中，尽量不要使用标签</li> <li>如果没有指定break，默认退出最近的循环体</li></ol></li></ol></li> <li><p>跳转控制语句continue</p> <p>基本介绍</p> <ol><li>continue语句用于结束本次循环，继续执行下一次循环</li> <li>continue语句出现多层嵌套的循环语句体中，可以通过标签指明要跳过的是哪一层循环，这个和前面的标签的 使用的规则一样</li></ol> <p>基本语法</p> <p><code>{</code></p> <p>​	<code>......</code></p> <p>​	<code>continue;</code></p> <p>​	<code>......</code></p> <p><code>}</code></p></li> <li><p>跳转控制语句return</p> <p>介绍：return使用在方法，表示跳出所在的方法</p> <p>注意：如果return写在main方法，退出程序</p></li></ul></li></ul> <h3 id="数组、排序和查找"><a href="#数组、排序和查找" class="header-anchor">#</a> 数组、排序和查找</h3> <h4 id="数组"><a href="#数组" class="header-anchor">#</a> 数组</h4> <p>数组介绍：数组可以存放多个同一类型的数据。数组也是一种数据类型，是引用类型。即：数组就是一组数据</p> <h5 id="数组的使用"><a href="#数组的使用" class="header-anchor">#</a> 数组的使用</h5> <ul><li><p>使用方式1-动态初始化</p> <ul><li><p>数组的定义：</p> <p>数据类型 数组名[] = new 数据类型[大小]  或者  数据类型[] 数组名 = new 数据类型[大小]</p> <p><code>int a[] = new int[5];	//创建了一个数组，名字a，存放5个int</code></p> <p>说明：这是定义数组的一种方法。</p></li> <li><p>数组的引用：数组名[下标/索引]，数组的下标从0开始。比如：你要使用a数组的第3个数  a[2]</p></li></ul></li> <li><p>使用方式2-动态初始化</p> <ul><li><p>先声明数组</p> <p>语法：数据类型 数组名[];  也可以  数据类型[] 数组名;</p> <p><code>int a[]; 或者 int[] a;</code></p></li> <li><p>创建数组</p> <p>语法：数组名 = new 数据类型[大小];</p> <p><code>a = new int[10];</code></p></li></ul></li> <li><p>使用方式3-静态初始化</p> <ul><li><p>初始化数组</p> <p>语法：数据类型 数组名[] = {元素值，元素值，...}</p> <p><code>int a[] = {2, 5, 6, 7, 8, 89, 90, 34, 56}</code></p></li></ul></li> <li><p>数组的使用注意事项和细节</p> <ol><li>数组是多个相同类型数据的组合，实现对这些数据的统一管理</li> <li>数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用</li> <li>数组创建后，如果没有赋值，有默认值。int 0，short 0，byte 0，long 0，float 0，double 0.0，char \u0000，boolean false，String null</li> <li>使用数组的步骤：(1)声明数组并开辟空间 (2)给数组各个元素赋值 (3)使用数组</li> <li>数组的下标是从0开始的</li> <li>数组下标必须在指定范围内使用，否则报：下标越界异常，比如<code>int[] arr = new int[5]; //则有效下标为0-4</code></li> <li>数组属引用类型，数组型数据是对象(object)</li></ol></li></ul> <h5 id="数组赋值机制"><a href="#数组赋值机制" class="header-anchor">#</a> 数组赋值机制</h5> <ol><li><p>基本数据类型赋值，这个值就是具体的数据，而且相互不影响</p> <p><code>int n1 = 2;</code></p> <p><code>int n2 = n1;</code></p></li> <li><p>数组在默认情况下是引用传递，赋的值是地址</p></li></ol> <h5 id="数组添加"><a href="#数组添加" class="header-anchor">#</a> 数组添加</h5> <p>要求：实现动态的给数组添加元素效果，实现对数组扩容</p> <ol><li>原始数组使用静态分配<code>int[] arr = {1, 2, 3}</code></li> <li>增加的元素，直接放在数组的最后<code>arr = {1, 2, 3, 4}</code></li> <li>用户可以通过如下方法来决定是否继续添加，添加成功，是否继续？y/n</li></ol> <h4 id="排序"><a href="#排序" class="header-anchor">#</a> 排序</h4> <h5 id="排序的介绍"><a href="#排序的介绍" class="header-anchor">#</a> 排序的介绍</h5> <p>排序是将一群数据，依指定的顺序进行排列的过程</p> <p>分类</p> <ol><li>内部排序：指将需要处理的所有数据都加载到内部存储器中进行排序。包括（交换式排序法、选择式排序法和插入式排序法）；</li> <li>外部排序法：数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括（合并排序法和直接合并排序法）。</li></ol> <h5 id="冒泡排序"><a href="#冒泡排序" class="header-anchor">#</a> 冒泡排序</h5> <p>基本思想：通过对待排序序列从后向前（从下标较大的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就像水底下的气泡一样逐渐向上冒</p> <p>特点：</p> <ol><li>我们一共有5个元素</li> <li>一共进行了4轮排序，可以看成是外层循环</li> <li>每1轮排序可以确定一个数的位置，比如第1轮排序确定最大数，第2轮排序确定第2大的数位置，依次类推</li> <li>当进行比较时，如果前面的数大于后面的数，就交换</li> <li>每轮比较在减少4-&gt;3-&gt;2-&gt;1</li></ol> <h4 id="查找"><a href="#查找" class="header-anchor">#</a> 查找</h4> <p>介绍：在java中，我们常用的查找有两种：</p> <ol><li>顺序查找</li> <li>二分查找</li></ol> <h4 id="二维数组"><a href="#二维数组" class="header-anchor">#</a> 二维数组</h4> <ul><li><p>使用方式1：动态初始化</p> <ol><li>语法：类型[][] 数组名 = new 类型[大小][大小]</li> <li>比如：<code>int a[][] = new int[2][3]</code></li></ol></li> <li><p>使用方式2：动态初始化</p> <ol><li>先声明：类型 数组名[][];</li> <li>再定义（开辟空间）数组名 = new 类型[大小][大小];</li> <li>赋值（有默认值，比如int类型的就是0）</li></ol></li> <li><p>使用方式3：动态初始化-列数不确定</p> <ol><li>看需求：动态创建二维数组，并输出</li></ol></li> <li><p>使用方式4：静态初始化</p> <ol><li>定义：类型 数组名[][] = \{{值1,值2...},{值1,值2...},{值1,值2...}\}</li></ol> <blockquote><p>备注：需要去除反斜杠来看，否则会报错，页面无法显示</p></blockquote> <ol start="2"><li>使用即可[固定方式访问]</li></ol></li> <li><p>使用细节和注意事项</p> <ol><li>声明方式：<code>int[][] y</code>或者<code>int[] y[]</code>或者<code>int y[][]</code></li> <li>二维数组实际上是由多个一维数组组成的，它的各个一维数组的长度可以相同，也可以不同</li></ol></li></ul> <h3 id="面向对象编程-基础"><a href="#面向对象编程-基础" class="header-anchor">#</a> 面向对象编程（基础）</h3> <h4 id="类与对象"><a href="#类与对象" class="header-anchor">#</a> 类与对象</h4> <ul><li><p>使用现有技术解决</p> <ol><li>单独的定义变量解决</li> <li>使用数组解决</li></ol></li> <li><p>现有技术解决的缺点分析</p> <ul><li>不利于数据的管理</li> <li>效率低==》引出我们的新知识点-类与对象、哲学、道家</li> <li>java设计者引入类与对象（OOP），根本原因就是现有的技术，不能完美的解决新的需求</li></ul></li> <li><p>类与对象的关系</p> <ul><li>类就是数据类型</li> <li>对象就是一个具体的实例</li></ul></li> <li><p>类与对象的区别与联系</p> <ul><li>类是抽象的，概念的，代表一类事物，即它是数据类型</li> <li>对象是具体的，实际的，代表一个具体事物，即实例</li> <li>类是对象的模板，对象是类的一个个体，对应一个实例</li></ul></li> <li><p>属性/成员变量</p> <ul><li><p>基本介绍</p> <ol><li>从概念或叫法上看：成员变量 = 属性 = field（字段）（即成员变量是用来表示属性的，授课中，统一叫属性）</li> <li>属性是类的一个组成部分，一般是基本数据类型，也可是引用类型（对象，数组）</li></ol></li> <li><p>注意事项和细节说明</p> <ol><li><p>属性的定义语法同变量，示例：访问修饰符 属性类型 属性名；</p> <p>修饰符：控制属性的访问范围：public，proctected，default，private</p></li> <li><p>属性的定义类型可以为任意类型，包含基本类型或引用类型</p></li> <li><p>属性如果不赋值，有默认值，规则和数组一致</p></li></ol></li></ul></li> <li><p>创建对象</p> <ol><li><p>先声明再创建</p> <p><code>Cat cat;</code></p> <p><code>cat = new Cat();</code></p></li> <li><p>直接创建</p> <p><code>Cat cat = new Cat();</code></p></li></ol></li> <li><p>访问属性</p> <p>基本语法：对象名.属性名;</p></li> <li><p>类和对象的内存分配机制</p> <ul><li><p>Java内存的结构分析</p> <ol><li>栈：一般存放基本数据类型（局部变量）</li> <li>堆：存放对象（Cat cat，数组等）</li> <li>方法区：常量池（常量，比如字符串），类加载信息</li> <li>示意图[Cat(name,age,price)]</li></ol></li> <li><p>Java创建对象的流程简单分析</p> <ol><li>先加载Person类信息（属性和方法信息，只会加载一次）</li> <li>在堆中分配空间，进行默认初始化（看规则）</li> <li>把地址赋给p，p就指向对象</li> <li>进行指定初始化，比如 <code>p.name = &quot;jack&quot;</code></li></ol></li></ul></li></ul> <h4 id="成员方法"><a href="#成员方法" class="header-anchor">#</a> 成员方法</h4> <ul><li><p>基本介绍：在某些情况下，我们需要定义成员方法（简称方法）。比如人类：除了有一些 属性外（年龄，姓名...），我们人类还有一些行为比如：可以说话、跑步...，通过学习，还可以做算术题。这时就要用成员方法才能完成</p></li> <li><p>方法调用小结</p> <ol><li>当程序执行到方法时，就会开辟一个独立的空间（栈空间）</li> <li>当方法执行完毕，或者执行到return语句时，就会返回</li> <li>返回到调用方法的地方</li> <li>返回后，继续执行方法后面的代码</li> <li>当main方法（栈）执行完毕，整个程序退出</li></ol></li> <li><p>成员方法的好处</p> <ul><li>提高代码的复用性</li> <li>可以将实现的细节封装起来，然后供其他用户来调用即可</li></ul></li> <li><p>成员方法的定义</p> <p><code>public 返回数据类型 方法名(参数列表...){//方法体</code></p> <p><code>语句;</code></p> <p><code>return 返回值;</code></p> <p><code>}</code></p> <ol><li>参数列表：表示成员方法输入cal(int n)</li> <li>数据类型（返回类型）：表示成员方法输出，void表示没有返回值</li> <li>方法主体：表示为了实现某一功能代码块</li> <li>return语句不是必须的</li> <li>老韩提示：结合前面的题示意图，来理解</li></ol></li> <li><p>注意事项和使用细节</p> <ul><li>修饰符（作用是控制方法使用的范围）（有四种：public，protected，默认，private）</li> <li>返回类型
<ol><li>一个方法最多有一个返回值</li> <li>返回类型可以为任意类型，包含基本类型或引用类型（数组，对象）</li> <li>如果方法要求有返回数据类型，则方法体中最后的执行语句必须为return；而且要求返回值类型必须和return的值类型一致或兼容</li> <li>如果方法是void，则方法体中可以没有return语句，或者只写return</li></ol></li> <li>方法名：遵循驼峰命名法，最好见名知义</li> <li>参数列表
<ol><li>一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开，比如<code>getSum(int n1, int n2)</code></li> <li>参数类型可以为任意类型，包含基本类型或引用类型</li> <li>调用带参的方法时，一定对应着参数列表传入相同类型或兼容类型的参数</li> <li>方法定义时的参数称为形式参数，简称形参；方法调用时的参数称为实际参数，简称实参，实参和形参的类型要一致或兼容、个数、顺序必须一致</li></ol></li> <li>方法体：里面写完成功能的具体的语句，可以为输入、输出、变量、运算、分支、循环、方法调用，但里面不能再定义方法！即：方法不能嵌套定义</li> <li>方法细节调用说明
<ol><li>同一个类中的方法调用：直接调用即可</li> <li>跨类中的方法A类调用B类方法：需要通过对象名调用。比如 对象名.方法名(参数);</li> <li>特别说明：跨类的方法调用和方法的访问修饰符相关</li></ol></li></ul></li> <li><p>成员方法传参机制</p> <ul><li><p>基本数据类型的传参机制：基本数据类型，传递的是值（值拷贝），形参的任何改变不影响实参！</p></li> <li><p>引用数据类型的传参机制：引用类型传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参！</p></li></ul></li> <li><p>方法递归调用</p> <p>基本介绍：简单的说：递归就是方法自己调用自己，每次调用时传入不同的变量。递归有助于编程者解决复杂问题，同时可以让代码变得简洁。</p> <p>解决的问题</p> <ol><li>各种数学问题如：8皇后问题，汉诺塔，阶乘问题，迷宫问题，球和篮子的问题（google编程大赛）</li> <li>各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等</li> <li>将用栈解决的问题--&gt;递归代码比较简洁</li></ol></li> <li><p>递归重要规则</p> <ol><li>执行一个方法时，就创建一个新的受保护的独立空间（栈空间）</li> <li>方法的局部变量是独立的，不会相互影响，比如n变量</li> <li>如果方法中使用的是引用类型变量（比如数组），就会共享该引用类型的数据</li> <li>递归必须向退出递归的条件逼近，否则就是无限递归，出现StackOverflowError，死龟了:）</li> <li>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕</li></ol></li></ul> <h4 id="重载-overload"><a href="#重载-overload" class="header-anchor">#</a> 重载（overload）</h4> <ul><li>基本介绍：Java中允许同一个类中，多个同名方法的存在，但要求形参列表不一致！比如：<code>System.out.println();</code>out是PrintStream类型</li> <li>好处
<ol><li>减轻了起名的麻烦</li> <li>减轻了记名的麻烦</li></ol></li> <li>注意事项和使用细节
<ol><li>方法名：必须相同</li> <li>形参列表：必须不同（形参类型或个数或顺序，至少有一样不同，参数名无要求）</li> <li>返回类型：无要求</li></ol></li></ul> <h4 id="可变参数"><a href="#可变参数" class="header-anchor">#</a> 可变参数</h4> <ul><li><p>基本概念：Java允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法</p></li> <li><p>基本语法</p> <p><code>访问修饰符 返回类型 方法名(数据类型...形参名){}</code></p> <p>使用可变参数时，可以当作数组来使用</p></li> <li><p>注意事项和使用细节</p> <ol><li>可变参数的实参可以为0个或任意多个</li> <li>可变参数的实参可以为数组</li> <li>可变参数的本质就是数组</li> <li>可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后</li> <li>一个形参列表中只能出现一个可变参数</li></ol></li></ul> <h4 id="作用域"><a href="#作用域" class="header-anchor">#</a> 作用域</h4> <ul><li><p>基本使用</p> <ol><li><p>在Java编程中，主要的变量就是属性（成员变量）和局部变量</p></li> <li><p>我们说的局部变量一般是指在成员方法中定义的变量</p></li> <li><p>Java中作用域的分类</p> <p>全局变量：也就是属性，作用域为整个类体</p> <p>局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中！</p></li> <li><p>全局变量可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值</p></li></ol></li> <li><p>注意事项和细节说明</p> <ol><li><p>属性和局部变量可以重名，访问时遵循就近原则</p></li> <li><p>在同一个作用域中，比如在同一个成员方法中，两个局部变量，不能重名</p></li> <li><p>属性生命周期较长，伴随着对象的创建而创建，伴随着对象的死亡而死亡。局部变量，生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而死亡。即在一次方法调用过程中。</p></li> <li><p>作用域不同</p> <p>全局变量：可以被本类使用，或其他类使用（通过对象调用）</p> <p>局部变量：只能在本类中对应的方法中使用</p></li> <li><p>修饰符不同</p> <p>全局变量/属性可以加修饰符</p> <p>局部变量不可以加修饰符</p></li></ol></li></ul> <h4 id="构造器"><a href="#构造器" class="header-anchor">#</a> 构造器</h4> <ul><li><p>基本语法</p> <p><code>[修饰符] 方法名(形参列表){</code></p> <p>​	<code>方法体;</code></p> <p><code>}</code></p></li> <li><p>说明</p> <ol><li>构造器的修饰符可以默认</li> <li>构造器没有返回值</li> <li>方法名和类名字必须一样</li> <li>参数列表和成员方法一样的规则</li> <li>构造器的调用由系统完成</li></ol></li> <li><p>基本介绍</p> <p>构造方法又叫构造器（constructor），是类的一种特殊的方法，它的主要作用是完成对新对象的初始化</p> <p>特点：</p> <ol><li>方法名和类名相同</li> <li>没有返回值</li> <li>在创建对象时，系统会自动的调用该类的构造器完成对对象的初始化</li></ol></li> <li><p>注意事项和使用细节</p> <ol><li>一个类可以定义多个不同的构造器，即构造器重载</li> <li>构造器名和类名要相同</li> <li>构造器没有返回值</li> <li>构造器是完成对象的初始化，并不是创建对象</li> <li>在创建对象时，系统自动的调用该类的构造方法</li> <li>如果程序员没有定义构造方法，系统会自动给类生成一个默认无参构造器（也叫默认构造器）</li> <li>一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下</li></ol></li> <li><p>反编译指令 <code>javap 文件名.class</code></p></li> <li><p>对象创建流程信息</p> <ol><li>加载Person类信息（Person.class），只会加载一次</li> <li>在堆中分配空间（地址）</li> <li>完成对象初始化【3.1 默认初始化-给类型默认初始值；3.2 显式初始化-<code>int age = 10;</code>；3.3 构造器的初始化】</li> <li>在对象在堆中的地址，返回给P（P是对象名，也可以理解成是对象的引用）</li></ol></li></ul> <h4 id="this"><a href="#this" class="header-anchor">#</a> this</h4> <ul><li>概念：Jav a虚拟机会给每个对象分配this，代表当前对象</li> <li>注意事项和使用细节
<ol><li>this关键字可以用来访问本类的属性、方法、构造器</li> <li>this用于区分当前类的属性和局部变量</li> <li>访问成员方法的语法：this.方法名(参数列表);</li> <li>访问构造器语法：this(参数列表);注意只能在构造器中使用（即只能在构造器中访问另外一个构造器，必须放在第一条语句）</li> <li>this不能在类定义的外部使用，只能在类定义的方法中使用</li></ol></li></ul> <h3 id="面向对象编程-中级"><a href="#面向对象编程-中级" class="header-anchor">#</a> 面向对象编程（中级）</h3> <h4 id="idea"><a href="#idea" class="header-anchor">#</a> IDEA</h4> <ul><li><p>IDEA的基本介绍和使用：IDEA是以项目的概念，来管理我们的java源码的</p></li> <li><p>常用快捷键</p> <ul><li>删除当前行，默认是 ctrl + Y，自己配置 ctrl + d</li> <li>复制当前行，自己配置 ctrl + alt + 向下光标</li> <li>补全代码 alt + /</li> <li>添加注释和取消注释 ctrl + /【第一次是添加注释，第二次是取消注释】</li> <li>导入该行需要的类，先配置auto import，然后使用 alt + enter 即可</li> <li>快速格式化代码 ctrl + alt + L</li> <li>快速运行程序，自己定义 alt + R</li> <li>生成构造方法等 alt + insert 【提高开发效率】</li> <li>查看一个类的层级关系 ctrl + H【学习继承后，非常有用】</li> <li>将光标放在一个方法上，输入 ctrl + B，可以选择定位到哪个类的方法【学继承后，非常有用】</li> <li>自动的分配变量名，通过在后面 .var</li></ul></li> <li><p>模板/自定义模板</p> <p>file -&gt; settings -&gt; editor -&gt; Live templates</p></li></ul> <h4 id="包"><a href="#包" class="header-anchor">#</a> 包</h4> <ul><li><p>三大作用</p> <ul><li>区分相同名字的类</li> <li>当类很多时，可以很好的管理类【看Java API文档】</li> <li>控制访问范围</li></ul></li> <li><p>基本语法</p> <p><code>package com.hspedu;</code></p> <ol><li>package关键字，表示打包</li> <li>com.hspedu：表示包名</li></ol></li> <li><p>包的本质：包实际上就是创建不同的文件夹来保存类文件</p></li> <li><p>包的命名</p> <p>命名规 则：只能包含数字、字母、下划线、小圆点，但不能是关键字或保留字</p> <p>命名规范：一般是小写字母 + 小圆点，一般是<code>com.公司名.项目名.业务逻辑块</code></p></li> <li><p>常用的包</p> <ul><li><code>java.lang.*</code>，lang包是基本包，默认引入，不需要再引入</li> <li><code>java.util.*</code>，util包，系统提供的工具包，工具类，使Scanner</li> <li><code>java.net.*</code>，网络包，网络开发</li> <li><code>java.awt.*</code>，是做java的界面开发，GUI</li></ul></li> <li><p>引入包：语法：<code>import 包;</code></p></li> <li><p>注意事项和使用细节</p> <ol><li>package 的作用是声明当前类所在的包，需要放在class 的最上面，一个类中最多只有一句package</li> <li>import 指令，位置放在package的下面，在类定义前面，可以有多句且没有顺序要求</li></ol></li></ul> <h4 id="访问修饰符"><a href="#访问修饰符" class="header-anchor">#</a> 访问修饰符</h4> <ul><li><p>基本介绍：java提供四种访问控制修饰符号控制方法和属性（成员变量）的访问权限（范围）</p> <ol><li>公开级别：用public修饰，对外公开</li> <li>受保护级别：用protected修饰，对子类和同一个包中的类公开</li> <li>默认级别：没有修饰符号，向同一个包的类公开</li> <li>私有级别：用private修饰，只有类本身可以访问，不对外公开</li></ol></li> <li><p>使用的注意事项</p> <ol><li>修饰符可以用来修饰类中的属性，成员方法以及类</li> <li>只有默认的和public才能修饰类！，并且遵循上述访问权限的特点</li> <li>成员方法的访问规则和属性完全一样</li></ol></li></ul> <h4 id="封装"><a href="#封装" class="header-anchor">#</a> 封装</h4> <p>面向对象编程三大特征：封装、继承和多态</p> <ul><li><p>介绍：封装就是把抽象出的数据【属性】和对数据的操作【方法】封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作【方法】，才能对数据进行操作</p></li> <li><p>封装的理解和好处</p> <ol><li>隐藏实现细节</li> <li>可以对数据进行验证，保证安全合理</li></ol></li> <li><p>封装实现步骤</p> <ol><li><p>将属性进行私有化【不能直接修改属性】</p></li> <li><p>提供一个公共的(public)set方法，用于对属性判断并赋值</p> <p><code>public void setXxx(类型 参数名){</code></p> <p>​	<code>属性 = 参数名;	//加入数据验证的业务逻辑</code></p> <p><code>}</code></p></li> <li><p>提供一个公共的(public)get方法，用于获取属性的值</p> <p><code>public XX getXxx(){//权限判断</code></p> <p>​	<code>return xx;</code></p> <p><code>}</code></p></li></ol></li></ul> <h4 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h4> <ul><li><p>基本介绍：继承可以解决代码复用，让我们的编程更加靠近人类思维，当多个类存在相同的属性（变量）和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过extends来声明继承父类即可</p></li> <li><p>基本语法</p> <p><code>class 子类 extends 父类{}</code></p> <ol><li>子类就会自动拥有父类定义的属性和方法</li> <li>父类又叫超类，基类</li> <li>子类又叫派生类</li></ol></li> <li><p>继承细节问题</p> <ol><li><p>子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问，但是私有属性和方法不能在子类直接访问，要通过公共的方法去访问</p></li> <li><p>子类必须调用父类的构造器，完成父类的初始化</p></li> <li><p>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过</p></li> <li><p>如果希望指定去调用父类的某个构造器，则显式的调用 一下super(参数列表)</p></li> <li><p>super在使用时，需要放在构造器第一行(super只能在构造器中使用)</p></li> <li><p>super()和this()都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</p></li> <li><p>java所有类都是Object类的子类，Object类是所有类的基类</p></li> <li><p>父类构造器的调用不限于直接父类！将一直往上追溯直到Object类（顶级父类）</p></li> <li><p>子类最多只能继承一个父类（指直接继承），即java中是单继承机制</p></li> <li><p>不能滥用继承 ，子类和父类之间必须满足is-a的逻辑关系</p> <p><code>Person is a Music?</code></p> <p><code>Person Music</code></p> <p><code>Music extends Person	// 不合理</code></p> <p><code>Animal</code></p> <p><code>Cat extends Animal	// 合理</code></p></li></ol></li> <li><p>继承本质：当子类对象创建好后，建立查找的关系</p></li></ul> <h4 id="多态"><a href="#多态" class="header-anchor">#</a> 多态</h4> <ul><li><p>基本介绍：方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。</p></li> <li><p>具体体现</p> <ol><li><p>方法的多态，重写和重载就体现多态</p></li> <li><p>对象的多态</p> <p>（1）一个对象的编译类型和运行类型可以不一致</p> <p>（2）编译类型在定义对象时，就确定了，不能改变</p> <p>（3）运行类型是可以变化的，通过getClass()来查看运行</p> <p>（4）编译类型看定义时 = 号的左边，运行类型看 = 号的右边</p></li></ol></li> <li><p>注意事项和细节讨论</p> <p>前提：两个对象（类）存在继承关系</p> <p>向上转型</p> <ol><li>本质：父类的引用指向了子类的对象</li> <li>语法：父类类型 引用名 = new 子类类型();</li> <li>特点：编译类型看左边，运行类型看右边。可以调用父类中的所有成员（需遵守访问权限），不能调用 子类中的特有成员；最终运行效果看子类的具体实现！</li></ol> <p>向下转型</p> <ol><li>语法：子类类型 引用名 = （子类类型） 父类引用;</li> <li>只能强转父类的引用，不能强转父类的对象</li> <li>要求父类的引用必须指向的是当前目标类型的对象</li> <li>当向下转型后， 可以调用子类类型中所有的成员</li></ol> <p>属性没有重写之说！属性的值看编译类型</p> <p>instanceof 比较操作符，用于判断对象的运行类型是否为XX类型或XX类型的子类型</p></li> <li><p>Java动态绑定机制</p> <ol><li>当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定</li> <li>当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用</li></ol></li> <li><p>多态的应用</p> <ol><li>多态数组：数组的定义类型为父类类型，里面保存的实际元素类型为子类类型</li> <li>多态参数：方法定义的形参类型为父类类型，实参类型允许为子类类型</li></ol></li></ul> <h4 id="super"><a href="#super" class="header-anchor">#</a> Super</h4> <ul><li><p>基本介绍：super代表父类的引用，用于访问父类的属性、方法、构造器</p></li> <li><p>基本语法</p> <ol><li>访问父类的属性，但不能访问父类的private属性<code>super.方法名(参数列表);</code></li> <li>访问父类的方法，不能访问父类的private方法<code>super.方法名(参数列表);</code></li> <li>访问父类的构造器：<code>super(参数列表);</code>只能放在构造器的第一句，只能出现一句！</li></ol></li> <li><p>super给编程带来的便利</p> <ol><li>调用父类的构造器的好处（分工明确，父类属性由父类初始化，子类的属性由子类初始化）</li> <li>当子类中有和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果！</li> <li>super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类（上级类）中都有同名的成员，使用super访问遵循就近原则</li></ol></li> <li><p>super和this的比较</p> <ol><li>访问属性：this访问本类中的属性，如果本类没有此属性则从父类中继续查找；super访问父类中的属性</li> <li>调用方法：this访问本类中的方法，如果本类没有此方法则从父类继续查找；super直接访问父类中的方法</li> <li>调用构造器：this调用本类构造器，必须放在构造器的首行；super调用父类构造器，必须放在子类构造器的首行</li> <li>特殊：this表示当前对象；super子类中访问父类对象</li></ol></li></ul> <h4 id="overwrite"><a href="#overwrite" class="header-anchor">#</a> overwrite</h4> <ul><li>基本介绍：方法覆盖就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这个方法覆盖了父类的那个方法</li> <li>注意事项和使用细节：方法重写也叫方法覆盖
<ol><li>子类的方法的参数，方法名称，要和父类方法的参数，方法名称完全一样</li> <li>子类方法的  返回类型和父类方法返回类型一样，或者是父类返回类型的子类</li> <li>子类方法不能缩小父类方法的访问权限</li></ol></li></ul> <table><thead><tr><th>名称</th> <th>发生范围</th> <th>方法名</th> <th>形参列表</th> <th>返回类型</th> <th>修饰符</th></tr></thead> <tbody><tr><td>重载(overload)</td> <td>本类</td> <td>必须一样</td> <td>类型，个数或者顺序至少有一个不同</td> <td>无需求</td> <td>无需求</td></tr> <tr><td>重写(override)</td> <td>父子类</td> <td>必须一样</td> <td>相同</td> <td>子类重写的方法，返回的类型和父类返回的类型一致，或者是其子类</td> <td>子类方法不能缩小父类方法的访问范围</td></tr></tbody></table> <h4 id="object类详解"><a href="#object类详解" class="header-anchor">#</a> Object类详解</h4> <ul><li><p>equals方法</p> <p>==和equals的对比</p> <p>==是一个比较运算符</p> <ol><li>==：既可以判断基本类型，又可以判断引用类型</li> <li>==：如果判断基本类型，判断的是值是否相等</li> <li>==：如果判断引用类型，判断的是地址是否相等，即判定是不是同一个对象</li> <li>equals：是Object类中的方法，只能判断引用类型</li> <li>默认判断的是地址是否相等 ，子类中往往重写该方法，用于判断内容是否相等</li></ol></li> <li><p>hashCode方法</p> <ol><li>提高具有哈希结构的容器的效率</li> <li>两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！</li> <li>两个引用，如果指向的是不同对象，则哈希值是不一样的</li> <li>哈希值主要根据地址号来的！不能完全将哈希值等价于地址</li></ol></li> <li><p>toString方法</p> <ul><li>基本介绍：默认返回：全类名 + @ + 哈希值的十六进制，【查看Object的toString方法】子类往往重写toString方法，用于返回对象的属性信息</li> <li>重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式</li> <li>当直接输出一个对象时，toString方法会被默认的调用</li></ul></li> <li><p>finalize方法</p> <ol><li><p>当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作</p></li> <li><p>什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize方法</p></li> <li><p>垃圾回收机制的调用，是由系统来决定（即有自己的GC算法），也可以通过System.gc()主动触发垃圾回收机制</p> <p>提示：我们在实际开发中，几乎不会运用finalize，所以更多就是为了应付面试</p></li></ol></li></ul> <h4 id="断点调试-debug"><a href="#断点调试-debug" class="header-anchor">#</a> 断点调试（debug）</h4> <ul><li><p>一个实际需求</p> <ol><li>在开发中，新手程序员在查找错误时，这时老程序员就会温馨提示，可以用断点调试一步一步的看源码执行的过程，从而发现错误所在</li> <li>重要提示：在断点调试过程中，是运行状态，是以对象的运行类型来执行的</li></ol></li> <li><p>断点调试介绍</p> <ol><li>断点调试是指在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。进行分析从而找到这个Bug</li> <li>断点调试也是程序员必须掌握的技能</li> <li>断点调试也能帮助我们查看java底层源代码的执行过程，提高程序员的Java水平</li></ol></li> <li><p>快捷键</p> <p>F7（跳入）：跳入方法内、F8（跳过）：逐行执行代码、shift+F8（跳出）：跳出方法、F9（resume，执行到下一个断点）</p></li> <li><p>断点技巧：断点可以在debug过程中，动态的下断点</p></li></ul></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">2023/12/19 22:03:32</span></div></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/vuepressblog/Java/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3%E4%B8%8A%E7%AF%87.html#一、建立编程思想" class="sidebar-link reco-side-一、建立编程思想" data-v-b57cc07c>一、建立编程思想</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepressblog/Java/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3%E4%B8%8A%E7%AF%87.html#学前详解" class="sidebar-link reco-side-学前详解" data-v-b57cc07c>学前详解</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepressblog/Java/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3%E4%B8%8A%E7%AF%87.html#java概述" class="sidebar-link reco-side-java概述" data-v-b57cc07c>Java概述</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepressblog/Java/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3%E4%B8%8A%E7%AF%87.html#变量" class="sidebar-link reco-side-变量" data-v-b57cc07c>变量</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepressblog/Java/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3%E4%B8%8A%E7%AF%87.html#运算符" class="sidebar-link reco-side-运算符" data-v-b57cc07c>运算符</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepressblog/Java/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3%E4%B8%8A%E7%AF%87.html#控制结构" class="sidebar-link reco-side-控制结构" data-v-b57cc07c>控制结构</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepressblog/Java/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3%E4%B8%8A%E7%AF%87.html#数组、排序和查找" class="sidebar-link reco-side-数组、排序和查找" data-v-b57cc07c>数组、排序和查找</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepressblog/Java/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3%E4%B8%8A%E7%AF%87.html#面向对象编程-基础" class="sidebar-link reco-side-面向对象编程-基础" data-v-b57cc07c>面向对象编程（基础）</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepressblog/Java/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3%E4%B8%8A%E7%AF%87.html#面向对象编程-中级" class="sidebar-link reco-side-面向对象编程-中级" data-v-b57cc07c>面向对象编程（中级）</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><!----><div></div><!----><div class="RibbonAnimation"></div></div></div>
    <script src="/vuepressblog/assets/js/app.80634c63.js" defer></script><script src="/vuepressblog/assets/js/3.ef187fa4.js" defer></script><script src="/vuepressblog/assets/js/1.93e2b1ee.js" defer></script><script src="/vuepressblog/assets/js/17.ad9b924f.js" defer></script><script src="/vuepressblog/assets/js/9.76c7ad5c.js" defer></script>
  </body>
</html>
