<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java基础学习笔记韩顺平中篇 | itwangcoder&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/vuepressblog/img/logo.png">
    <meta name="description" content="Java基础学习笔记韩顺平中篇">
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/vuepressblog/assets/css/0.styles.e7a65157.css" as="style"><link rel="preload" href="/vuepressblog/assets/js/app.80634c63.js" as="script"><link rel="preload" href="/vuepressblog/assets/js/3.ef187fa4.js" as="script"><link rel="preload" href="/vuepressblog/assets/js/1.93e2b1ee.js" as="script"><link rel="preload" href="/vuepressblog/assets/js/19.ae4fe37d.js" as="script"><link rel="preload" href="/vuepressblog/assets/js/9.76c7ad5c.js" as="script"><link rel="prefetch" href="/vuepressblog/assets/js/10.987eeee2.js"><link rel="prefetch" href="/vuepressblog/assets/js/11.e2698b0f.js"><link rel="prefetch" href="/vuepressblog/assets/js/12.d1a773de.js"><link rel="prefetch" href="/vuepressblog/assets/js/13.b1124dce.js"><link rel="prefetch" href="/vuepressblog/assets/js/14.d43425cc.js"><link rel="prefetch" href="/vuepressblog/assets/js/15.301d4ee9.js"><link rel="prefetch" href="/vuepressblog/assets/js/16.fb92ba76.js"><link rel="prefetch" href="/vuepressblog/assets/js/17.ad9b924f.js"><link rel="prefetch" href="/vuepressblog/assets/js/18.b28999b2.js"><link rel="prefetch" href="/vuepressblog/assets/js/20.8648e605.js"><link rel="prefetch" href="/vuepressblog/assets/js/21.afba39d8.js"><link rel="prefetch" href="/vuepressblog/assets/js/22.a421ec88.js"><link rel="prefetch" href="/vuepressblog/assets/js/23.43bb5f78.js"><link rel="prefetch" href="/vuepressblog/assets/js/24.5300c069.js"><link rel="prefetch" href="/vuepressblog/assets/js/25.e5fe554e.js"><link rel="prefetch" href="/vuepressblog/assets/js/26.d4f0f7c0.js"><link rel="prefetch" href="/vuepressblog/assets/js/27.3d604a05.js"><link rel="prefetch" href="/vuepressblog/assets/js/28.5b15f884.js"><link rel="prefetch" href="/vuepressblog/assets/js/29.f763d748.js"><link rel="prefetch" href="/vuepressblog/assets/js/30.2d33ed3c.js"><link rel="prefetch" href="/vuepressblog/assets/js/31.63dec94e.js"><link rel="prefetch" href="/vuepressblog/assets/js/32.1d419569.js"><link rel="prefetch" href="/vuepressblog/assets/js/33.dd0d73a3.js"><link rel="prefetch" href="/vuepressblog/assets/js/34.11980da6.js"><link rel="prefetch" href="/vuepressblog/assets/js/35.60c39dd1.js"><link rel="prefetch" href="/vuepressblog/assets/js/36.3eb7aee1.js"><link rel="prefetch" href="/vuepressblog/assets/js/37.9b1bc008.js"><link rel="prefetch" href="/vuepressblog/assets/js/38.05776efb.js"><link rel="prefetch" href="/vuepressblog/assets/js/39.7ae3eed8.js"><link rel="prefetch" href="/vuepressblog/assets/js/4.fadd923b.js"><link rel="prefetch" href="/vuepressblog/assets/js/40.fb2393be.js"><link rel="prefetch" href="/vuepressblog/assets/js/41.5f5dec94.js"><link rel="prefetch" href="/vuepressblog/assets/js/42.b9f6299c.js"><link rel="prefetch" href="/vuepressblog/assets/js/43.b3178a1b.js"><link rel="prefetch" href="/vuepressblog/assets/js/5.b07d85ee.js"><link rel="prefetch" href="/vuepressblog/assets/js/6.cdd119e1.js"><link rel="prefetch" href="/vuepressblog/assets/js/7.fe6c61b0.js"><link rel="prefetch" href="/vuepressblog/assets/js/8.d08f9a62.js">
    <link rel="stylesheet" href="/vuepressblog/assets/css/0.styles.e7a65157.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>itwangcoder's blog</h3> <p class="description" data-v-59e6cb88>我的个人网站</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>itwangcoder</span>
          
        <!---->
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepressblog/" class="home-link router-link-active"><img src="/vuepressblog/img/logo.png" alt="itwangcoder's blog" class="logo"> <span class="site-name">itwangcoder's blog</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vuepressblog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><a href="/vuepressblog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><a href="https://www.baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  百度
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><img src="/vuepressblog/img/logo.png" alt="author-avatar" class="personal-img" data-v-1fad0c41> <h3 class="name" data-v-1fad0c41>
    itwangcoder
  </h3> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>31</h3> <h6 data-v-1fad0c41>文章</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>32</h3> <h6 data-v-1fad0c41>标签</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/vuepressblog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><a href="/vuepressblog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><a href="https://www.baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  百度
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>Java基础学习笔记韩顺平中篇</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>itwangcoder</span>
          
        <!---->
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">Java基础学习笔记韩顺平中篇</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>itwangcoder</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>2023/12/19</span></i> <!----> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>韩顺平</span><span class="tag-item" data-v-8a445198>Java</span><span class="tag-item" data-v-8a445198>编程语言</span></i></div></div> <div class="theme-reco-content content__default"><h1 id="java基础-韩顺平"><a href="#java基础-韩顺平" class="header-anchor">#</a> Java基础---韩顺平</h1> <h2 id="二、提高编程能力"><a href="#二、提高编程能力" class="header-anchor">#</a> 二、提高编程能力</h2> <h3 id="面向对象编程-高级部分"><a href="#面向对象编程-高级部分" class="header-anchor">#</a> 面向对象编程（高级部分）</h3> <h4 id="类变量和类方法"><a href="#类变量和类方法" class="header-anchor">#</a> 类变量和类方法</h4> <ul><li><p>类变量内存布局</p> <p>static变量是对象共享，不管static变量在哪里，共识</p> <ol><li>static变量是同一个类所有对象共享</li> <li>static变量，在类加载的时候就生成了</li></ol></li> <li><p>什么是类变量：类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量。</p></li> <li><p>类变量定义</p> <p>定义语法：</p> <p><code>访问修饰符 static 数据类型 变量名;[推荐]</code></p> <p><code>static 访问修饰符 数据类型 变量名;</code></p> <p>访问类变量：类名.类变量名【推荐】 或者 对象名.类变量名【静态变量的访问修饰符的访问权限和范围和普通属性是一样的】</p></li> <li><p>类变量注意事项和细节讨论</p> <ol><li>当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量（静态变量）</li> <li>类变量是该类的所有对象共享的，而实例变量是每个对象独享的</li> <li>加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量</li> <li>类变量可以通过类名.类变量名 或者 对象名.类变量名来访问，但java设计者推荐我们使用类名.类变量名方式访问【前提是满足访问修饰符的访问权限和范围】</li> <li>实例变量不能通过 类名.类变量名 方式访问</li> <li>类变量是在类加载时就初始化了，也就是说，即使你没有创建对象，只要类加载了，就可以使用类变量了</li> <li>类变量的生命周期是随类的加载开始，随着类的消亡而销毁</li></ol></li> <li><p>类方法基本介绍：</p> <p>也叫静态方法，形式如下</p> <p><code>访问修饰符 static 数据返回类型 方法名(){}</code>【推荐】</p> <p><code>static 访问修饰符 数据返回类型 方法名(){}</code></p></li> <li><p>类方法的调用：</p> <p>使用方式：类名.类方法名 或者 对象名.类方法名【前提是满足访问修饰符的访问权限和范围】</p></li> <li><p>经典使用场景：当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率</p></li> <li><p>类方法使用注意事项和细节讨论</p> <ol><li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：类方法中无this的参数；普通方法中隐含着this的参数</li> <li>类方法可以通过类名调用，也可以通过对象名调用</li> <li>普通方法和对象有关，需要通过对象名调用，比如对象名.方法名（参数），不能通过类名调用</li> <li>类方法中不允许使用和对象有关的关键字，比如this和super。普通方法（成员方法）可以</li> <li>类方法（静态方法）中只能访问静态变量或静态方法</li> <li>普通成员方法，既可以访问（非静态）普通变量（方法），也可以访问静态变量（方法）</li></ol> <p>小结：静态方法，只能访问静态的成员，非静态的方法，可以访问静态成员和非静态成员（必须遵守访问权限）</p></li></ul> <h4 id="理解main方法语法"><a href="#理解main方法语法" class="header-anchor">#</a> 理解main方法语法</h4> <ul><li><p>深入理解main方法</p> <ol><li>java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public</li> <li>java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static</li> <li>该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数</li> <li>java执行的程序 参数1 参数2 参数3</li></ol></li> <li><p>特别提示</p> <ol><li>在main()方法中，我们可以直接调用main方法所在类的静态方法或静态属性</li> <li>但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员</li></ol></li></ul> <h4 id="代码块"><a href="#代码块" class="header-anchor">#</a> 代码块</h4> <ul><li><p>基本介绍</p> <p>代码化块又称为初始化块，属于类中的成员【即是类的一部分】，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来。</p> <p>但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用</p></li> <li><p>基本语法</p> <p><code>[修饰符]{</code></p> <p>​	<code>代码</code></p> <p><code>};</code></p> <p>注意：</p> <ol><li>修饰符可选，要写的话，也只能写static</li> <li>代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块</li> <li>逻辑语句可以为任何逻辑语句（输入、输出、方法调用、循环、判断等）</li> <li>;号可以写上，也可以省略</li></ol></li> <li><p>代码块的好处</p> <ol><li>相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化的操作</li> <li>如果多个构造器中都有重复的语句，可以抽到初始化块中，提高代码的重用性</li></ol></li> <li><p>代码块使用注意事项和细节讨论</p> <ol><li><p>static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次。如果是普通代码块，每创建一个对象，就执行</p></li> <li><p>类什么时候被加载：</p> <p>①创建对象实例时</p> <p>②创建子类对象实例，父类也会被加载</p> <p>③使用类的静态成员时（静态属性，静态方法）</p></li> <li><p>普通的代码块，在创建对象实例时，会被隐式的调用。被创建一次，就会调用一次。如果只是使用类的静态成员时，普通代码块并不会执行。</p></li> <li><p>创建一个对象时，在一个类调用顺序是：</p> <p>①调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码和多个静态变量初始化，则按他们定义的顺序调用）</p> <p>②调用普通代码块和普通属性的初始化（注意：普通代码块和普通属性初始化调用的优先级一样，如果多个普通代码块和多个普通属性初始化，则按定义顺序调用）</p> <p>③调用构造方法</p></li> <li><p>构造方法（构造器）的最前面其实隐含了super()和调用普通代码块，新写一个类演示【截图+说明】，静态相关的代码块，属性初始化，在类加载时，就执行完毕，因此是优先于构造器和普通代码块执行的</p></li> <li><p>创建一个子类对象时（继承关系），他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下 ：</p> <p>①父类的静态代码块和静态属性（优先级一样，按定义顺序执行）</p> <p>②子类的静态代码块和静态属性（优先级一样，按定义顺序执行）</p> <p>③父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）</p> <p>④父类的构造方法</p> <p>⑤子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）</p> <p>⑥子类的构造方法</p></li> <li><p>静态代码块只能调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员</p></li></ol></li></ul> <h4 id="单例设计模式"><a href="#单例设计模式" class="header-anchor">#</a> 单例设计模式</h4> <ul><li><p>什么是设计模式</p> <ol><li>静态方法和属性的经典使用</li> <li>设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式就像是经典的棋谱，不同的棋局，我们使用不同的棋谱。</li></ol></li> <li><p>什么是单例模式</p> <ol><li>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法</li> <li>单例模式有两种方式：①饿汉式 ②懒汉式</li></ol></li> <li><p>单例设计模式应用步骤</p> <ol><li>构造器私有化 ==》 防止直接new</li> <li>类的内部创建对象</li> <li>向外暴露一个静态的公共方法。getInstance</li> <li>代码实现</li></ol></li> <li><p>饿汉式VS懒汉式</p> <ol><li>二者最主要的区别在于创建对象的时机不同：饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建</li> <li>饿汉式不存在线程安全问题，懒汉式存在线程安全问题</li> <li>饿汉式存在浪费资源的可能。因为如果程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题</li> <li>在我们javaSE标准类中，java.lang.Runtime就是经典的单例模式</li></ol></li></ul> <h4 id="final关键字"><a href="#final关键字" class="header-anchor">#</a> final关键字</h4> <ul><li><p>基本介绍</p> <p>final中文意思：最后的，最终的。</p> <p>final可以修饰类、属性、方法和局部变量</p> <p>在某些情况下，程序员可能有以下需求，就会使用到final：</p> <ol><li>当不希望类被继承时，可以用final修饰</li> <li>当不希望父类的某个方法被子类覆盖/重写（override）时，可以用final关键字修饰</li> <li>当不希望类的某个属性的值被修改，可以用final修饰</li> <li>当不希望某个局部变量被修改，可以使用final修饰</li></ol></li> <li><p>final使用注意事项和细节讨论</p> <ol><li><p>final修饰的属性又叫常量，一般用XX_XX_XX来命名</p></li> <li><p>final修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以在如下位置之一【选择一个位置赋初值即可】</p> <p>①定义时：如public final double TAX_RATE = 0.08;</p> <p>②在构造器中</p> <p>③在代码块中</p></li> <li><p>如果final修饰的属性是静态的，则初始化的位置只能是</p> <p>①定义时</p> <p>②在静态代码块不能在构造器中赋值</p></li> <li><p>final类不能继承，但是可以实例化对象</p></li> <li><p>如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承</p></li> <li><p>一般来说，如果一个类已经是final类了，就没有必要再将方法修饰成final方法</p></li> <li><p>final不能修饰构造方法（即构造器）</p></li> <li><p>final和static往往搭配使用，效率更高，不会导致类加载，底层编译器做了优化处理</p></li> <li><p>包装类（Integer，Double，Float，Boolean等都是final），String也是final类</p></li></ol></li></ul> <h4 id="抽象类"><a href="#抽象类" class="header-anchor">#</a> 抽象类</h4> <ul><li><p>当父类的某些方法，需要声明，但是又不确定如何实现时，可以将其声明为抽象方法，那么 这个类就是抽象类</p></li> <li><p>抽象类快速入门：当父类的一些方法不能确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰该类就是抽象类</p></li> <li><p>所谓抽象方法就是没有实现的方法，所谓没有实现就是指，没有方法体，当一个类中存在抽象方法时，需要将该类声明为abstract类，一般来说，抽象类会被继承，有其子类来实现抽象方法</p></li> <li><p>抽象类的介绍</p> <ol><li><p>用abstract关键字来修饰一个类时，这个类就叫抽象类</p> <p><code>访问修饰符 abstract 类名{}</code></p></li> <li><p>用abstract关键字来修饰一个方法时，这个方法就是抽象方法</p> <p><code>访问修饰符 abstract 返回类型 方法名(参数列表);//没有方法体</code></p></li> <li><p>抽象类的价值更多作用是在于设计 ，是设计者设计好后，让子类继承并实现抽象类()</p></li></ol></li> <li><p>抽象类使用的注意事项和细节讨论</p> <ol><li>抽象类不能被实例化</li> <li>抽象类不一定要包含abstract方法。也就是说，抽象类可以没有abstract方法</li> <li>一旦类包含了abstract方法，则这个类必须声明为abstract</li> <li>abstract只能修饰类和方法，不能修饰属性和其它的</li> <li>抽象类可以有任意成员【因为抽象类本质还是类】，比如：非抽象方法、构造器、静态属性等等</li> <li>抽象方法不能有主体，即不能实现</li> <li>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类</li> <li>抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的</li></ol></li> <li><p>抽象类实践-模板设计模式</p> <p>需求</p> <ol><li>有多个类，完成不同的任务job</li> <li>要求能够得到各自完成任务的时间</li></ol> <p>其它</p></li></ul> <h4 id="接口"><a href="#接口" class="header-anchor">#</a> 接口</h4> <ul><li><p>基本介绍</p> <p>接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，在根据具体情况把这些方法写出来。语法：</p> <p><code>interface 接口名{</code></p> <p>​	<code>//属性</code></p> <p>​	<code>//方法（1.抽象方法：可以省略abstract关键字 2.默认实现方法：jdk8后，需要使用default关键字修饰 3.静态方法：jdk8后）</code></p> <p><code>}</code></p> <p><code>class 类名 implements 接口{</code></p> <p>​	<code>自己属性</code></p> <p>​	<code>自己方法</code></p> <p>​	<code>必须实现的接口的抽象方法</code></p> <p><code>}</code></p> <p>小结：</p> <ol><li>在JDK7.0前，接口里的所有方法都没有方法体，即都是抽象方法</li> <li>JDK8.0后接口 类可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现</li></ol></li> <li><p>注意事项和细节</p> <ol><li>接口不能被实例化</li> <li>接口中所有的方法是public方法，接口中抽象方法，可以不用abstract修饰</li> <li>一个普通类实现接口，就必须将该接口的所有方法都实现</li> <li>抽象类实现接口，可以不用实现接口的方法</li> <li>一个类同时可以实现多个接口</li> <li>接口中的属性，只能是final的，而且是public static final修饰符。比如：int a = 1;实际上是public static final int a = 1;（必须初始化）</li> <li>接口中属性的访问形式：接口名.属性名</li> <li>一个接口不能继承其它的类，但是可以继承多个别的接口</li> <li>接口的修饰符只能是public和默认，这点和类的修饰符是一样的</li></ol></li> <li><p>继承类VS实现接口</p> <p>当子类继承了父类，就自动的拥有父类的功能。如果子类需要扩展功能，可以通过实现接口的方式扩展。可以理解，实现接口是对java单继承机制的一种补充</p> <ul><li><p>接口和继承解决的问题不同</p> <p>继承的价值主要在于：解决代码的复用性和可维护性</p> <p>接口的价值主要在于：设计，设计好各种规范（方法），让其它类去实现这些方法</p></li> <li><p>接口比继承更加灵活</p> <p>接口比继承更加灵活，继承是满足is-a的关系，而接口只需满足like-a的关系</p></li> <li><p>接口在一定程度上实现代码解耦【即接口规范性+动态绑定】</p></li></ul></li> <li><p>接口的多态特性</p> <ol><li>多态参数：在前面的Usb接口案例，Usb usb，既可以接收手机对象，又可以接收相机对象，就体现了接口多态（接口引用可以指向实现了接口的类的对象）</li> <li>多态数组</li> <li>接口存在多态传递现象</li></ol></li></ul> <h4 id="内部类"><a href="#内部类" class="header-anchor">#</a> 内部类</h4> <ul><li><p>基本介绍</p> <p>一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类（inner class），嵌套其他类的类称为外部类（outer class）。是我们类的第五大成员【属性、方法、构造器、代码块、内部类】，内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系</p></li> <li><p>基本语法</p> <p><code>class Outer{//外部类</code></p> <p>​	<code>class Inner{//内部类</code></p> <p>​	<code>}</code></p> <p><code>}</code></p> <p><code>class Other{//外部其他类</code></p> <p><code>}</code></p></li> <li><p>内部类的分类</p> <ul><li>定义在外部类的局部位置上（比如方法内）：
<ol><li>局部内部类（有类名）</li> <li>匿名内部类（没有类名，重点）</li></ol></li> <li>定义在外部类的成员位置上：
<ol><li>成员内部类（没用static修饰）</li> <li>静态内部类（使用static修饰）</li></ol></li></ul></li> <li><p>局部内部类的使用</p> <p>说明：局部内部类是定义在外部类的局部位置，比如方法中，并且有类名</p> <ol><li><p>可以直接访问外部类的所有成员、包含私有的</p></li> <li><p>不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但是可以使用final修饰，因为局部变量也可以使用final</p></li> <li><p>作用域：仅仅在定义它的方法或代码块中</p></li> <li><p>局部内部类---访问----&gt;外部类的成员【访问方式：直接访问】</p></li> <li><p>外部类---访问----&gt;局部内部类的成员</p> <p>访问方式：创建对象，再访问（注意：必须在作用域内）</p></li> <li><p>外部其他类---不能访问----&gt;局部内部类（因为局部内部类地位是一个局部变量）</p></li> <li><p>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问</p></li></ol></li> <li><p>匿名内部类的使用</p> <p>(1)本质是类(2)内部类(3)该类没有名字(4)同时还是一个对象</p> <p>说明：匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名</p> <ol><li><p>匿名内部类的基本语法</p> <p><code>new 类或接口(参数列表){</code></p> <p>​	<code>类体</code></p> <p><code>};</code></p></li> <li><p>匿名内部类的语法比较奇特，请大家注意，因为匿名内部类既是一个类的定义，同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征，对前面代码分析可以看出这个特点，因此可以调用匿名内部类方法</p></li> <li><p>可以直接访问外部类的所有成员，包含私有的</p></li> <li><p>不能添加访问修饰符，因为它的地位就是一个局部变量</p></li> <li><p>作用域：仅仅在定义它的方法或代码块中</p></li> <li><p>匿名内部类---访问----&gt;外部类成员【访问方式：直接访问】</p></li> <li><p>外部其他类---不能访问----&gt;匿名内部类（因为匿名内部类地位是一个局部变量）</p></li> <li><p>如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问</p></li></ol></li> <li><p>成员内部类的使用</p> <p>说明：成员内部类是定义在外部类的成员位置，并且没有static修饰</p> <ol><li>可以直接访问外部类的所有成员，包含私有的</li> <li>可以添加任意访问修饰符（public、protected、默认、private），因为它的地位就是一个成员</li> <li>作用域：和外部类的其他成员一样，为整个类体比如前面案例，在外部类的成员方法中创建成员内部类对象，再调用方法</li> <li>成员内部类---访问----&gt;外部类（比如：属性）【访问方式：直接访问】</li> <li>外部类---访问----&gt;内部类（说明）访问方式：创建对象，再访问</li> <li>外部其他类---访问---&gt;成员内部类</li> <li>如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问</li></ol></li> <li><p>静态内部类的使用</p> <p>说明：静态内部类是定义在外部类的成员位置，并且有static修饰</p> <ol><li>可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员</li> <li>可以添加任意访问修饰符（public、protected、默认、private），因为它的地位就是一个成员</li> <li>作用域：同其他的成员，为整个类体</li> <li>静态内部类---访问----&gt;外部类（比如：静态属性）【访问方式：直接访问所有静态成员】</li> <li>外部类---访问----&gt;静态内部类 访问方式：创建对象，再访问</li> <li>外部其他类---访问----&gt;静态内部类</li> <li>如果外部类和静态内部类的成员重名时，静态内部类访问的时候，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.成员）去访问</li></ol></li></ul> <h3 id="枚举和注解"><a href="#枚举和注解" class="header-anchor">#</a> 枚举和注解</h3> <h4 id="枚举介绍"><a href="#枚举介绍" class="header-anchor">#</a> 枚举介绍</h4> <p>枚举是一组常量的集合</p> <ul><li>枚举的二种实现方式
<ol><li>自定义实现枚举</li> <li>使用enum关键字实现枚举</li></ol></li></ul> <h4 id="自定义类实现枚举"><a href="#自定义类实现枚举" class="header-anchor">#</a> 自定义类实现枚举</h4> <ul><li><p>实现</p> <ol><li>不需要提供setXxx方法，因为枚举对象通常为只读</li> <li>对枚举对象/属性使用final + static共同修饰，实现底层优化</li> <li>枚举对象名通常使用全部大写，常量的命名规范</li> <li>枚举对象根据需要，也可以有多个属性</li></ol></li> <li><p>自定义类实现枚举特点</p> <ol><li>构造器私有化</li> <li>本类内部创建一组对象</li> <li>对外暴露对象（通过为对象添加public final static 修饰符）</li> <li>可以提供get方法，但是不要提供set</li></ol></li></ul> <h4 id="enum关键字实现枚举"><a href="#enum关键字实现枚举" class="header-anchor">#</a> enum关键字实现枚举</h4> <ul><li><p>enum关键字实现枚举注意事项</p> <ol><li>当我们使用enum关键字开发一个枚举类时，默认会继承Enum类，而且是一个final类</li> <li>传统的public static final Season2 SPRING = new Season2(&quot;春天&quot;,&quot;温暖&quot;); 简化成SPRING(&quot;春天&quot;,&quot;温暖&quot;)，这里必须知道，它调用的是哪个构造器</li> <li>如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略</li> <li>当有多个枚举对象时，使用&quot;,&quot;间隔，最后有一个分号结尾</li> <li>枚举对象必须放在枚举类的行首</li></ol></li> <li><p>enum常用方法说明</p> <p>说明：使用关键字enum时，会隐式继承Enum类，这样我们就可以使用Enum类相关的方法</p> <p><code>public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;,Serializable{}</code></p> <ol><li>toString：Enum类已经重写过了，返回的是当前对象名，子类可以重写该方法，用于返回对象的属性信息</li> <li>name：返回当前对象名（常量名），子类中不能重写</li> <li>ordinal：返回当前对象的位置号，默认从0开始</li> <li>values：返回当前枚举类中所有的常量</li> <li>valueOf：将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常！</li> <li>compareTo：比较两个枚举常量，比较的就是位置号！</li></ol></li> <li><p>enum实现接口</p> <ol><li><p>使用enum关键字后，就不能再继承其它类了，因为enum会隐式继承Enum，而Java是单继承机制</p></li> <li><p>枚举类和普通类一样，可以实现接口，如下形式</p> <p><code>enum 类名 implements 接口1,接口2{}</code></p></li></ol></li></ul> <h4 id="jdk内置的基本注解类型"><a href="#jdk内置的基本注解类型" class="header-anchor">#</a> JDK内置的基本注解类型</h4> <ul><li><p>注解的理解</p> <ol><li>注解（Annotation）也称为元数据（Metadata），用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息</li> <li>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息</li> <li>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替java EE旧版中所遗留的繁冗代码和XML配置等。</li></ol></li> <li><p>基本的Annotation介绍</p> <p>使用Annotation时要在其前面增加@符号，并把该Annotation当成一个修饰符使用。用于修饰它支持的程序元素</p> <p>三个基本的Annotation：</p> <ol><li>@Override：限定某个方法，是重写父类方法，该注解只能用于方法</li> <li>@Deprecated：用于表示某个程度元素（类，方法等）已过时</li> <li>@SuppressWarnings：抑制编译器警告</li></ol> <p>补充说明：</p> <p>@interface：不是interface，是注解类，是jdk5.0之后加入的</p></li> <li><p>Override使用说明</p> <ol><li>@Override表示指定重写父类的方法（从编译层面验证），如果父类没有fly方法，则会报错</li> <li>如果不写@Override注解 ，而父类仍有public void fly(){}，仍然构成重写</li> <li>@Override只能修饰方法，不能修饰其它类、包、属性等等</li> <li>查看@Override注解源码为@Target(ElementType.METHOD)，说明只能修饰方法</li> <li>@Target是修饰注解的注解，称为元注解</li></ol></li> <li><p>@Deprecated的说明</p> <ol><li>用于表示某个程序元素（类，方法等）已过时</li> <li>可以修饰方法、类、字段、包、参数等等</li> <li>@Target(value={CONSTRUCTOR,FIELD,LOCAL_VARIABLE,METHOD,PACKAGE,PARAMETER,TYPE})</li> <li>@Deprecated的作用可以做到新旧版本的兼容和过渡</li></ol></li> <li><p>@SuppressWarnings说明</p> <ol><li>unchecked：是忽略没有检查的警告</li> <li>rawtypes：是忽略没有指定泛型的警告（传参时没有指定泛型的警告错误）</li> <li>unused：是忽略没有使用某个变量的警告错误</li> <li>@SuppressWarnings：可以修饰的程序元素为，查看@Target</li> <li>生成@SuppressWarnings时，不用背，直接点击左侧的黄色提示，就可以选择（注意可以指定生成的位置）</li></ol></li></ul> <h4 id="元注解-对注解进行注解"><a href="#元注解-对注解进行注解" class="header-anchor">#</a> 元注解：对注解进行注解</h4> <ul><li><p>元注解的基本介绍</p> <p>JDK的元Annotation用于修饰其他Annotation</p></li> <li><p>元注解的种类（使用不多，了解，不用深入研究）</p> <ol><li>Retention：指定注解的作用范围，三种SOURCE，CLASS，RUNTIME</li> <li>Target：指定注解可以在哪些地方使用</li> <li>Documented：指定该注解是否会在javadoc体现</li> <li>Inherited：子类会继承父类注解</li></ol></li> <li><p>@Retention注解</p> <ul><li><p>说明</p> <p>只能用于修饰一个Annotation定义，用于指定该Annotation可以保留多长时间，@Retention包含一个RetentionPolicy类型的成员变量，使用@Rentention时必须为该value成员变量指定值</p></li> <li><p>@Retention的三种值</p> <ol><li>RetentionPolicy.SOURCE：编译器使用后，直接丢弃这种策略的注释</li> <li>RetentionPolicy.CLASS：编译器将把注释记录在class文件中，当运行Java程序时，JVM不会保留注释，这是默认值</li> <li>RetentionPolicy.RUNTIME：编译器将把注释记录在class文件中，当运行Java程序时，JVM会保留注释，程序可以通过反射获取该注释</li></ol></li> <li><p>@Override说明：Override的作用域在SOURCE，当编译器编译 时生效，不会写入到.class文件，也不会再runtime（运行时）生效</p></li> <li><p>@Target说明：用于修饰Annotation定义，用于指定被修饰的Annotation能用于修饰哪些程序元素。@Target也包含一个名为value的成员变量</p></li></ul></li> <li><p>@Inherited注解</p> <p>被它修饰的Annotation将具有继承性，如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解</p> <p>说明：实际应用中，使用较少，了解即可</p></li></ul> <h3 id="异常-exception"><a href="#异常-exception" class="header-anchor">#</a> 异常-Exception</h3> <h4 id="异常的概念"><a href="#异常的概念" class="header-anchor">#</a> 异常的概念</h4> <ul><li>基本概念：Java语言中，将程序执行中发生的不正常情况称为“异常”。（开发过程中的语法错误和逻辑错误不是异常）</li> <li>执行过程中所发生的异常事件可分为两类
<ol><li>Error（错误）：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError【栈溢出】和OOM（out of memory），Error是严重错误，程序会崩溃</li> <li>Exception：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等等，Exception分为两大类：运行时异常【程序运行时，发生的异常】和编译时异常【编程时，编译器检查出的异常】</li></ol></li></ul> <h4 id="异常体系图"><a href="#异常体系图" class="header-anchor">#</a> 异常体系图</h4> <ul><li>小结
<ol><li>异常分为两大类，运行时异常和编译时异常</li> <li>运行时异常，编译器不要求强制处置的异常。编译器检查不出来，一般是指编程时的逻辑错误，是程序员应该避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常</li> <li>对于运行时异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响</li> <li>编译时异常，是编译器要求必须处置的异常。</li></ol></li></ul> <h4 id="常见的异常"><a href="#常见的异常" class="header-anchor">#</a> 常见的异常</h4> <ul><li><p>常见的运行时异常包括</p> <ol><li>NullPointerException空指针异常：当应用程序试图在需要对象的地方使用null时，抛出该异常</li> <li>ArithmeticException数学运算异常：当出现异常的运算条件时，抛出此异常</li> <li>ArrayIndexOutOfBoundsException数组下标越界异常：用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引</li> <li>ClassCastException类型转换异常：当试图将对象强制转换为不是实例的子类时，抛出该异常</li> <li>NumberFormatException数字格式不正确异常[]：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式，抛出该异常 = 》使用异常我们可以确保输入是满足条件数字</li></ol></li> <li><p>编译异常</p> <p>介绍：编译异常是指在编译期间，就必须处理的异常，否则代码不能通过编译</p> <p>常见的编译异常</p> <ul><li>SQLException // 操作数据库时，查询表可能发生异常</li> <li>IOException // 操作文件时，发生的异常</li> <li>FileNotFoundException // 当操作一个不存在的文件时，发生异常</li> <li>ClassNotFoundException // 加载类，而该类不存在时，异常</li> <li>EOFException // 操作文件，到文件末尾，发生异常</li> <li>IllegalArguementException // 参数异常</li></ul></li></ul> <h4 id="异常处理概念"><a href="#异常处理概念" class="header-anchor">#</a> 异常处理概念</h4> <ul><li>基本介绍：异常处理就是当异常发生时，对异常处理的方式</li> <li>异常处理的方式
<ol><li>try-catch-finally：程序员在代码中捕获发生的异常，自行处理</li> <li>throws：将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是JVM</li></ol></li></ul> <h4 id="异常处理分类"><a href="#异常处理分类" class="header-anchor">#</a> 异常处理分类</h4> <ul><li><p>try-catch异常处理</p> <ul><li><p>try-catch方式处理异常说明</p> <ol><li><p>Java提供try和catch块来处理异常。try块用于包含可能出错的代码。catch块用于处理try块中发生的异常。可以根据需要在程序中有多个数量的try...catch块</p></li> <li><p>基本语法</p> <p><code>try{</code></p> <p>​	<code>// 可疑代码</code></p> <p>​	<code>// 将异常生成对应的异常对象，传递给catch块</code></p> <p><code>}catch(异常){</code></p> <p>​	<code>// 对异常的处理</code></p> <p><code>}</code></p></li></ol></li> <li><p>try-catch方式处理异常-注意事项</p> <ol><li><p>如果异常发生了，则异常发生后面的代码不会执行，直接进入到catch块</p></li> <li><p>如果异常没有发生，则顺序执行try的代码块，不会进入到catch</p></li> <li><p>如果希望不管是否发生异常，都执行某段代码（比如关闭连接，释放资源等）则使用如下代码-finally{}</p> <p><code>try{</code></p> <p>​	<code>// 可疑代码</code></p> <p><code>}catch(异常){</code></p> <p>​	<code>// ...</code></p> <p><code>}finally{</code></p> <p>​	<code>// 释放资源等</code></p> <p><code>}</code></p></li> <li><p>可以有多个catch语句，捕获不同的异常（进行不同的业务处理），要求父类异常在后，子类异常在前，比如（Exception在后，NullPointerException在前），如果发生异常，只会匹配一个catch</p> <p><code>try{</code></p> <p><code>}catch(NullPointerException e){</code></p> <p><code>}catch(Exception e){</code></p> <p><code>}finally{</code></p> <p><code>}</code></p></li> <li><p>可以进行try-finally配合使用，这种用法相当于没有捕获异常，因此程序会直接崩掉/退出 。应用场景，就是执行一段代码，不管是否发生异常，都必须执行某个业务逻辑</p> <p><code>try{</code></p> <p>​	<code>//代码...</code></p> <p><code>}finally{</code></p> <p>​	<code>//总是执行</code></p> <p><code>}</code></p></li></ol></li> <li><p>try-catch-finally执行顺序小结</p> <ol><li>如果没有出现异常，则执行try块中所有语句，不执行catch块中语句，如果有finally，最后还需要执行finally里面的语句</li> <li>如果出现异常，则try块中异常发生后，try块剩下的语句不再执行。将执行catch块中的语句，如果有finally，最后还需要执行finally里面的语句</li></ol></li></ul></li> <li><p>throws异常处理</p> <ul><li>基本介绍
<ol><li>如果一个方法（中的语句执行时）可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理</li> <li>在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类</li></ol></li> <li>注意事项和使用细节
<ol><li>对于编译异常，程序中必须处理，比如try-catch或者throws</li> <li>对于运行时异常，程序中如果没有处理，默认就是throws的方式处理</li> <li>子类重写父类的方法时，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常的类型的子类型</li> <li>在throws过程中，如果有方法try-catch，就相当于处理异常，就可以不必throws</li></ol></li></ul></li></ul> <h4 id="自定义异常"><a href="#自定义异常" class="header-anchor">#</a> 自定义异常</h4> <ul><li>基本概念：当程序中出现了某些“错误”，但该错误信息并没有在Throwable子类中描述处理，这个时候可以自己设计异常类，用于描述该错误信息</li> <li>自定义异常的步骤
<ol><li>定义类：自定义异常类名继承Exception或RuntimeException</li> <li>如果继承Exception，属于编译异常</li> <li>如果继承RuntimeException，属于运行异常（一般来说，继承RuntimeException）</li></ol></li></ul> <h4 id="throw和throws的对比"><a href="#throw和throws的对比" class="header-anchor">#</a> throw和throws的对比</h4> <table><thead><tr><th></th> <th>意义</th> <th>位置</th> <th>后面跟的东西</th></tr></thead> <tbody><tr><td>throws</td> <td>异常处理的一种方式</td> <td>方法声明处</td> <td>异常类型</td></tr> <tr><td>throw</td> <td>手动生成异常对象的关键字</td> <td>方法体中</td> <td>异常对象</td></tr></tbody></table> <h3 id="常用类"><a href="#常用类" class="header-anchor">#</a> 常用类</h3> <h4 id="包装类"><a href="#包装类" class="header-anchor">#</a> 包装类</h4> <ul><li><p>包装类的分类</p> <ol><li>针对八种基本数据类型相应的引用类型—包装类</li> <li>有了类的特点，就可以调用类中的方法</li></ol> <table><thead><tr><th style="text-align:center;">基本数据类型</th> <th style="text-align:center;">包装类</th></tr></thead> <tbody><tr><td style="text-align:center;">boolean</td> <td style="text-align:center;">Boolean</td></tr> <tr><td style="text-align:center;">char</td> <td style="text-align:center;">Character</td></tr> <tr><td style="text-align:center;">byte</td> <td style="text-align:center;">Byte</td></tr> <tr><td style="text-align:center;">short</td> <td style="text-align:center;">Short</td></tr> <tr><td style="text-align:center;">int</td> <td style="text-align:center;">Integer</td></tr> <tr><td style="text-align:center;">long</td> <td style="text-align:center;">Long</td></tr> <tr><td style="text-align:center;">float</td> <td style="text-align:center;">Float</td></tr> <tr><td style="text-align:center;">double</td> <td style="text-align:center;">Double</td></tr></tbody></table> <p>父类：Number——Byte、Short、Integer、Long、Float、Double</p></li> <li><p>包装类和基本数据的转换</p> <ol><li>Jdk5前的手动装箱和拆箱方式，装箱：基本类型-&gt;包装类型，反之，拆箱</li> <li>jdk5之后（含jdk5）的自动装箱和拆箱方式</li> <li>自动装箱底层调用的是valueOf方法，比如Integer.valueOf()</li></ol> <p><code>// 基本类型---&gt;包装类型【手动装箱】</code></p> <p><code>int i = 10;</code></p> <p><code>Integer i1 = new Integer(i);</code></p> <p><code>Integer i2 = Integer.valueOf(i);</code></p> <p><code>// 包装类型---&gt;基本类型【手动拆箱】</code></p> <p><code>Integer j = new Integer(99);</code></p> <p><code>int j1 = j.intValue();</code></p></li> <li><p>包装类和String类型的相互转换</p> <p><code>// 包装类---&gt;String</code></p> <p><code>// 方式1</code></p> <p><code>String str1 = i + &quot;&quot;;</code></p> <p><code>// 方式2</code></p> <p><code>String str2 = i.toString();</code></p> <p><code>// 方法3</code></p> <p><code>String str3 = String.valueOf(i);</code></p> <p><code>// String ---&gt;包装类</code></p> <p><code>// 使用自动装箱</code></p> <p><code>Integer i2 = Integer.parseInt(str);</code></p> <p><code>// 构造器</code></p> <p><code>Integer i3 = new Integer(str);</code></p></li> <li><p>Integer类和Character类的常用方法</p> <ul><li>Integer.MIN_VALUE：返回最小值</li> <li>Integer.MAX_VALUE：返回最大值</li> <li>Character.isDigit('a')：判断是不是数字</li> <li>Character.isLetter('a')：判断是不是字母</li> <li>Character.isUpperCase('a')：判断是不是大写</li> <li>Character.isLowerCase('a')：判断是不是小写</li> <li>Character.isWhitespace('a')：判断是不是空格</li> <li>Character.toUpperCase('a')：转成大写</li> <li>Character.toLowerCase('A')：转成小写</li></ul></li></ul> <h4 id="string类"><a href="#string类" class="header-anchor">#</a> String类</h4> <ul><li><p>String类的理解和创建对象</p> <ol><li><p>String对象用于保存字符串，也就是一组字符序列</p></li> <li><p>字符串常量对象是用双引号括起的字符序列</p></li> <li><p>字符串的字符使用Unicode字符编码，一个字符（不区分字母还是汉字）占两个字节</p></li> <li><p>String类比较常用构造方法</p> <ul><li>String s1 = new String();</li> <li>String s2 = new String(String original);</li> <li>String s3 = new String(char[] a);</li> <li>String s4 = new String(char[] a, int startIndex, int count)</li></ul></li> <li><p>注意：String实现了Serializable，说明String可以串行化（数据可以在网络传输）；String实现了Comparable接口，说明String对象可以比较</p></li> <li><p>String是final类，不能被其他的类继承</p></li> <li><p>String有属性private final char value[];用于存放字符串内容</p></li> <li><p>一定要注意：value是一个final类型，（value指向的地址）不可修改：即value不能指向新的地址，但是单个字符内容是可以变化</p></li></ol></li> <li><p>创建String对象的两种方式</p> <ol><li>方式一：直接赋值 String s = &quot;hspedu&quot;;</li> <li>方式二：调用构造器 String s = new String(&quot;hspedu&quot;);</li></ol></li> <li><p>两种创建String对象的区别</p> <p>方式一：直接赋值 String s = &quot;hsp&quot;;</p> <p>方式二：调用构造器 String s2 = new String(&quot;hsp&quot;);</p> <ol><li>方式一：先从常量池查看是否有&quot;hsp&quot;数据空间，如果有，直接指向；如果没有则重新创建，然后指向。s最终指向的是常量池的空间地址</li> <li>方式二：先在堆中创建空间，里面维护了value属性，指向常量池的hsp空间。如果常量池没有&quot;hsp&quot;，重新创建，如果有，直接通过value指向。最终指向的是堆中的空间地址</li></ol></li> <li><p>字符串的特性</p> <ol><li>String是一个final类，代表不可变的字符序列</li> <li>字符串是不可变的。一个字符串对象一旦被分配，其内容 是不可变的</li> <li>编译器会做一个优化，判断创建的常量池对象，是否有引用指向<code>String a = &quot;hello&quot; + &quot;abc&quot;; =》 String a = &quot;Helloabc&quot;;</code></li> <li>重要规则，String c1 = &quot;ab&quot; + &quot;cd&quot;；常量相加，看的是池。String c1 = a + b；变量相加，是在堆中</li></ol></li> <li><p>String类的常用方法：String类是保存字符串常量的。每次更新都需要重新开辟空间，效率较低，因此java设计者还提供了StringBuilder和StringBuffer来增强String的功能，并提高效率</p> <ul><li><p>equals：区分大小写，判断内容是否相等</p></li> <li><p>equalsIgnoreCase：忽略大小写的判断内容是否相等</p></li> <li><p>length：获取字符的个数，字符串的长度</p></li> <li><p>indexOf：获取字符在字符串中第1次出现的索引，索引从0开始，如果找不到，返回-1</p></li> <li><p>lastIndexOf：获取字符在字符串中最后1次出现的索引，索引从0开始，如找不到，返回-1</p></li> <li><p>substring：截取指定范围的子串</p></li> <li><p>trim：去前后空格</p></li> <li><p>charAt：获取某索引处的字符，注意不能使用Str[index]这种方式</p></li> <li><p>toUpperCase</p></li> <li><p>toLowerCase</p></li> <li><p>concat：拼接字符串</p></li> <li><p>replace：替换字符串中的字符</p></li> <li><p>split：分割字符串，对于某些分割字符，我们需要转义比如|\\等</p></li> <li><p>compare：比较两个字符串的大小</p></li> <li><p>toCharArray：转换成字符数组</p></li> <li><p>format：格式字符串，%s字符串 %c字符串 %d整型 %.2f浮点型</p></li></ul></li></ul> <h4 id="stringbuffer和stringbuilder类"><a href="#stringbuffer和stringbuilder类" class="header-anchor">#</a> StringBuffer和StringBuilder类</h4> <ul><li><p>StringBuffer类基本介绍</p> <ul><li>java.lang.StringBuffer代表可变的字符序列，可以对字符串内容进行增删</li> <li>很多方法与String相同，但StringBuffer是可变长度的</li> <li>StringBuffer是一个容器</li> <li>其他：
<ol><li>StringBuffer的直接父类是AbstractStringBuilder</li> <li>StringBuffer实现了Serializable，即StringBuffer的对象可以串行化</li> <li>在父类中，AbstractStringBuilder有属性char[] value，不是final，该value数组存放字符串内容，引出存放在堆中的</li> <li>StringBuffer是一个final类，不能被继承</li> <li>因为StringBuffer字符内容是存在char[] value，所有在变化（增加/删除）不用每次都更换地址（即创建新对象），所以效率高于String</li></ol></li></ul></li> <li><p>String VS StringBuffer</p> <ol><li>String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址，效率较低<code>// private final char value[];</code></li> <li>StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用每次更新地址，效率较高<code>// char[] value; // 这个放在堆</code></li></ol></li> <li><p>StringBuffer的构造器</p> <ul><li>StringBuffer()：构造一个其中不带字符的字符串缓冲区，其初始容量为16个字符</li> <li>StringBuffer(CharSequence seq)：public java.lang.StringBuilder(CharSequence seq)构造一个字符串缓冲区，它包含与指定的CharSequence相同的字符</li> <li>StringBuffer(int capacity)  // capacity[容量]：构造一个不带字符，但具有指定初始容量的字符串缓冲区。即对char[]大小进行指定</li> <li>StringBuffer(String str)：构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容，char[] 大小就是str.length() + 16</li></ul></li> <li><p>String和StringBuffer相互转换</p> <ul><li><p>String--&gt;StringBuffer</p> <p><code>String s = &quot;hello&quot;;</code></p> <p><code>// 方式1 - 对str本身没有影响</code></p> <p><code>StringBuffer b1 = new StringBuffer(s);</code></p> <p><code>// 方式2</code></p> <p><code>StringBuffer b2 = new StringBuffer();</code></p> <p><code>b2.append(s);</code></p></li> <li><p>StringBuffer--&gt;String</p> <p><code>// 方式1</code></p> <p><code>String s2 = b1.toString(); // b1[StringBuffer]</code></p> <p><code>// 方式2</code></p> <p><code>String s3 = new String(b1);</code></p></li></ul></li> <li><p>StringBuffer类常见方法</p> <ol><li>增 append</li> <li>删 delete(start,end)：删除索引大于等于start&amp;&amp;小于end处的字符</li> <li>改 replace(start,end,string) //将start---end间的内容替换掉，不含end</li> <li>查 indexOf //查找子串在字符串第1次出现的索引，如果找不到返回-1</li> <li>插 insert</li> <li>获取长度 length</li></ol></li> <li><p>StringBuilder类基本介绍</p> <ol><li>一个可变的字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步（StringBuilder不是线程安全的）。该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer要快</li> <li>在StringBuilder上的主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据。</li></ol></li> <li><p>StringBuilder常用方法</p> <p>StringBuilder和StringBuffer均代表可变的字符序列，方法是一样的，所以使用和StringBuffer一样</p> <ol><li>StringBuilder是final类，不能被继承</li> <li>继承了AbstractStringBuilder，属性char[] value，内容（对象字符序列）存到value，字符序列是堆中</li> <li>实现了Serializable接口，序列化（所谓序列化即可以保存类型和数据本身），可以串行化（对象可以网络传输，还可以保存到文件）</li> <li>StringBuilder的方法，没有做互斥处理，即没有synchronized关键字，因此在单线程的情况下使用StringBuilder</li></ol></li> <li><p>String、StringBuffer和StringBuilder的比较</p> <ol><li><p>StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且方法也一样</p></li> <li><p>String：不可变字符序列，效率低，但是复用率高</p></li> <li><p>StringBuffer：可变字符序列、效率较高（增删）、线程安全</p></li> <li><p>StringBuilder：可变字符序列、效率最高、线程不安全</p></li> <li><p>String使用注意说明：</p> <p>string s = &quot;a&quot;;// 创建了一个字符串</p> <p>s += &quot;b&quot;; // 实际上原来的“a”字符串对象已经丢弃了，现在又产生了一个字符串s+&quot;b&quot;（也就是&quot;ab&quot;）。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能=&gt; 结论：如果我们对String做大量修改，不要使用String</p></li></ol></li> <li><p>String、StringBuffer和StringBuilder的选择</p> <ol><li>如果字符串存在大量的修改操作，一般使用StringBuffer或StringBuilder</li> <li>如果字符串存在大量的修改操作，并在单线程的情况，使用StringBuilder</li> <li>如果字符串存在大量的修改操作，并在多线程的情况，使用StringBuffer</li> <li>如果我们字符串很少修改，被多个对象引用，使用String，比如配置信息等</li></ol></li></ul> <h4 id="math类"><a href="#math类" class="header-anchor">#</a> Math类</h4> <ul><li>基本介绍：Math类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数</li> <li>方法一览
<ol><li>abs 绝对值</li> <li>pow 求幂</li> <li>ceil 向上取整</li> <li>floor 向下取整</li> <li>round 四舍五入</li> <li>sqrt 求开方</li> <li>random 求随机数</li> <li>max 求两个数的最大值</li> <li>min 求两个数的最小值</li></ol></li></ul> <h4 id="date日期类、calendar日历类以及新的日期"><a href="#date日期类、calendar日历类以及新的日期" class="header-anchor">#</a> Date日期类、Calendar日历类以及新的日期</h4> <ul><li><p>第一代日期类</p> <ol><li>Date：精确到毫秒，代表特定的瞬间</li> <li>SimpleDateFormat：格式和解析日期的类，SimpleDateFormat格式化和解析日期的具体类。它允许格式化（日期-&gt;文本）、解析（文本-&gt;日期）和规范化</li></ol></li> <li><p>第二代日期类</p> <ol><li><p>第二代日期类，主要就是Calendar类（日历）</p> <p><code>public abstract class Calendar extends Object implements Serializable,Cloneable,Comparable&lt;Calendar&gt;</code></p></li> <li><p>Calendar类是一个抽象类，它为特定瞬间与一组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法</p></li></ol></li> <li><p>第三代日期类</p> <p>前面两代日期类的不足分析</p> <p>JDK1.0中包含一个java.util.Date类，但是它的大多数方法已经在JDK1.1引入Calendar类之后被弃用了。而Calendar也存在问题是：</p> <ol><li>可变性：像日期和时间这样的类应该是不可变的</li> <li>偏移性：Date中的年份是从1900开始的，而月份都从0开始</li> <li>格式化：格式化只对Date有用，Calendar则不行</li> <li>此外，它们也不是线程安全的；不能处理闰秒等（每隔2天，多出1s）</li></ol></li> <li><p>第三代日期类常见方法</p> <ol><li><p>LocalDate（日期）、LocalTime（时间）、LocalDateTime（日期时间）</p> <p>LocalDate只包含日期，可以获取日期字段</p> <p>LocalTime只包含时间，可以获取时间字段</p> <p>LocalDateTime包含日期+时间，可以获取日期和时间字段</p></li> <li><p>DateTimeFormatter格式日期类</p> <p>类似于SimpleDateFormat</p> <p>DateTimeFormat dtf = DateTimeFormatter.ofPattern(格式);</p> <p>String str = dtf.format(日期对象);</p></li> <li><p>Instant时间戳</p> <p>类似于Date</p> <p>提供了一系列和Date类转换的方式</p> <p>Instant -----&gt;Date：</p> <p>Date date = Date.from(instant);</p> <p>Date -----&gt;Instant：</p> <p>Instant instant = date.toInstant();</p></li> <li><p>第三代日期类更多方法</p> <ul><li>LocalDateTime类</li> <li>MonthDay类：检查重复事件</li> <li>是否是闰年</li> <li>增加日期的某个部分</li> <li>使用plus方法测试增加时间的某个部分</li> <li>使用minus方法测试查看一年前和一年后的日期</li></ul></li></ol></li></ul> <h4 id="system类"><a href="#system类" class="header-anchor">#</a> System类</h4> <ul><li><p>System类常见方法</p> <ol><li><p>exit退出当前程序</p></li> <li><p>arraycopy：复制数组元素，比较适合底层调用，一般使用Arrays.copyOf完成复制数组</p> <p><code>int[] src = {1, 2, 3};</code></p> <p><code>int[] dest = new int[3];</code></p> <p><code>System.arraycopy(src, 0, dest, 0, 3);</code></p></li> <li><p>currentTimeMillens：返回当前时间距离1970-1-1的毫秒数</p></li> <li><p>gc：运行垃圾回收机制System.gc()</p></li></ol></li></ul> <h4 id="arrays类"><a href="#arrays类" class="header-anchor">#</a> Arrays类</h4> <ul><li><p>常见方法</p> <ol><li><p>toString返回数组的字符串形式<code>Arrays.toString(arr)</code></p></li> <li><p>sort排序（自然排序和定制排序）<code>Integer arr[] = {1, -1, 7, 0, 89};</code></p></li> <li><p>binarySearch通过二分搜索法进行查找，要求必须排好序<code>int index = Arrays.binarySearch(arr, 3);</code></p></li> <li><p>copyOf 数组元素的复制<code>Integer[] newArr = Arrays.copyOf(arr, arr.length);</code></p></li> <li><p>fill数组元素的填充<code>Integer[] num = new Integer[]{9, 3, 2};</code></p> <p><code>Arrays.fill(num, 99);</code></p></li> <li><p>equals比较两个数组元素内容是否完全一致<code>boolean equals = Arrays.equals(arr, arr2);</code></p></li> <li><p>asList将一组值，转换成list<code>List&lt;Integer&gt; asList = Arrays.asList(2, 3, 4, 5, 6, 1);</code></p> <p><code>System.out.println(&quot;asList=&quot; + asList);</code></p></li></ol></li></ul> <h4 id="biginteger类和bigdecimal类"><a href="#biginteger类和bigdecimal类" class="header-anchor">#</a> BigInteger类和BigDecimal类</h4> <ul><li>应用场景
<ol><li>BigInteger适合保存比较大的整型</li> <li>BigDecimal适合保存精度更高的浮点型（小数）</li></ol></li> <li>BigInteger和BigDecimal常见方法
<ol><li>add 加</li> <li>subtract 减</li> <li>multiply 乘</li> <li>divide 除</li></ol></li></ul> <h3 id="集合"><a href="#集合" class="header-anchor">#</a> 集合</h3> <h4 id="集合框架体系"><a href="#集合框架体系" class="header-anchor">#</a> 集合框架体系</h4> <ul><li><p>数组的不足</p> <ol><li>长度开始时必须指定，而且一旦指定，不能更改</li> <li>保存的必须为同一类型的元素</li> <li>使用数组进行增加元素的示意代码，比较麻烦</li></ol></li> <li><p>集合的理解和好处</p> <ol><li>可以动态保存任意多个对象，使用比较方便！</li> <li>提供了一系列方便的操作对象的方法：add、remove、set、get等</li> <li>使用集合添加，删除新元素的示意代码，简洁明了</li></ol></li> <li><p>集合框架图</p> <p><img src="Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9B%BE.png" alt=""></p> <p>解读：</p> <ol><li>集合主要是两组（单列集合，双列集合）</li> <li>Collection接口有两个重要的子接口 List  Set，他们的实现子类都是单列集合</li> <li>Map接口的实现子类，是双列集合，存放的是 key-value</li></ol></li></ul> <h4 id="collection接口"><a href="#collection接口" class="header-anchor">#</a> Collection接口</h4> <ul><li><p>Collection接口实现类的特点</p> <ol><li>collection实现子类可以存放多个元素，每个元素可以是Object</li> <li>有些Collection的实现类，可以存放重复的元素，有些不可以</li> <li>有些Collection的实现类，有些是有序的（List），有些不是有序的（Set）</li> <li>Collection接口没有直接的实现子类，是通过它的子接口Set和List来实现的</li></ol></li> <li><p>Collection接口常用方法</p> <ol><li>add：添加单个元素</li> <li>remove：删除指定元素</li> <li>contains：查找元素是否存在</li> <li>size：获取元素个数</li> <li>isEmpty：判断是否为空</li> <li>clear：清空</li> <li>addAll：添加多个元素</li> <li>containsAll：查找多个元素是否都存在</li> <li>removeAll：删除多个元素</li></ol></li> <li><p>Collection接口遍历元素方式1-使用Iterator（迭代器）</p> <ul><li><p>基本介绍</p> <p><img src="Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/Iterator%E7%BB%93%E6%9E%84.png" alt=""></p> <ol><li>Iterator对象称为迭代器，主要用于遍历Collection集合中的元素</li> <li>所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器</li> <li>Iterator的结构</li> <li>Iterator仅用于遍历集合，Iterator本身并不存放对象</li></ol></li> <li><p>迭代器的执行原理</p> <p><code>Iterator iterator = coll.iterator();//得到一个集合的迭代器</code></p> <p><code>//hasNext()：判断是否还有下一个元素</code></p> <p><code>while(iterator.hasNext()){</code></p> <p><code>//next()作用：①指针下移 ②将下移以后集合位置上的元素返回</code></p> <p><code>System.out.println(iterator.next());</code></p> <p><code>}</code></p> <p><img src="Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86.png" alt=""></p> <p>注意：在调用iterator.nexxt()方法之前必须调用iterator.hasNext()进行检测。若不调用，且下一条记录无效，直接调用iterator.next()会抛出NoSuchElementException异常。</p></li></ul></li> <li><p>Collection接口遍历对象方式2-for循环增强</p> <p>增强for循环，可以代替iterator迭代器，特点：增强for就是简化版的iterator，本质一样。只能用于遍历集合或数组。</p> <ul><li><p>基本语法</p> <p><code>for(元素类型 元素名：集合名或数组名){</code></p> <p>​	<code>访问元素</code></p> <p><code>}</code></p></li></ul></li> <li><p>List接口和常用方法</p> <ul><li><p>List接口基本介绍</p> <p>List接口是Collection接口的子接口</p> <ol><li><p>List集合类中元素有序(即添加顺序和取出顺序一致)、且可重复</p></li> <li><p>List集合中的每个元素都有其对应的顺序索引，即支持索引</p></li> <li><p>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素</p></li> <li><p>JDK API中List接口的实现类有：</p> <p>常用的有：ArrayList、LinkedList和Vector</p></li></ol></li> <li><p>List接口的常用方法</p> <p>List集合里添加了一些根据索引来操作集合元素的方法</p> <ol><li>void add(int index,Object ele)：在index位置插入ele元素</li> <li>boolean addAll(int index,Collection eles)：从index位置开始将eles中的所有元素添加进来</li> <li>Object get(int index)：获取指定index位置的元素</li> <li>int indexOf(Object obj)：返回obj在集合中首次出现的位置</li> <li>int lastIndexOf(Object obj)：返回obj在当前集合中末次出现的位置</li> <li>Object remove(int index)：移除指定index位置的元素，并返回此元素</li> <li>Object set(int index,Object ele)：设置指定index位置的元素为ele，相当于是替换</li> <li>List subList(int fromIndex,int toIndex)：返回从fromIndex到toIndex位置的子集合</li></ol></li> <li><p>List的三种遍历方式</p> <ol><li><p>方式一：使用iterator</p> <p><code>Iterator iter = col.iterator();</code></p> <p><code>while(iter.hasNext()){</code></p> <p>​	<code>Object o = iter.next();</code></p> <p><code>}</code></p></li> <li><p>方式二：使用增强for</p> <p><code>for(Object o:col){</code></p> <p><code>}</code></p></li> <li><p>方式三：使用普通for</p> <p><code>for(int i = 0; i&lt;list.size(); i++){</code></p> <p>​	<code>Object object = list.get(i);</code></p> <p>​	<code>System.out.println(object);</code></p> <p><code>}</code></p> <p>说明：使用LinkedList完成使用方式和ArrayList一样</p></li></ol></li></ul></li> <li><p>ArrayList底层结构和源码分析</p> <ul><li><p>ArrayList的注意事项</p> <ol><li>permits all elements, including null, ArrayList可以加入null，多个null也可以</li> <li>ArrayList是由数组来实现数据存储的</li> <li>ArrayList基本等同于Vector，除了ArrayList是线程不安全(执行效率高)看源码，在多线程情况下，不建议使用ArrayList</li></ol></li> <li><p>ArrayList的底层操作机制源码分析（重点，难点）</p> <ol><li><p>ArrayList中维护了一个Object类型的数组elementData</p> <p><code>transient Object[] elementData;// transient 表示瞬间，短暂的，表示该属性不会被序列化</code></p></li> <li><p>当创建对象时，如果使用的是无参构造器，则初始elementData容量为0（jdk7是10）</p></li> <li><p>当添加元素时：先判断是否需要扩容，如果需要扩容，则调用grow方法，否则直接添加元素到合适位置</p></li> <li><p>如果使用的是无参构造器，如果第一次添加，需要扩容的话，则扩容elementData为10，如果需要再次扩容的话，则扩容elementData为1.5倍</p></li> <li><p>如果使用的是指定容量capacity的构造器，则初始elementData容量为capacity</p></li> <li><p>如果使用的是指定容量capacity的构造器，如果需要扩容，则直接扩容elementData为1.5倍</p></li></ol> <div class="language-注释 extra-class"><pre class="language-text"><code>注意：IDEA默认情况下，Debug显示的数据是简化后的，如果希望看到完整的数据，需要做设置Build，Execution，Deployment=》Debugger=》Data Views=》Java中取消勾选Enable alternative view for Collections classes
</code></pre></div></li></ul></li> <li><p>Vector底层结构和源码剖析</p> <ul><li><p>Vector的基本介绍</p> <ol><li><p>Vector类的定义说明</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Vector</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span><span class="token class-name">RandomAccess</span><span class="token punctuation">,</span><span class="token class-name">Cloneable</span><span class="token punctuation">,</span><span class="token class-name">Serializable</span>
</code></pre></div></li> <li><p>Vector底层也是一个对象数组</p> <p><code>protected Object[] elementData;</code></p></li> <li><p>Vector是线程同步的，即线程安全，Vector类的操作方法带有synchronized</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">&gt;=</span> elementCount<span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ArrayIndexOutOfBoundsException</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>在开发中，需要线程同步安全时，考虑使用Vector</p></li></ol></li> <li><p>Vector和ArrayList的比较</p> <p><img src="Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/Vector%E5%92%8CArrayList%E7%9A%84%E6%AF%94%E8%BE%83.png" alt=""></p></li></ul></li> <li><p>LinkedList底层结构</p> <ul><li><p>LinkedList的全面说明</p> <ol><li>LinkedList实现了双向链表和双端队列特点</li> <li>可以添加任意元素（元素可以重复），包括null</li> <li>线程不安全，没有实现同步</li></ol></li> <li><p>LinkedList的底层操作机制</p> <ol><li><p>LinkedList底层维护了一个双向链表</p></li> <li><p>LinkedList中维护了两个属性first和last分别指向首结点和尾结点</p></li> <li><p>每个结点（Node对象），里面又维护了prev、next、item三个属性，其中通过prev指向前一个，通过next指向后一个结点。最终实现双向链表</p></li> <li><p>所有LinkedList的元素的添加和删除，不是通过数组完成的，相对来说效率较高</p> <p><img src="Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/LinkedList%E7%9A%84%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C%E6%9C%BA%E5%88%B6.png" alt=""></p></li></ol></li> <li><p>ArrayList和LinkedList的比较</p> <p><img src="Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/ArrayList%E5%92%8CLinkedList%E7%9A%84%E6%AF%94%E8%BE%83.png" alt=""></p> <p>如何选择ArrayList和LinkedList：</p> <ol><li>如果我们改查的操作多，选择ArrayList</li> <li>如果我们增删的操作多，选择LinkedList</li> <li>一般来说，在程序中，80%-90%都是查询，因此大部分情况下会选择ArrayList</li> <li>在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList，另外一个模块是LinkedList，也就是说，要根据业务来进行选择</li></ol></li></ul></li> <li><p>Set接口和常用方法</p> <ul><li><p>Set接口基本介绍</p> <ol><li><p>无序（添加和取出的顺序不一致），没有索引</p></li> <li><p>不允许重复元素，所以最多包含一个null</p></li> <li><p>JDK API中Set接口的实现类有：</p> <p><img src="Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/Set%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png" alt=""></p></li></ol></li> <li><p>Set接口的常用方法</p> <p>和List接口一样，Set接口也是Collection的子接口，因此，常用方法和Collection接口一样</p></li> <li><p>Set接口的遍历方式</p> <p>同Collection的遍历方式一样，因为Set接口是Collection接口的子接口。</p> <ol><li>可以使用迭代器</li> <li>增强for</li> <li>不能使用索引的方式来获取</li></ol></li></ul></li> <li><p>Set接口实现类-HashSet</p> <ul><li><p>HashSet的全面说明</p> <ol><li><p>HashSet实现了Set接口</p></li> <li><p>HashSet实际上是HashMap</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>可以存放null值，但是只能有一个null</p></li> <li><p>HashSet不保证元素是有序的，取决于hash后，再确定索引的结果</p></li> <li><p>不能有重复元素/对象。在前面Set接口使用已经讲过</p></li></ol></li> <li><p>HashSet底层机制说明</p> <p>分析HashSet底层是HashMap，HashMap底层是（数组+链表+红黑树）</p> <p><img src="Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/HashSet%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%E8%AF%B4%E6%98%8E.png" alt=""></p> <ul><li>分析HashSet的添加元素底层是如何实现(hash()+equals())
<ol><li>HashSet底层是HashMap</li> <li>添加一个元素时，先得到hash值 -&gt; 会转成 -&gt; 索引值</li> <li>找到存储数据表table，看这个索引位置是否已经存放的有元素</li> <li>如果没有，直接加入</li> <li>如果有，调用equals比较，如果相同，就放弃添加，如果不相同，则添加到最后</li> <li>在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD（默认是8），并且table的大小&gt;=MIN_TREEIFY_CAPACITY（默认是64），就会进行树化（红黑树)</li></ol></li> <li>分析HashSet的扩容和转成红黑树机制
<ol><li>HashSet底层是HashMap，第一次添加时，table数组扩容到16，临界值(threshold)是16*加载因子(loadFactor)是0.75=12</li> <li>如果table数组使用到了临界值12，就会扩容到16*2=32，新的临界值就是32*0.75=24，依次类推</li> <li>在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)，并且table的大小&gt;=MIN_TREEIFY_CAPACITY(默认是64)，就会进行树化(红黑树)，否则仍然采用数组扩容机制</li></ol></li></ul></li></ul></li> <li><p>Set接口实现类-LinkedHashSet</p> <ul><li><p>LinkedHashSet的全面说明</p> <ol><li>LinkedHashSet是HashSet的子类</li> <li>LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表</li> <li>LinkedHashSet根据元素的hashCode值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的</li> <li>LinkedHashSet不允许添重复元素</li></ol></li> <li><p>LinkedHashSet底层机制示意图</p> <p><img src="Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/LinkedHashSet%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p> <p>说明</p> <ol><li><p>在LinkedHashSet中维护了一个hash表和双向链表(LinkedHashSet有head和tail)</p></li> <li><p>每一个节点有pre和next属性，这样可以形成双向链表</p></li> <li><p>在添加一个元素时，先求hash值，在求索引，确定该元素在hashtable的位置，然后将添加的元素加入到双向链表(如果已经存在，不添加【原则和和hashset一样】)</p> <div class="language-java extra-class"><pre class="language-java"><code>tail<span class="token punctuation">.</span>next <span class="token operator">=</span> newElement<span class="token punctuation">;</span> <span class="token comment">// 简单指定</span>
newElement<span class="token punctuation">.</span>pre <span class="token operator">=</span> tail<span class="token punctuation">;</span>
tail <span class="token operator">=</span> newElement<span class="token punctuation">;</span>
</code></pre></div></li> <li><p>这样的话，我们遍历LinkedHashSet也能确保插入顺序和遍历顺序一致</p></li></ol></li></ul></li></ul> <h4 id="map接口"><a href="#map接口" class="header-anchor">#</a> Map接口</h4> <ul><li><p>Map接口和常用方法</p> <ul><li><p>Map接口实现类的特点</p> <p>注意：这里讲的是JDK8的Map接口特点</p> <ol><li><p>Map与Collection并列存在。用于保存具有映射关系的数据：key-value（双列元素）</p></li> <li><p>Map中的key和value可以是任何引用类型的数据，会封装到HashMap$Node对象中</p></li> <li><p>Map中的key不允许重复，原因和HashSet一样，前面分析过源码</p></li> <li><p>Map中的value可以重复</p></li> <li><p>Map的key可以为null，value也可以为null，注意key为null，只能有一个，value为null，可以多个</p></li> <li><p>常用String类作为Map的key</p></li> <li><p>key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value</p></li> <li><p>Map存放数据的key-value示意图，一对k-v是放在一个HashMap$Node中的，有因为Node实现了Entry接口，有些书上也说，一对k-v就是一个Entry</p> <p><img src="Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/Map%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%89%B9%E7%82%B9.png" alt=""></p></li></ol></li> <li><p>Map体系的继承图</p> <p><img src="Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/Map%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%9B%BE.png" alt=""></p></li> <li><p>Map接口常用方法</p> <ol><li>put：添加</li> <li>remove：根据键删除映射关系</li> <li>get：根据键获取值</li> <li>size：获取元素个数</li> <li>isEmpty：判断个数是否为0</li> <li>clear：清除</li> <li>containsKey：查找键是否存在</li></ol></li> <li><p>Map接口遍历方法</p> <ul><li><p>Map遍历的示意图（比List，和Set复杂点，但是基本原理一样）</p></li> <li><p>Map遍历方式案例演示</p> <ol><li>containsKey：查找键是否存在</li> <li>keySet：获取所有的键</li> <li>entrySet：获取所有关系</li> <li>values：获取所有的值</li></ol></li></ul></li></ul></li> <li><p>Map接口实现类-HashMap</p> <ul><li><p>HashMap小结</p> <ol><li>Map接口的常用实现类：HashMap、Hashtable和Properties</li> <li>HashMap是Map接口使用频率最高的实现类</li> <li>HashMap是以key-val对的方式来存储数据</li> <li>key不能重复，但是值可以重复，允许使用null键和null值</li> <li>如果添加相同的key，则会覆盖原来的key-val，等同于修改（key不会替换，val会替换）</li> <li>与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的</li> <li>HashMap没有实现同步，因此是线程不安全的，方法没有做同步互斥操作，没有synchronized</li></ol></li> <li><p>HashMap底层机制及源码剖析</p> <p><img src="Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/HashMap%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p> <ol><li>(k,v)是一个Node实现了Map.Entry&lt;K,V&gt;，查看HashMap的源码可以看到</li> <li>jdk7.0的hashmap底层实现[数组+链表]，jdk8.0底层[数组+链表+红黑树]</li></ol> <p>扩容机制：（和HashSet相同）</p> <ol><li>HashMap底层维护了Node类型的数组table，默认为null</li> <li>当创建对象时，将加载因子(loadfactor)初始化为0.75</li> <li>当添加key-val时，通过key的哈希值得到在table的索引。然后判断该索引处是否有元素，如果没有元素直接添加。如果该索引处有元素，继续判断该元素的key和准备加入的key是否相等，如果相等，则直接替换val；如果不相等需要判断是树结构还是链表结构，做出相应处理。如果添加时发现容量不够，则需要扩容</li> <li>第1次添加，则需要扩容table容量为16，临界值(threshold)为12</li> <li>以后再扩容，则需要扩容table容量为原来的2倍，临界值为原来的2倍，即24，依此类推</li> <li>在Java8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD（默认是8），并且table的大小&gt;=MIN_TREEIFY_CAPACITY（默认64），就会进行树化（红黑树）</li></ol></li></ul></li> <li><p>Map接口实现类-Hashtable</p> <ul><li><p>HashTable的基本介绍</p> <ol><li>存放的元素是键值对：即K-V</li> <li>hashtable的键和值都不能为null，否则会抛出NullPointerException</li> <li>hashTable使用方法基本上和HashMap一样</li> <li>hashTable是线程安全的(synchronized)，hashMap是线程不安全的</li></ol></li> <li><p>Hashtable和HashMap对比</p> <p><img src="Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3/Hashtable%E5%92%8CHashMap%E5%AF%B9%E6%AF%94.png" alt=""></p></li></ul></li> <li><p>Map接口实现类-Properties</p> <ul><li><p>基本介绍</p> <ol><li><p>Properties类继承自Hashtable类并且实现了Map接口，也是使用一种键值对的形式来保存数据</p></li> <li><p>他的使用特点和Hashtable类似</p></li> <li><p>Properties还可以用于从 xxx.properties 文件中，加载数据到Properties类对象，并进行读取和修改</p></li> <li><p>说明：工作后 xxx.properties 文件通常作为配置文件，这个知识点在IO流举例，有兴趣可先看文章</p> <p>https://www.cnblogs.com/xudong-bupt/p/3758136.html</p></li></ol></li></ul></li> <li><p>总结-开发中如何选择集合实现类</p> <p>在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行选择，分析如下：</p> <ol><li><p>先判断存储的类型（一组对象[单列]或一组键值对[双列]）</p></li> <li><p>一组对象[单列]：Collection接口</p> <ul><li><p>允许重复：List</p> <ul><li>增删多：LinkedList [底层维护了一个双向链表]</li> <li>改查多：ArrayList [底层维护了Object类型的可变数组]</li></ul></li> <li><p>不允许重复：Set</p> <ul><li>无序：HashSet [底层是HashMap，维护了一个哈希表，即（数组+链表+红黑树）]</li> <li>排序：TreeSet</li> <li>插入和取出顺序一致：LinkedHashSet [底层LinkedHashMap的底层HashMap]，维护数组+双向链表</li></ul></li></ul></li> <li><p>一组键值对[双列]：Map</p> <ul><li>键无序：HashMap [底层是：哈希表 jdk7：数组+链表，jdk8：数组+链表+红黑树]</li> <li>键排序：TreeMap</li> <li>键插入和取出顺序一致：LinkedHashMap</li> <li>读取文件 Properties</li></ul></li></ol></li></ul> <h4 id="collections工具类的使用"><a href="#collections工具类的使用" class="header-anchor">#</a> Collections工具类的使用</h4> <ul><li>Collections工具类
<ul><li>Collections工具类介绍
<ol><li>Collections是一个操作Set、List和Map等集合的工具类</li> <li>Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作</li></ol></li> <li>排序操作：（均为static方法）
<ol><li>reverse(List)：反转List中元素的顺序</li> <li>shuffle(List)：对List集合元素进行随机排序</li> <li>sort(List)：根据元素的自然顺序对指定的List集合元素按升序排序</li> <li>sort(List, Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序</li> <li>swap(List, int, int)：将指定list集合中的i处元素和j处元素进行交换</li></ol></li> <li>查找、替换
<ol><li>Object max(Collection)：根据元素的自然排序，返回给指定集合中的最大元素</li> <li>Object max(Collection, Comparator)：根据Comparator指定的顺序，返回给定集合中的最大元素</li> <li>Object min(Collection)</li> <li>Object min(Collection, Comparator)</li> <li>int frequency(Collection, Object)：返回指定集合中指定元素的出现次数</li> <li>void copy(List dest, List src)：将src中的内容复制到dest中</li> <li>boolean replaceAll(List list, Object oldVal, Object newVal)：使用新值替换List对象的所有旧值</li></ol></li></ul></li></ul></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">2023/12/19 22:03:32</span></div></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/vuepressblog/Java/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3%E4%B8%AD%E7%AF%87.html#二、提高编程能力" class="sidebar-link reco-side-二、提高编程能力" data-v-b57cc07c>二、提高编程能力</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepressblog/Java/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3%E4%B8%AD%E7%AF%87.html#面向对象编程-高级部分" class="sidebar-link reco-side-面向对象编程-高级部分" data-v-b57cc07c>面向对象编程（高级部分）</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepressblog/Java/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3%E4%B8%AD%E7%AF%87.html#枚举和注解" class="sidebar-link reco-side-枚举和注解" data-v-b57cc07c>枚举和注解</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepressblog/Java/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3%E4%B8%AD%E7%AF%87.html#异常-exception" class="sidebar-link reco-side-异常-exception" data-v-b57cc07c>异常-Exception</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepressblog/Java/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3%E4%B8%AD%E7%AF%87.html#常用类" class="sidebar-link reco-side-常用类" data-v-b57cc07c>常用类</a></li><li class="level-3" data-v-b57cc07c><a href="/vuepressblog/Java/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9F%A9%E9%A1%BA%E5%B9%B3%E4%B8%AD%E7%AF%87.html#集合" class="sidebar-link reco-side-集合" data-v-b57cc07c>集合</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><!----><div></div><!----><div class="RibbonAnimation"></div></div></div>
    <script src="/vuepressblog/assets/js/app.80634c63.js" defer></script><script src="/vuepressblog/assets/js/3.ef187fa4.js" defer></script><script src="/vuepressblog/assets/js/1.93e2b1ee.js" defer></script><script src="/vuepressblog/assets/js/19.ae4fe37d.js" defer></script><script src="/vuepressblog/assets/js/9.76c7ad5c.js" defer></script>
  </body>
</html>
